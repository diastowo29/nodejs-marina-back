
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model customers
 * 
 */
export type customers = $Result.DefaultSelection<Prisma.$customersPayload>
/**
 * Model products_img
 * 
 */
export type products_img = $Result.DefaultSelection<Prisma.$products_imgPayload>
/**
 * Model channel
 * 
 */
export type channel = $Result.DefaultSelection<Prisma.$channelPayload>
/**
 * Model store
 * 
 */
export type store = $Result.DefaultSelection<Prisma.$storePayload>
/**
 * Model products
 * 
 */
export type products = $Result.DefaultSelection<Prisma.$productsPayload>
/**
 * Model order_items
 * 
 */
export type order_items = $Result.DefaultSelection<Prisma.$order_itemsPayload>
/**
 * Model logistic
 * 
 */
export type logistic = $Result.DefaultSelection<Prisma.$logisticPayload>
/**
 * Model orders
 * 
 */
export type orders = $Result.DefaultSelection<Prisma.$ordersPayload>
/**
 * Model omnichat_user
 * 
 */
export type omnichat_user = $Result.DefaultSelection<Prisma.$omnichat_userPayload>
/**
 * Model omnichat
 * 
 */
export type omnichat = $Result.DefaultSelection<Prisma.$omnichatPayload>
/**
 * Model omnichat_line
 * 
 */
export type omnichat_line = $Result.DefaultSelection<Prisma.$omnichat_linePayload>
/**
 * Model zdconnector
 * 
 */
export type zdconnector = $Result.DefaultSelection<Prisma.$zdconnectorPayload>
/**
 * Model omnicrm
 * 
 */
export type omnicrm = $Result.DefaultSelection<Prisma.$omnicrmPayload>
/**
 * Model clients
 * 
 */
export type clients = $Result.DefaultSelection<Prisma.$clientsPayload>
/**
 * Model credent
 * 
 */
export type credent = $Result.DefaultSelection<Prisma.$credentPayload>
/**
 * Model integration
 * 
 */
export type integration = $Result.DefaultSelection<Prisma.$integrationPayload>
/**
 * Model return_line_item
 * 
 */
export type return_line_item = $Result.DefaultSelection<Prisma.$return_line_itemPayload>
/**
 * Model return_refund
 * 
 */
export type return_refund = $Result.DefaultSelection<Prisma.$return_refundPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customers.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customers.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.customers`: Exposes CRUD operations for the **customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.customersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products_img`: Exposes CRUD operations for the **products_img** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products_imgs
    * const products_imgs = await prisma.products_img.findMany()
    * ```
    */
  get products_img(): Prisma.products_imgDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.channelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.storeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.productsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order_items`: Exposes CRUD operations for the **order_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_items
    * const order_items = await prisma.order_items.findMany()
    * ```
    */
  get order_items(): Prisma.order_itemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.logistic`: Exposes CRUD operations for the **logistic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logistics
    * const logistics = await prisma.logistic.findMany()
    * ```
    */
  get logistic(): Prisma.logisticDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.ordersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.omnichat_user`: Exposes CRUD operations for the **omnichat_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Omnichat_users
    * const omnichat_users = await prisma.omnichat_user.findMany()
    * ```
    */
  get omnichat_user(): Prisma.omnichat_userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.omnichat`: Exposes CRUD operations for the **omnichat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Omnichats
    * const omnichats = await prisma.omnichat.findMany()
    * ```
    */
  get omnichat(): Prisma.omnichatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.omnichat_line`: Exposes CRUD operations for the **omnichat_line** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Omnichat_lines
    * const omnichat_lines = await prisma.omnichat_line.findMany()
    * ```
    */
  get omnichat_line(): Prisma.omnichat_lineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zdconnector`: Exposes CRUD operations for the **zdconnector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zdconnectors
    * const zdconnectors = await prisma.zdconnector.findMany()
    * ```
    */
  get zdconnector(): Prisma.zdconnectorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.omnicrm`: Exposes CRUD operations for the **omnicrm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Omnicrms
    * const omnicrms = await prisma.omnicrm.findMany()
    * ```
    */
  get omnicrm(): Prisma.omnicrmDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clients`: Exposes CRUD operations for the **clients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.clients.findMany()
    * ```
    */
  get clients(): Prisma.clientsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credent`: Exposes CRUD operations for the **credent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credents
    * const credents = await prisma.credent.findMany()
    * ```
    */
  get credent(): Prisma.credentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.integrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.return_line_item`: Exposes CRUD operations for the **return_line_item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Return_line_items
    * const return_line_items = await prisma.return_line_item.findMany()
    * ```
    */
  get return_line_item(): Prisma.return_line_itemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.return_refund`: Exposes CRUD operations for the **return_refund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Return_refunds
    * const return_refunds = await prisma.return_refund.findMany()
    * ```
    */
  get return_refund(): Prisma.return_refundDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    customers: 'customers',
    products_img: 'products_img',
    channel: 'channel',
    store: 'store',
    products: 'products',
    order_items: 'order_items',
    logistic: 'logistic',
    orders: 'orders',
    omnichat_user: 'omnichat_user',
    omnichat: 'omnichat',
    omnichat_line: 'omnichat_line',
    zdconnector: 'zdconnector',
    omnicrm: 'omnicrm',
    clients: 'clients',
    credent: 'credent',
    integration: 'integration',
    return_line_item: 'return_line_item',
    return_refund: 'return_refund'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "customers" | "products_img" | "channel" | "store" | "products" | "order_items" | "logistic" | "orders" | "omnichat_user" | "omnichat" | "omnichat_line" | "zdconnector" | "omnicrm" | "clients" | "credent" | "integration" | "return_line_item" | "return_refund"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      customers: {
        payload: Prisma.$customersPayload<ExtArgs>
        fields: Prisma.customersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          findFirst: {
            args: Prisma.customersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          findMany: {
            args: Prisma.customersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          create: {
            args: Prisma.customersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          createMany: {
            args: Prisma.customersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          delete: {
            args: Prisma.customersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          update: {
            args: Prisma.customersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          deleteMany: {
            args: Prisma.customersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.customersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          upsert: {
            args: Prisma.customersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.customersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.customersCountArgs<ExtArgs>
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      products_img: {
        payload: Prisma.$products_imgPayload<ExtArgs>
        fields: Prisma.products_imgFieldRefs
        operations: {
          findUnique: {
            args: Prisma.products_imgFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$products_imgPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.products_imgFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$products_imgPayload>
          }
          findFirst: {
            args: Prisma.products_imgFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$products_imgPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.products_imgFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$products_imgPayload>
          }
          findMany: {
            args: Prisma.products_imgFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$products_imgPayload>[]
          }
          create: {
            args: Prisma.products_imgCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$products_imgPayload>
          }
          createMany: {
            args: Prisma.products_imgCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.products_imgCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$products_imgPayload>[]
          }
          delete: {
            args: Prisma.products_imgDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$products_imgPayload>
          }
          update: {
            args: Prisma.products_imgUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$products_imgPayload>
          }
          deleteMany: {
            args: Prisma.products_imgDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.products_imgUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.products_imgUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$products_imgPayload>[]
          }
          upsert: {
            args: Prisma.products_imgUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$products_imgPayload>
          }
          aggregate: {
            args: Prisma.Products_imgAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts_img>
          }
          groupBy: {
            args: Prisma.products_imgGroupByArgs<ExtArgs>
            result: $Utils.Optional<Products_imgGroupByOutputType>[]
          }
          count: {
            args: Prisma.products_imgCountArgs<ExtArgs>
            result: $Utils.Optional<Products_imgCountAggregateOutputType> | number
          }
        }
      }
      channel: {
        payload: Prisma.$channelPayload<ExtArgs>
        fields: Prisma.channelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.channelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.channelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          findFirst: {
            args: Prisma.channelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.channelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          findMany: {
            args: Prisma.channelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>[]
          }
          create: {
            args: Prisma.channelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          createMany: {
            args: Prisma.channelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.channelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>[]
          }
          delete: {
            args: Prisma.channelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          update: {
            args: Prisma.channelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          deleteMany: {
            args: Prisma.channelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.channelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.channelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>[]
          }
          upsert: {
            args: Prisma.channelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.channelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.channelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      store: {
        payload: Prisma.$storePayload<ExtArgs>
        fields: Prisma.storeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.storeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.storeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          findFirst: {
            args: Prisma.storeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.storeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          findMany: {
            args: Prisma.storeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>[]
          }
          create: {
            args: Prisma.storeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          createMany: {
            args: Prisma.storeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.storeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>[]
          }
          delete: {
            args: Prisma.storeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          update: {
            args: Prisma.storeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          deleteMany: {
            args: Prisma.storeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.storeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.storeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>[]
          }
          upsert: {
            args: Prisma.storeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.storeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.storeCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      products: {
        payload: Prisma.$productsPayload<ExtArgs>
        fields: Prisma.productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findFirst: {
            args: Prisma.productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findMany: {
            args: Prisma.productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          create: {
            args: Prisma.productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          createMany: {
            args: Prisma.productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          delete: {
            args: Prisma.productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          update: {
            args: Prisma.productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          deleteMany: {
            args: Prisma.productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.productsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          upsert: {
            args: Prisma.productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.productsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      order_items: {
        payload: Prisma.$order_itemsPayload<ExtArgs>
        fields: Prisma.order_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          findFirst: {
            args: Prisma.order_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          findMany: {
            args: Prisma.order_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>[]
          }
          create: {
            args: Prisma.order_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          createMany: {
            args: Prisma.order_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.order_itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>[]
          }
          delete: {
            args: Prisma.order_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          update: {
            args: Prisma.order_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          deleteMany: {
            args: Prisma.order_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.order_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.order_itemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>[]
          }
          upsert: {
            args: Prisma.order_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          aggregate: {
            args: Prisma.Order_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder_items>
          }
          groupBy: {
            args: Prisma.order_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Order_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Order_itemsCountAggregateOutputType> | number
          }
        }
      }
      logistic: {
        payload: Prisma.$logisticPayload<ExtArgs>
        fields: Prisma.logisticFieldRefs
        operations: {
          findUnique: {
            args: Prisma.logisticFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logisticPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.logisticFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logisticPayload>
          }
          findFirst: {
            args: Prisma.logisticFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logisticPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.logisticFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logisticPayload>
          }
          findMany: {
            args: Prisma.logisticFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logisticPayload>[]
          }
          create: {
            args: Prisma.logisticCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logisticPayload>
          }
          createMany: {
            args: Prisma.logisticCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.logisticCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logisticPayload>[]
          }
          delete: {
            args: Prisma.logisticDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logisticPayload>
          }
          update: {
            args: Prisma.logisticUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logisticPayload>
          }
          deleteMany: {
            args: Prisma.logisticDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.logisticUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.logisticUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logisticPayload>[]
          }
          upsert: {
            args: Prisma.logisticUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logisticPayload>
          }
          aggregate: {
            args: Prisma.LogisticAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogistic>
          }
          groupBy: {
            args: Prisma.logisticGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogisticGroupByOutputType>[]
          }
          count: {
            args: Prisma.logisticCountArgs<ExtArgs>
            result: $Utils.Optional<LogisticCountAggregateOutputType> | number
          }
        }
      }
      orders: {
        payload: Prisma.$ordersPayload<ExtArgs>
        fields: Prisma.ordersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ordersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ordersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          findFirst: {
            args: Prisma.ordersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ordersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          findMany: {
            args: Prisma.ordersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          create: {
            args: Prisma.ordersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          createMany: {
            args: Prisma.ordersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ordersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          delete: {
            args: Prisma.ordersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          update: {
            args: Prisma.ordersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          deleteMany: {
            args: Prisma.ordersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ordersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ordersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          upsert: {
            args: Prisma.ordersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          aggregate: {
            args: Prisma.OrdersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrders>
          }
          groupBy: {
            args: Prisma.ordersGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ordersCountArgs<ExtArgs>
            result: $Utils.Optional<OrdersCountAggregateOutputType> | number
          }
        }
      }
      omnichat_user: {
        payload: Prisma.$omnichat_userPayload<ExtArgs>
        fields: Prisma.omnichat_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.omnichat_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.omnichat_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_userPayload>
          }
          findFirst: {
            args: Prisma.omnichat_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.omnichat_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_userPayload>
          }
          findMany: {
            args: Prisma.omnichat_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_userPayload>[]
          }
          create: {
            args: Prisma.omnichat_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_userPayload>
          }
          createMany: {
            args: Prisma.omnichat_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.omnichat_userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_userPayload>[]
          }
          delete: {
            args: Prisma.omnichat_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_userPayload>
          }
          update: {
            args: Prisma.omnichat_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_userPayload>
          }
          deleteMany: {
            args: Prisma.omnichat_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.omnichat_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.omnichat_userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_userPayload>[]
          }
          upsert: {
            args: Prisma.omnichat_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_userPayload>
          }
          aggregate: {
            args: Prisma.Omnichat_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOmnichat_user>
          }
          groupBy: {
            args: Prisma.omnichat_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Omnichat_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.omnichat_userCountArgs<ExtArgs>
            result: $Utils.Optional<Omnichat_userCountAggregateOutputType> | number
          }
        }
      }
      omnichat: {
        payload: Prisma.$omnichatPayload<ExtArgs>
        fields: Prisma.omnichatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.omnichatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.omnichatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichatPayload>
          }
          findFirst: {
            args: Prisma.omnichatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.omnichatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichatPayload>
          }
          findMany: {
            args: Prisma.omnichatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichatPayload>[]
          }
          create: {
            args: Prisma.omnichatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichatPayload>
          }
          createMany: {
            args: Prisma.omnichatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.omnichatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichatPayload>[]
          }
          delete: {
            args: Prisma.omnichatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichatPayload>
          }
          update: {
            args: Prisma.omnichatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichatPayload>
          }
          deleteMany: {
            args: Prisma.omnichatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.omnichatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.omnichatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichatPayload>[]
          }
          upsert: {
            args: Prisma.omnichatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichatPayload>
          }
          aggregate: {
            args: Prisma.OmnichatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOmnichat>
          }
          groupBy: {
            args: Prisma.omnichatGroupByArgs<ExtArgs>
            result: $Utils.Optional<OmnichatGroupByOutputType>[]
          }
          count: {
            args: Prisma.omnichatCountArgs<ExtArgs>
            result: $Utils.Optional<OmnichatCountAggregateOutputType> | number
          }
        }
      }
      omnichat_line: {
        payload: Prisma.$omnichat_linePayload<ExtArgs>
        fields: Prisma.omnichat_lineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.omnichat_lineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_linePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.omnichat_lineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_linePayload>
          }
          findFirst: {
            args: Prisma.omnichat_lineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_linePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.omnichat_lineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_linePayload>
          }
          findMany: {
            args: Prisma.omnichat_lineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_linePayload>[]
          }
          create: {
            args: Prisma.omnichat_lineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_linePayload>
          }
          createMany: {
            args: Prisma.omnichat_lineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.omnichat_lineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_linePayload>[]
          }
          delete: {
            args: Prisma.omnichat_lineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_linePayload>
          }
          update: {
            args: Prisma.omnichat_lineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_linePayload>
          }
          deleteMany: {
            args: Prisma.omnichat_lineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.omnichat_lineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.omnichat_lineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_linePayload>[]
          }
          upsert: {
            args: Prisma.omnichat_lineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnichat_linePayload>
          }
          aggregate: {
            args: Prisma.Omnichat_lineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOmnichat_line>
          }
          groupBy: {
            args: Prisma.omnichat_lineGroupByArgs<ExtArgs>
            result: $Utils.Optional<Omnichat_lineGroupByOutputType>[]
          }
          count: {
            args: Prisma.omnichat_lineCountArgs<ExtArgs>
            result: $Utils.Optional<Omnichat_lineCountAggregateOutputType> | number
          }
        }
      }
      zdconnector: {
        payload: Prisma.$zdconnectorPayload<ExtArgs>
        fields: Prisma.zdconnectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.zdconnectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zdconnectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.zdconnectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zdconnectorPayload>
          }
          findFirst: {
            args: Prisma.zdconnectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zdconnectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.zdconnectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zdconnectorPayload>
          }
          findMany: {
            args: Prisma.zdconnectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zdconnectorPayload>[]
          }
          create: {
            args: Prisma.zdconnectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zdconnectorPayload>
          }
          createMany: {
            args: Prisma.zdconnectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.zdconnectorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zdconnectorPayload>[]
          }
          delete: {
            args: Prisma.zdconnectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zdconnectorPayload>
          }
          update: {
            args: Prisma.zdconnectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zdconnectorPayload>
          }
          deleteMany: {
            args: Prisma.zdconnectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.zdconnectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.zdconnectorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zdconnectorPayload>[]
          }
          upsert: {
            args: Prisma.zdconnectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zdconnectorPayload>
          }
          aggregate: {
            args: Prisma.ZdconnectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZdconnector>
          }
          groupBy: {
            args: Prisma.zdconnectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZdconnectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.zdconnectorCountArgs<ExtArgs>
            result: $Utils.Optional<ZdconnectorCountAggregateOutputType> | number
          }
        }
      }
      omnicrm: {
        payload: Prisma.$omnicrmPayload<ExtArgs>
        fields: Prisma.omnicrmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.omnicrmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnicrmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.omnicrmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnicrmPayload>
          }
          findFirst: {
            args: Prisma.omnicrmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnicrmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.omnicrmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnicrmPayload>
          }
          findMany: {
            args: Prisma.omnicrmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnicrmPayload>[]
          }
          create: {
            args: Prisma.omnicrmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnicrmPayload>
          }
          createMany: {
            args: Prisma.omnicrmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.omnicrmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnicrmPayload>[]
          }
          delete: {
            args: Prisma.omnicrmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnicrmPayload>
          }
          update: {
            args: Prisma.omnicrmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnicrmPayload>
          }
          deleteMany: {
            args: Prisma.omnicrmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.omnicrmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.omnicrmUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnicrmPayload>[]
          }
          upsert: {
            args: Prisma.omnicrmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$omnicrmPayload>
          }
          aggregate: {
            args: Prisma.OmnicrmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOmnicrm>
          }
          groupBy: {
            args: Prisma.omnicrmGroupByArgs<ExtArgs>
            result: $Utils.Optional<OmnicrmGroupByOutputType>[]
          }
          count: {
            args: Prisma.omnicrmCountArgs<ExtArgs>
            result: $Utils.Optional<OmnicrmCountAggregateOutputType> | number
          }
        }
      }
      clients: {
        payload: Prisma.$clientsPayload<ExtArgs>
        fields: Prisma.clientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          findFirst: {
            args: Prisma.clientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          findMany: {
            args: Prisma.clientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>[]
          }
          create: {
            args: Prisma.clientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          createMany: {
            args: Prisma.clientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clientsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>[]
          }
          delete: {
            args: Prisma.clientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          update: {
            args: Prisma.clientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          deleteMany: {
            args: Prisma.clientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clientsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>[]
          }
          upsert: {
            args: Prisma.clientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          aggregate: {
            args: Prisma.ClientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClients>
          }
          groupBy: {
            args: Prisma.clientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientsCountArgs<ExtArgs>
            result: $Utils.Optional<ClientsCountAggregateOutputType> | number
          }
        }
      }
      credent: {
        payload: Prisma.$credentPayload<ExtArgs>
        fields: Prisma.credentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.credentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.credentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credentPayload>
          }
          findFirst: {
            args: Prisma.credentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.credentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credentPayload>
          }
          findMany: {
            args: Prisma.credentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credentPayload>[]
          }
          create: {
            args: Prisma.credentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credentPayload>
          }
          createMany: {
            args: Prisma.credentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.credentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credentPayload>[]
          }
          delete: {
            args: Prisma.credentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credentPayload>
          }
          update: {
            args: Prisma.credentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credentPayload>
          }
          deleteMany: {
            args: Prisma.credentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.credentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.credentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credentPayload>[]
          }
          upsert: {
            args: Prisma.credentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credentPayload>
          }
          aggregate: {
            args: Prisma.CredentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredent>
          }
          groupBy: {
            args: Prisma.credentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CredentGroupByOutputType>[]
          }
          count: {
            args: Prisma.credentCountArgs<ExtArgs>
            result: $Utils.Optional<CredentCountAggregateOutputType> | number
          }
        }
      }
      integration: {
        payload: Prisma.$integrationPayload<ExtArgs>
        fields: Prisma.integrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.integrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.integrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integrationPayload>
          }
          findFirst: {
            args: Prisma.integrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.integrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integrationPayload>
          }
          findMany: {
            args: Prisma.integrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integrationPayload>[]
          }
          create: {
            args: Prisma.integrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integrationPayload>
          }
          createMany: {
            args: Prisma.integrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.integrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integrationPayload>[]
          }
          delete: {
            args: Prisma.integrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integrationPayload>
          }
          update: {
            args: Prisma.integrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integrationPayload>
          }
          deleteMany: {
            args: Prisma.integrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.integrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.integrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integrationPayload>[]
          }
          upsert: {
            args: Prisma.integrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.integrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.integrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
      return_line_item: {
        payload: Prisma.$return_line_itemPayload<ExtArgs>
        fields: Prisma.return_line_itemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.return_line_itemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_line_itemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.return_line_itemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_line_itemPayload>
          }
          findFirst: {
            args: Prisma.return_line_itemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_line_itemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.return_line_itemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_line_itemPayload>
          }
          findMany: {
            args: Prisma.return_line_itemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_line_itemPayload>[]
          }
          create: {
            args: Prisma.return_line_itemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_line_itemPayload>
          }
          createMany: {
            args: Prisma.return_line_itemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.return_line_itemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_line_itemPayload>[]
          }
          delete: {
            args: Prisma.return_line_itemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_line_itemPayload>
          }
          update: {
            args: Prisma.return_line_itemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_line_itemPayload>
          }
          deleteMany: {
            args: Prisma.return_line_itemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.return_line_itemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.return_line_itemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_line_itemPayload>[]
          }
          upsert: {
            args: Prisma.return_line_itemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_line_itemPayload>
          }
          aggregate: {
            args: Prisma.Return_line_itemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturn_line_item>
          }
          groupBy: {
            args: Prisma.return_line_itemGroupByArgs<ExtArgs>
            result: $Utils.Optional<Return_line_itemGroupByOutputType>[]
          }
          count: {
            args: Prisma.return_line_itemCountArgs<ExtArgs>
            result: $Utils.Optional<Return_line_itemCountAggregateOutputType> | number
          }
        }
      }
      return_refund: {
        payload: Prisma.$return_refundPayload<ExtArgs>
        fields: Prisma.return_refundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.return_refundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_refundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.return_refundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_refundPayload>
          }
          findFirst: {
            args: Prisma.return_refundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_refundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.return_refundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_refundPayload>
          }
          findMany: {
            args: Prisma.return_refundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_refundPayload>[]
          }
          create: {
            args: Prisma.return_refundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_refundPayload>
          }
          createMany: {
            args: Prisma.return_refundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.return_refundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_refundPayload>[]
          }
          delete: {
            args: Prisma.return_refundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_refundPayload>
          }
          update: {
            args: Prisma.return_refundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_refundPayload>
          }
          deleteMany: {
            args: Prisma.return_refundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.return_refundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.return_refundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_refundPayload>[]
          }
          upsert: {
            args: Prisma.return_refundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_refundPayload>
          }
          aggregate: {
            args: Prisma.Return_refundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturn_refund>
          }
          groupBy: {
            args: Prisma.return_refundGroupByArgs<ExtArgs>
            result: $Utils.Optional<Return_refundGroupByOutputType>[]
          }
          count: {
            args: Prisma.return_refundCountArgs<ExtArgs>
            result: $Utils.Optional<Return_refundCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    customers?: customersOmit
    products_img?: products_imgOmit
    channel?: channelOmit
    store?: storeOmit
    products?: productsOmit
    order_items?: order_itemsOmit
    logistic?: logisticOmit
    orders?: ordersOmit
    omnichat_user?: omnichat_userOmit
    omnichat?: omnichatOmit
    omnichat_line?: omnichat_lineOmit
    zdconnector?: zdconnectorOmit
    omnicrm?: omnicrmOmit
    clients?: clientsOmit
    credent?: credentOmit
    integration?: integrationOmit
    return_line_item?: return_line_itemOmit
    return_refund?: return_refundOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomersCountOutputType
   */

  export type CustomersCountOutputType = {
    orders: number
  }

  export type CustomersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomersCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     */
    select?: CustomersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }


  /**
   * Count Type ChannelCountOutputType
   */

  export type ChannelCountOutputType = {
    store: number
  }

  export type ChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | ChannelCountOutputTypeCountStoreArgs
  }

  // Custom InputTypes
  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountStoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: storeWhereInput
  }


  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    omnichat: number
    orders: number
    products: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    omnichat?: boolean | StoreCountOutputTypeCountOmnichatArgs
    orders?: boolean | StoreCountOutputTypeCountOrdersArgs
    products?: boolean | StoreCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountOmnichatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: omnichatWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    order_items: number
    product_img: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_items?: boolean | ProductsCountOutputTypeCountOrder_itemsArgs
    product_img?: boolean | ProductsCountOutputTypeCountProduct_imgArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountOrder_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_itemsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountProduct_imgArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: products_imgWhereInput
  }


  /**
   * Count Type Order_itemsCountOutputType
   */

  export type Order_itemsCountOutputType = {
    return_line_item: number
  }

  export type Order_itemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    return_line_item?: boolean | Order_itemsCountOutputTypeCountReturn_line_itemArgs
  }

  // Custom InputTypes
  /**
   * Order_itemsCountOutputType without action
   */
  export type Order_itemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order_itemsCountOutputType
     */
    select?: Order_itemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Order_itemsCountOutputType without action
   */
  export type Order_itemsCountOutputTypeCountReturn_line_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: return_line_itemWhereInput
  }


  /**
   * Count Type LogisticCountOutputType
   */

  export type LogisticCountOutputType = {
    orders: number
  }

  export type LogisticCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | LogisticCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * LogisticCountOutputType without action
   */
  export type LogisticCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogisticCountOutputType
     */
    select?: LogisticCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LogisticCountOutputType without action
   */
  export type LogisticCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }


  /**
   * Count Type OrdersCountOutputType
   */

  export type OrdersCountOutputType = {
    order_items: number
  }

  export type OrdersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_items?: boolean | OrdersCountOutputTypeCountOrder_itemsArgs
  }

  // Custom InputTypes
  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersCountOutputType
     */
    select?: OrdersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountOrder_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_itemsWhereInput
  }


  /**
   * Count Type Omnichat_userCountOutputType
   */

  export type Omnichat_userCountOutputType = {
    omnichat: number
    omnichat_line: number
  }

  export type Omnichat_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    omnichat?: boolean | Omnichat_userCountOutputTypeCountOmnichatArgs
    omnichat_line?: boolean | Omnichat_userCountOutputTypeCountOmnichat_lineArgs
  }

  // Custom InputTypes
  /**
   * Omnichat_userCountOutputType without action
   */
  export type Omnichat_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Omnichat_userCountOutputType
     */
    select?: Omnichat_userCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Omnichat_userCountOutputType without action
   */
  export type Omnichat_userCountOutputTypeCountOmnichatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: omnichatWhereInput
  }

  /**
   * Omnichat_userCountOutputType without action
   */
  export type Omnichat_userCountOutputTypeCountOmnichat_lineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: omnichat_lineWhereInput
  }


  /**
   * Count Type OmnichatCountOutputType
   */

  export type OmnichatCountOutputType = {
    messages: number
  }

  export type OmnichatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | OmnichatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * OmnichatCountOutputType without action
   */
  export type OmnichatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OmnichatCountOutputType
     */
    select?: OmnichatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OmnichatCountOutputType without action
   */
  export type OmnichatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: omnichat_lineWhereInput
  }


  /**
   * Count Type ClientsCountOutputType
   */

  export type ClientsCountOutputType = {
    channel: number
    integration: number
  }

  export type ClientsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ClientsCountOutputTypeCountChannelArgs
    integration?: boolean | ClientsCountOutputTypeCountIntegrationArgs
  }

  // Custom InputTypes
  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientsCountOutputType
     */
    select?: ClientsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channelWhereInput
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: integrationWhereInput
  }


  /**
   * Count Type IntegrationCountOutputType
   */

  export type IntegrationCountOutputType = {
    credent: number
  }

  export type IntegrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credent?: boolean | IntegrationCountOutputTypeCountCredentArgs
  }

  // Custom InputTypes
  /**
   * IntegrationCountOutputType without action
   */
  export type IntegrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCountOutputType
     */
    select?: IntegrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IntegrationCountOutputType without action
   */
  export type IntegrationCountOutputTypeCountCredentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: credentWhereInput
  }


  /**
   * Count Type Return_refundCountOutputType
   */

  export type Return_refundCountOutputType = {
    line_item: number
  }

  export type Return_refundCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    line_item?: boolean | Return_refundCountOutputTypeCountLine_itemArgs
  }

  // Custom InputTypes
  /**
   * Return_refundCountOutputType without action
   */
  export type Return_refundCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Return_refundCountOutputType
     */
    select?: Return_refundCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Return_refundCountOutputType without action
   */
  export type Return_refundCountOutputTypeCountLine_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: return_line_itemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomersSumAggregateOutputType = {
    id: number | null
  }

  export type CustomersMinAggregateOutputType = {
    id: number | null
    name: string | null
    origin_id: string | null
    phone: string | null
    email: string | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    origin_id: string | null
    phone: string | null
    email: string | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    name: number
    origin_id: number
    phone: number
    email: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    id?: true
  }

  export type CustomersSumAggregateInputType = {
    id?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    name?: true
    origin_id?: true
    phone?: true
    email?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    name?: true
    origin_id?: true
    phone?: true
    email?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    name?: true
    origin_id?: true
    phone?: true
    email?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to aggregate.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type customersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customersWhereInput
    orderBy?: customersOrderByWithAggregationInput | customersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: customersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    id: number
    name: string | null
    origin_id: string | null
    phone: string | null
    email: string | null
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends customersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type customersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    origin_id?: boolean
    phone?: boolean
    email?: boolean
    orders?: boolean | customers$ordersArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type customersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    origin_id?: boolean
    phone?: boolean
    email?: boolean
  }, ExtArgs["result"]["customers"]>

  export type customersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    origin_id?: boolean
    phone?: boolean
    email?: boolean
  }, ExtArgs["result"]["customers"]>

  export type customersSelectScalar = {
    id?: boolean
    name?: boolean
    origin_id?: boolean
    phone?: boolean
    email?: boolean
  }

  export type customersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "origin_id" | "phone" | "email", ExtArgs["result"]["customers"]>
  export type customersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | customers$ordersArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type customersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type customersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $customersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customers"
    objects: {
      orders: Prisma.$ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      origin_id: string | null
      phone: string | null
      email: string | null
    }, ExtArgs["result"]["customers"]>
    composites: {}
  }

  type customersGetPayload<S extends boolean | null | undefined | customersDefaultArgs> = $Result.GetResult<Prisma.$customersPayload, S>

  type customersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface customersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customers'], meta: { name: 'customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {customersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customersFindUniqueArgs>(args: SelectSubset<T, customersFindUniqueArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customersFindUniqueOrThrowArgs>(args: SelectSubset<T, customersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customersFindFirstArgs>(args?: SelectSubset<T, customersFindFirstArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customersFindFirstOrThrowArgs>(args?: SelectSubset<T, customersFindFirstOrThrowArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customersFindManyArgs>(args?: SelectSubset<T, customersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customers.
     * @param {customersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
     */
    create<T extends customersCreateArgs>(args: SelectSubset<T, customersCreateArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {customersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customersCreateManyArgs>(args?: SelectSubset<T, customersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customersCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customersCreateManyAndReturnArgs>(args?: SelectSubset<T, customersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customers.
     * @param {customersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
     */
    delete<T extends customersDeleteArgs>(args: SelectSubset<T, customersDeleteArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customers.
     * @param {customersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customersUpdateArgs>(args: SelectSubset<T, customersUpdateArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {customersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customersDeleteManyArgs>(args?: SelectSubset<T, customersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customersUpdateManyArgs>(args: SelectSubset<T, customersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {customersUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends customersUpdateManyAndReturnArgs>(args: SelectSubset<T, customersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customers.
     * @param {customersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends customersUpsertArgs>(args: SelectSubset<T, customersUpsertArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customersCountArgs>(
      args?: Subset<T, customersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customersGroupByArgs['orderBy'] }
        : { orderBy?: customersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customers model
   */
  readonly fields: customersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends customers$ordersArgs<ExtArgs> = {}>(args?: Subset<T, customers$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customers model
   */
  interface customersFieldRefs {
    readonly id: FieldRef<"customers", 'Int'>
    readonly name: FieldRef<"customers", 'String'>
    readonly origin_id: FieldRef<"customers", 'String'>
    readonly phone: FieldRef<"customers", 'String'>
    readonly email: FieldRef<"customers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * customers findUnique
   */
  export type customersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers findUniqueOrThrow
   */
  export type customersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers findFirst
   */
  export type customersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers findFirstOrThrow
   */
  export type customersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers findMany
   */
  export type customersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers create
   */
  export type customersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The data needed to create a customers.
     */
    data?: XOR<customersCreateInput, customersUncheckedCreateInput>
  }

  /**
   * customers createMany
   */
  export type customersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customers createManyAndReturn
   */
  export type customersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customers update
   */
  export type customersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The data needed to update a customers.
     */
    data: XOR<customersUpdateInput, customersUncheckedUpdateInput>
    /**
     * Choose, which customers to update.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers updateMany
   */
  export type customersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customersWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customers updateManyAndReturn
   */
  export type customersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * The data used to update customers.
     */
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customersWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customers upsert
   */
  export type customersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The filter to search for the customers to update in case it exists.
     */
    where: customersWhereUniqueInput
    /**
     * In case the customers found by the `where` argument doesn't exist, create a new customers with this data.
     */
    create: XOR<customersCreateInput, customersUncheckedCreateInput>
    /**
     * In case the customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customersUpdateInput, customersUncheckedUpdateInput>
  }

  /**
   * customers delete
   */
  export type customersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter which customers to delete.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers deleteMany
   */
  export type customersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customersWhereInput
    /**
     * Limit how many customers to delete.
     */
    limit?: number
  }

  /**
   * customers.orders
   */
  export type customers$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * customers without action
   */
  export type customersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
  }


  /**
   * Model products_img
   */

  export type AggregateProducts_img = {
    _count: Products_imgCountAggregateOutputType | null
    _avg: Products_imgAvgAggregateOutputType | null
    _sum: Products_imgSumAggregateOutputType | null
    _min: Products_imgMinAggregateOutputType | null
    _max: Products_imgMaxAggregateOutputType | null
  }

  export type Products_imgAvgAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    productsId: number | null
  }

  export type Products_imgSumAggregateOutputType = {
    id: number | null
    width: number | null
    height: number | null
    productsId: number | null
  }

  export type Products_imgMinAggregateOutputType = {
    id: number | null
    origin_id: string | null
    filename: string | null
    status: string | null
    width: number | null
    height: number | null
    originalUrl: string | null
    thumbnailUrl: string | null
    productsId: number | null
  }

  export type Products_imgMaxAggregateOutputType = {
    id: number | null
    origin_id: string | null
    filename: string | null
    status: string | null
    width: number | null
    height: number | null
    originalUrl: string | null
    thumbnailUrl: string | null
    productsId: number | null
  }

  export type Products_imgCountAggregateOutputType = {
    id: number
    origin_id: number
    filename: number
    status: number
    width: number
    height: number
    originalUrl: number
    thumbnailUrl: number
    productsId: number
    _all: number
  }


  export type Products_imgAvgAggregateInputType = {
    id?: true
    width?: true
    height?: true
    productsId?: true
  }

  export type Products_imgSumAggregateInputType = {
    id?: true
    width?: true
    height?: true
    productsId?: true
  }

  export type Products_imgMinAggregateInputType = {
    id?: true
    origin_id?: true
    filename?: true
    status?: true
    width?: true
    height?: true
    originalUrl?: true
    thumbnailUrl?: true
    productsId?: true
  }

  export type Products_imgMaxAggregateInputType = {
    id?: true
    origin_id?: true
    filename?: true
    status?: true
    width?: true
    height?: true
    originalUrl?: true
    thumbnailUrl?: true
    productsId?: true
  }

  export type Products_imgCountAggregateInputType = {
    id?: true
    origin_id?: true
    filename?: true
    status?: true
    width?: true
    height?: true
    originalUrl?: true
    thumbnailUrl?: true
    productsId?: true
    _all?: true
  }

  export type Products_imgAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products_img to aggregate.
     */
    where?: products_imgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_imgs to fetch.
     */
    orderBy?: products_imgOrderByWithRelationInput | products_imgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: products_imgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_imgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_imgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products_imgs
    **/
    _count?: true | Products_imgCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Products_imgAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Products_imgSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Products_imgMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Products_imgMaxAggregateInputType
  }

  export type GetProducts_imgAggregateType<T extends Products_imgAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts_img]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts_img[P]>
      : GetScalarType<T[P], AggregateProducts_img[P]>
  }




  export type products_imgGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: products_imgWhereInput
    orderBy?: products_imgOrderByWithAggregationInput | products_imgOrderByWithAggregationInput[]
    by: Products_imgScalarFieldEnum[] | Products_imgScalarFieldEnum
    having?: products_imgScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Products_imgCountAggregateInputType | true
    _avg?: Products_imgAvgAggregateInputType
    _sum?: Products_imgSumAggregateInputType
    _min?: Products_imgMinAggregateInputType
    _max?: Products_imgMaxAggregateInputType
  }

  export type Products_imgGroupByOutputType = {
    id: number
    origin_id: string | null
    filename: string | null
    status: string | null
    width: number | null
    height: number | null
    originalUrl: string | null
    thumbnailUrl: string | null
    productsId: number | null
    _count: Products_imgCountAggregateOutputType | null
    _avg: Products_imgAvgAggregateOutputType | null
    _sum: Products_imgSumAggregateOutputType | null
    _min: Products_imgMinAggregateOutputType | null
    _max: Products_imgMaxAggregateOutputType | null
  }

  type GetProducts_imgGroupByPayload<T extends products_imgGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Products_imgGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Products_imgGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Products_imgGroupByOutputType[P]>
            : GetScalarType<T[P], Products_imgGroupByOutputType[P]>
        }
      >
    >


  export type products_imgSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    filename?: boolean
    status?: boolean
    width?: boolean
    height?: boolean
    originalUrl?: boolean
    thumbnailUrl?: boolean
    productsId?: boolean
    products?: boolean | products_img$productsArgs<ExtArgs>
  }, ExtArgs["result"]["products_img"]>

  export type products_imgSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    filename?: boolean
    status?: boolean
    width?: boolean
    height?: boolean
    originalUrl?: boolean
    thumbnailUrl?: boolean
    productsId?: boolean
    products?: boolean | products_img$productsArgs<ExtArgs>
  }, ExtArgs["result"]["products_img"]>

  export type products_imgSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    filename?: boolean
    status?: boolean
    width?: boolean
    height?: boolean
    originalUrl?: boolean
    thumbnailUrl?: boolean
    productsId?: boolean
    products?: boolean | products_img$productsArgs<ExtArgs>
  }, ExtArgs["result"]["products_img"]>

  export type products_imgSelectScalar = {
    id?: boolean
    origin_id?: boolean
    filename?: boolean
    status?: boolean
    width?: boolean
    height?: boolean
    originalUrl?: boolean
    thumbnailUrl?: boolean
    productsId?: boolean
  }

  export type products_imgOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "origin_id" | "filename" | "status" | "width" | "height" | "originalUrl" | "thumbnailUrl" | "productsId", ExtArgs["result"]["products_img"]>
  export type products_imgInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | products_img$productsArgs<ExtArgs>
  }
  export type products_imgIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | products_img$productsArgs<ExtArgs>
  }
  export type products_imgIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | products_img$productsArgs<ExtArgs>
  }

  export type $products_imgPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "products_img"
    objects: {
      products: Prisma.$productsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      origin_id: string | null
      filename: string | null
      status: string | null
      width: number | null
      height: number | null
      originalUrl: string | null
      thumbnailUrl: string | null
      productsId: number | null
    }, ExtArgs["result"]["products_img"]>
    composites: {}
  }

  type products_imgGetPayload<S extends boolean | null | undefined | products_imgDefaultArgs> = $Result.GetResult<Prisma.$products_imgPayload, S>

  type products_imgCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<products_imgFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Products_imgCountAggregateInputType | true
    }

  export interface products_imgDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['products_img'], meta: { name: 'products_img' } }
    /**
     * Find zero or one Products_img that matches the filter.
     * @param {products_imgFindUniqueArgs} args - Arguments to find a Products_img
     * @example
     * // Get one Products_img
     * const products_img = await prisma.products_img.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends products_imgFindUniqueArgs>(args: SelectSubset<T, products_imgFindUniqueArgs<ExtArgs>>): Prisma__products_imgClient<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Products_img that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {products_imgFindUniqueOrThrowArgs} args - Arguments to find a Products_img
     * @example
     * // Get one Products_img
     * const products_img = await prisma.products_img.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends products_imgFindUniqueOrThrowArgs>(args: SelectSubset<T, products_imgFindUniqueOrThrowArgs<ExtArgs>>): Prisma__products_imgClient<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products_img that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_imgFindFirstArgs} args - Arguments to find a Products_img
     * @example
     * // Get one Products_img
     * const products_img = await prisma.products_img.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends products_imgFindFirstArgs>(args?: SelectSubset<T, products_imgFindFirstArgs<ExtArgs>>): Prisma__products_imgClient<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products_img that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_imgFindFirstOrThrowArgs} args - Arguments to find a Products_img
     * @example
     * // Get one Products_img
     * const products_img = await prisma.products_img.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends products_imgFindFirstOrThrowArgs>(args?: SelectSubset<T, products_imgFindFirstOrThrowArgs<ExtArgs>>): Prisma__products_imgClient<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products_imgs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_imgFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products_imgs
     * const products_imgs = await prisma.products_img.findMany()
     * 
     * // Get first 10 Products_imgs
     * const products_imgs = await prisma.products_img.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const products_imgWithIdOnly = await prisma.products_img.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends products_imgFindManyArgs>(args?: SelectSubset<T, products_imgFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Products_img.
     * @param {products_imgCreateArgs} args - Arguments to create a Products_img.
     * @example
     * // Create one Products_img
     * const Products_img = await prisma.products_img.create({
     *   data: {
     *     // ... data to create a Products_img
     *   }
     * })
     * 
     */
    create<T extends products_imgCreateArgs>(args: SelectSubset<T, products_imgCreateArgs<ExtArgs>>): Prisma__products_imgClient<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products_imgs.
     * @param {products_imgCreateManyArgs} args - Arguments to create many Products_imgs.
     * @example
     * // Create many Products_imgs
     * const products_img = await prisma.products_img.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends products_imgCreateManyArgs>(args?: SelectSubset<T, products_imgCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products_imgs and returns the data saved in the database.
     * @param {products_imgCreateManyAndReturnArgs} args - Arguments to create many Products_imgs.
     * @example
     * // Create many Products_imgs
     * const products_img = await prisma.products_img.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products_imgs and only return the `id`
     * const products_imgWithIdOnly = await prisma.products_img.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends products_imgCreateManyAndReturnArgs>(args?: SelectSubset<T, products_imgCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Products_img.
     * @param {products_imgDeleteArgs} args - Arguments to delete one Products_img.
     * @example
     * // Delete one Products_img
     * const Products_img = await prisma.products_img.delete({
     *   where: {
     *     // ... filter to delete one Products_img
     *   }
     * })
     * 
     */
    delete<T extends products_imgDeleteArgs>(args: SelectSubset<T, products_imgDeleteArgs<ExtArgs>>): Prisma__products_imgClient<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Products_img.
     * @param {products_imgUpdateArgs} args - Arguments to update one Products_img.
     * @example
     * // Update one Products_img
     * const products_img = await prisma.products_img.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends products_imgUpdateArgs>(args: SelectSubset<T, products_imgUpdateArgs<ExtArgs>>): Prisma__products_imgClient<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products_imgs.
     * @param {products_imgDeleteManyArgs} args - Arguments to filter Products_imgs to delete.
     * @example
     * // Delete a few Products_imgs
     * const { count } = await prisma.products_img.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends products_imgDeleteManyArgs>(args?: SelectSubset<T, products_imgDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products_imgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_imgUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products_imgs
     * const products_img = await prisma.products_img.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends products_imgUpdateManyArgs>(args: SelectSubset<T, products_imgUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products_imgs and returns the data updated in the database.
     * @param {products_imgUpdateManyAndReturnArgs} args - Arguments to update many Products_imgs.
     * @example
     * // Update many Products_imgs
     * const products_img = await prisma.products_img.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products_imgs and only return the `id`
     * const products_imgWithIdOnly = await prisma.products_img.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends products_imgUpdateManyAndReturnArgs>(args: SelectSubset<T, products_imgUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Products_img.
     * @param {products_imgUpsertArgs} args - Arguments to update or create a Products_img.
     * @example
     * // Update or create a Products_img
     * const products_img = await prisma.products_img.upsert({
     *   create: {
     *     // ... data to create a Products_img
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products_img we want to update
     *   }
     * })
     */
    upsert<T extends products_imgUpsertArgs>(args: SelectSubset<T, products_imgUpsertArgs<ExtArgs>>): Prisma__products_imgClient<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products_imgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_imgCountArgs} args - Arguments to filter Products_imgs to count.
     * @example
     * // Count the number of Products_imgs
     * const count = await prisma.products_img.count({
     *   where: {
     *     // ... the filter for the Products_imgs we want to count
     *   }
     * })
    **/
    count<T extends products_imgCountArgs>(
      args?: Subset<T, products_imgCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Products_imgCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products_img.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Products_imgAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Products_imgAggregateArgs>(args: Subset<T, Products_imgAggregateArgs>): Prisma.PrismaPromise<GetProducts_imgAggregateType<T>>

    /**
     * Group by Products_img.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_imgGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends products_imgGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: products_imgGroupByArgs['orderBy'] }
        : { orderBy?: products_imgGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, products_imgGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProducts_imgGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the products_img model
   */
  readonly fields: products_imgFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for products_img.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__products_imgClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends products_img$productsArgs<ExtArgs> = {}>(args?: Subset<T, products_img$productsArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the products_img model
   */
  interface products_imgFieldRefs {
    readonly id: FieldRef<"products_img", 'Int'>
    readonly origin_id: FieldRef<"products_img", 'String'>
    readonly filename: FieldRef<"products_img", 'String'>
    readonly status: FieldRef<"products_img", 'String'>
    readonly width: FieldRef<"products_img", 'Int'>
    readonly height: FieldRef<"products_img", 'Int'>
    readonly originalUrl: FieldRef<"products_img", 'String'>
    readonly thumbnailUrl: FieldRef<"products_img", 'String'>
    readonly productsId: FieldRef<"products_img", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * products_img findUnique
   */
  export type products_imgFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgInclude<ExtArgs> | null
    /**
     * Filter, which products_img to fetch.
     */
    where: products_imgWhereUniqueInput
  }

  /**
   * products_img findUniqueOrThrow
   */
  export type products_imgFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgInclude<ExtArgs> | null
    /**
     * Filter, which products_img to fetch.
     */
    where: products_imgWhereUniqueInput
  }

  /**
   * products_img findFirst
   */
  export type products_imgFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgInclude<ExtArgs> | null
    /**
     * Filter, which products_img to fetch.
     */
    where?: products_imgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_imgs to fetch.
     */
    orderBy?: products_imgOrderByWithRelationInput | products_imgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products_imgs.
     */
    cursor?: products_imgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_imgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_imgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products_imgs.
     */
    distinct?: Products_imgScalarFieldEnum | Products_imgScalarFieldEnum[]
  }

  /**
   * products_img findFirstOrThrow
   */
  export type products_imgFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgInclude<ExtArgs> | null
    /**
     * Filter, which products_img to fetch.
     */
    where?: products_imgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_imgs to fetch.
     */
    orderBy?: products_imgOrderByWithRelationInput | products_imgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products_imgs.
     */
    cursor?: products_imgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_imgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_imgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products_imgs.
     */
    distinct?: Products_imgScalarFieldEnum | Products_imgScalarFieldEnum[]
  }

  /**
   * products_img findMany
   */
  export type products_imgFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgInclude<ExtArgs> | null
    /**
     * Filter, which products_imgs to fetch.
     */
    where?: products_imgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_imgs to fetch.
     */
    orderBy?: products_imgOrderByWithRelationInput | products_imgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products_imgs.
     */
    cursor?: products_imgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_imgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_imgs.
     */
    skip?: number
    distinct?: Products_imgScalarFieldEnum | Products_imgScalarFieldEnum[]
  }

  /**
   * products_img create
   */
  export type products_imgCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgInclude<ExtArgs> | null
    /**
     * The data needed to create a products_img.
     */
    data?: XOR<products_imgCreateInput, products_imgUncheckedCreateInput>
  }

  /**
   * products_img createMany
   */
  export type products_imgCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products_imgs.
     */
    data: products_imgCreateManyInput | products_imgCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * products_img createManyAndReturn
   */
  export type products_imgCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * The data used to create many products_imgs.
     */
    data: products_imgCreateManyInput | products_imgCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * products_img update
   */
  export type products_imgUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgInclude<ExtArgs> | null
    /**
     * The data needed to update a products_img.
     */
    data: XOR<products_imgUpdateInput, products_imgUncheckedUpdateInput>
    /**
     * Choose, which products_img to update.
     */
    where: products_imgWhereUniqueInput
  }

  /**
   * products_img updateMany
   */
  export type products_imgUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products_imgs.
     */
    data: XOR<products_imgUpdateManyMutationInput, products_imgUncheckedUpdateManyInput>
    /**
     * Filter which products_imgs to update
     */
    where?: products_imgWhereInput
    /**
     * Limit how many products_imgs to update.
     */
    limit?: number
  }

  /**
   * products_img updateManyAndReturn
   */
  export type products_imgUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * The data used to update products_imgs.
     */
    data: XOR<products_imgUpdateManyMutationInput, products_imgUncheckedUpdateManyInput>
    /**
     * Filter which products_imgs to update
     */
    where?: products_imgWhereInput
    /**
     * Limit how many products_imgs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * products_img upsert
   */
  export type products_imgUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgInclude<ExtArgs> | null
    /**
     * The filter to search for the products_img to update in case it exists.
     */
    where: products_imgWhereUniqueInput
    /**
     * In case the products_img found by the `where` argument doesn't exist, create a new products_img with this data.
     */
    create: XOR<products_imgCreateInput, products_imgUncheckedCreateInput>
    /**
     * In case the products_img was found with the provided `where` argument, update it with this data.
     */
    update: XOR<products_imgUpdateInput, products_imgUncheckedUpdateInput>
  }

  /**
   * products_img delete
   */
  export type products_imgDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgInclude<ExtArgs> | null
    /**
     * Filter which products_img to delete.
     */
    where: products_imgWhereUniqueInput
  }

  /**
   * products_img deleteMany
   */
  export type products_imgDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products_imgs to delete
     */
    where?: products_imgWhereInput
    /**
     * Limit how many products_imgs to delete.
     */
    limit?: number
  }

  /**
   * products_img.products
   */
  export type products_img$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
  }

  /**
   * products_img without action
   */
  export type products_imgDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgInclude<ExtArgs> | null
  }


  /**
   * Model channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelAvgAggregateOutputType = {
    id: number | null
    clientsId: number | null
  }

  export type ChannelSumAggregateOutputType = {
    id: number | null
    clientsId: number | null
  }

  export type ChannelMinAggregateOutputType = {
    id: number | null
    name: string | null
    clientsId: number | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    clientsId: number | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    name: number
    clientsId: number
    _all: number
  }


  export type ChannelAvgAggregateInputType = {
    id?: true
    clientsId?: true
  }

  export type ChannelSumAggregateInputType = {
    id?: true
    clientsId?: true
  }

  export type ChannelMinAggregateInputType = {
    id?: true
    name?: true
    clientsId?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    name?: true
    clientsId?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    name?: true
    clientsId?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which channel to aggregate.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type channelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channelWhereInput
    orderBy?: channelOrderByWithAggregationInput | channelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: channelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _avg?: ChannelAvgAggregateInputType
    _sum?: ChannelSumAggregateInputType
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: number
    name: string | null
    clientsId: number | null
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends channelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type channelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    clientsId?: boolean
    client?: boolean | channel$clientArgs<ExtArgs>
    store?: boolean | channel$storeArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type channelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    clientsId?: boolean
    client?: boolean | channel$clientArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type channelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    clientsId?: boolean
    client?: boolean | channel$clientArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type channelSelectScalar = {
    id?: boolean
    name?: boolean
    clientsId?: boolean
  }

  export type channelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "clientsId", ExtArgs["result"]["channel"]>
  export type channelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | channel$clientArgs<ExtArgs>
    store?: boolean | channel$storeArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type channelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | channel$clientArgs<ExtArgs>
  }
  export type channelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | channel$clientArgs<ExtArgs>
  }

  export type $channelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "channel"
    objects: {
      client: Prisma.$clientsPayload<ExtArgs> | null
      store: Prisma.$storePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      clientsId: number | null
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type channelGetPayload<S extends boolean | null | undefined | channelDefaultArgs> = $Result.GetResult<Prisma.$channelPayload, S>

  type channelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<channelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface channelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['channel'], meta: { name: 'channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {channelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends channelFindUniqueArgs>(args: SelectSubset<T, channelFindUniqueArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {channelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends channelFindUniqueOrThrowArgs>(args: SelectSubset<T, channelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends channelFindFirstArgs>(args?: SelectSubset<T, channelFindFirstArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends channelFindFirstOrThrowArgs>(args?: SelectSubset<T, channelFindFirstOrThrowArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends channelFindManyArgs>(args?: SelectSubset<T, channelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Channel.
     * @param {channelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends channelCreateArgs>(args: SelectSubset<T, channelCreateArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Channels.
     * @param {channelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends channelCreateManyArgs>(args?: SelectSubset<T, channelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Channels and returns the data saved in the database.
     * @param {channelCreateManyAndReturnArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends channelCreateManyAndReturnArgs>(args?: SelectSubset<T, channelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Channel.
     * @param {channelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends channelDeleteArgs>(args: SelectSubset<T, channelDeleteArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Channel.
     * @param {channelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends channelUpdateArgs>(args: SelectSubset<T, channelUpdateArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Channels.
     * @param {channelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends channelDeleteManyArgs>(args?: SelectSubset<T, channelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends channelUpdateManyArgs>(args: SelectSubset<T, channelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels and returns the data updated in the database.
     * @param {channelUpdateManyAndReturnArgs} args - Arguments to update many Channels.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends channelUpdateManyAndReturnArgs>(args: SelectSubset<T, channelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Channel.
     * @param {channelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends channelUpsertArgs>(args: SelectSubset<T, channelUpsertArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends channelCountArgs>(
      args?: Subset<T, channelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends channelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: channelGroupByArgs['orderBy'] }
        : { orderBy?: channelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, channelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the channel model
   */
  readonly fields: channelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__channelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends channel$clientArgs<ExtArgs> = {}>(args?: Subset<T, channel$clientArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    store<T extends channel$storeArgs<ExtArgs> = {}>(args?: Subset<T, channel$storeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the channel model
   */
  interface channelFieldRefs {
    readonly id: FieldRef<"channel", 'Int'>
    readonly name: FieldRef<"channel", 'String'>
    readonly clientsId: FieldRef<"channel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * channel findUnique
   */
  export type channelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel findUniqueOrThrow
   */
  export type channelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel findFirst
   */
  export type channelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for channels.
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * channel findFirstOrThrow
   */
  export type channelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for channels.
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * channel findMany
   */
  export type channelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channels to fetch.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing channels.
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * channel create
   */
  export type channelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * The data needed to create a channel.
     */
    data?: XOR<channelCreateInput, channelUncheckedCreateInput>
  }

  /**
   * channel createMany
   */
  export type channelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many channels.
     */
    data: channelCreateManyInput | channelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * channel createManyAndReturn
   */
  export type channelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * The data used to create many channels.
     */
    data: channelCreateManyInput | channelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * channel update
   */
  export type channelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * The data needed to update a channel.
     */
    data: XOR<channelUpdateInput, channelUncheckedUpdateInput>
    /**
     * Choose, which channel to update.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel updateMany
   */
  export type channelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update channels.
     */
    data: XOR<channelUpdateManyMutationInput, channelUncheckedUpdateManyInput>
    /**
     * Filter which channels to update
     */
    where?: channelWhereInput
    /**
     * Limit how many channels to update.
     */
    limit?: number
  }

  /**
   * channel updateManyAndReturn
   */
  export type channelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * The data used to update channels.
     */
    data: XOR<channelUpdateManyMutationInput, channelUncheckedUpdateManyInput>
    /**
     * Filter which channels to update
     */
    where?: channelWhereInput
    /**
     * Limit how many channels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * channel upsert
   */
  export type channelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * The filter to search for the channel to update in case it exists.
     */
    where: channelWhereUniqueInput
    /**
     * In case the channel found by the `where` argument doesn't exist, create a new channel with this data.
     */
    create: XOR<channelCreateInput, channelUncheckedCreateInput>
    /**
     * In case the channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<channelUpdateInput, channelUncheckedUpdateInput>
  }

  /**
   * channel delete
   */
  export type channelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter which channel to delete.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel deleteMany
   */
  export type channelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which channels to delete
     */
    where?: channelWhereInput
    /**
     * Limit how many channels to delete.
     */
    limit?: number
  }

  /**
   * channel.client
   */
  export type channel$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    where?: clientsWhereInput
  }

  /**
   * channel.store
   */
  export type channel$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    where?: storeWhereInput
    orderBy?: storeOrderByWithRelationInput | storeOrderByWithRelationInput[]
    cursor?: storeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * channel without action
   */
  export type channelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
  }


  /**
   * Model store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreAvgAggregateOutputType = {
    id: number | null
    channelId: number | null
  }

  export type StoreSumAggregateOutputType = {
    id: number | null
    channelId: number | null
  }

  export type StoreMinAggregateOutputType = {
    id: number | null
    name: string | null
    origin_id: string | null
    channelId: number | null
    refresh_token: string | null
    token: string | null
    secondary_refresh_token: string | null
    secondary_token: string | null
    url: string | null
    status: string | null
  }

  export type StoreMaxAggregateOutputType = {
    id: number | null
    name: string | null
    origin_id: string | null
    channelId: number | null
    refresh_token: string | null
    token: string | null
    secondary_refresh_token: string | null
    secondary_token: string | null
    url: string | null
    status: string | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    name: number
    origin_id: number
    channelId: number
    refresh_token: number
    token: number
    secondary_refresh_token: number
    secondary_token: number
    url: number
    status: number
    _all: number
  }


  export type StoreAvgAggregateInputType = {
    id?: true
    channelId?: true
  }

  export type StoreSumAggregateInputType = {
    id?: true
    channelId?: true
  }

  export type StoreMinAggregateInputType = {
    id?: true
    name?: true
    origin_id?: true
    channelId?: true
    refresh_token?: true
    token?: true
    secondary_refresh_token?: true
    secondary_token?: true
    url?: true
    status?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    name?: true
    origin_id?: true
    channelId?: true
    refresh_token?: true
    token?: true
    secondary_refresh_token?: true
    secondary_token?: true
    url?: true
    status?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    name?: true
    origin_id?: true
    channelId?: true
    refresh_token?: true
    token?: true
    secondary_refresh_token?: true
    secondary_token?: true
    url?: true
    status?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which store to aggregate.
     */
    where?: storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storeOrderByWithRelationInput | storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type storeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: storeWhereInput
    orderBy?: storeOrderByWithAggregationInput | storeOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: storeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _avg?: StoreAvgAggregateInputType
    _sum?: StoreSumAggregateInputType
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: number
    name: string | null
    origin_id: string | null
    channelId: number | null
    refresh_token: string | null
    token: string | null
    secondary_refresh_token: string | null
    secondary_token: string | null
    url: string | null
    status: string | null
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends storeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type storeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    origin_id?: boolean
    channelId?: boolean
    refresh_token?: boolean
    token?: boolean
    secondary_refresh_token?: boolean
    secondary_token?: boolean
    url?: boolean
    status?: boolean
    omnichat?: boolean | store$omnichatArgs<ExtArgs>
    orders?: boolean | store$ordersArgs<ExtArgs>
    products?: boolean | store$productsArgs<ExtArgs>
    channel?: boolean | store$channelArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type storeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    origin_id?: boolean
    channelId?: boolean
    refresh_token?: boolean
    token?: boolean
    secondary_refresh_token?: boolean
    secondary_token?: boolean
    url?: boolean
    status?: boolean
    channel?: boolean | store$channelArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type storeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    origin_id?: boolean
    channelId?: boolean
    refresh_token?: boolean
    token?: boolean
    secondary_refresh_token?: boolean
    secondary_token?: boolean
    url?: boolean
    status?: boolean
    channel?: boolean | store$channelArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type storeSelectScalar = {
    id?: boolean
    name?: boolean
    origin_id?: boolean
    channelId?: boolean
    refresh_token?: boolean
    token?: boolean
    secondary_refresh_token?: boolean
    secondary_token?: boolean
    url?: boolean
    status?: boolean
  }

  export type storeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "origin_id" | "channelId" | "refresh_token" | "token" | "secondary_refresh_token" | "secondary_token" | "url" | "status", ExtArgs["result"]["store"]>
  export type storeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    omnichat?: boolean | store$omnichatArgs<ExtArgs>
    orders?: boolean | store$ordersArgs<ExtArgs>
    products?: boolean | store$productsArgs<ExtArgs>
    channel?: boolean | store$channelArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type storeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | store$channelArgs<ExtArgs>
  }
  export type storeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | store$channelArgs<ExtArgs>
  }

  export type $storePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "store"
    objects: {
      omnichat: Prisma.$omnichatPayload<ExtArgs>[]
      orders: Prisma.$ordersPayload<ExtArgs>[]
      products: Prisma.$productsPayload<ExtArgs>[]
      channel: Prisma.$channelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      origin_id: string | null
      channelId: number | null
      refresh_token: string | null
      token: string | null
      secondary_refresh_token: string | null
      secondary_token: string | null
      url: string | null
      status: string | null
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type storeGetPayload<S extends boolean | null | undefined | storeDefaultArgs> = $Result.GetResult<Prisma.$storePayload, S>

  type storeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<storeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface storeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['store'], meta: { name: 'store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {storeFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends storeFindUniqueArgs>(args: SelectSubset<T, storeFindUniqueArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {storeFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends storeFindUniqueOrThrowArgs>(args: SelectSubset<T, storeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends storeFindFirstArgs>(args?: SelectSubset<T, storeFindFirstArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends storeFindFirstOrThrowArgs>(args?: SelectSubset<T, storeFindFirstOrThrowArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends storeFindManyArgs>(args?: SelectSubset<T, storeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Store.
     * @param {storeCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends storeCreateArgs>(args: SelectSubset<T, storeCreateArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {storeCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends storeCreateManyArgs>(args?: SelectSubset<T, storeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {storeCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends storeCreateManyAndReturnArgs>(args?: SelectSubset<T, storeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Store.
     * @param {storeDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends storeDeleteArgs>(args: SelectSubset<T, storeDeleteArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Store.
     * @param {storeUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends storeUpdateArgs>(args: SelectSubset<T, storeUpdateArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {storeDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends storeDeleteManyArgs>(args?: SelectSubset<T, storeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends storeUpdateManyArgs>(args: SelectSubset<T, storeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {storeUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends storeUpdateManyAndReturnArgs>(args: SelectSubset<T, storeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Store.
     * @param {storeUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends storeUpsertArgs>(args: SelectSubset<T, storeUpsertArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends storeCountArgs>(
      args?: Subset<T, storeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends storeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: storeGroupByArgs['orderBy'] }
        : { orderBy?: storeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, storeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the store model
   */
  readonly fields: storeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__storeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    omnichat<T extends store$omnichatArgs<ExtArgs> = {}>(args?: Subset<T, store$omnichatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends store$ordersArgs<ExtArgs> = {}>(args?: Subset<T, store$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends store$productsArgs<ExtArgs> = {}>(args?: Subset<T, store$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    channel<T extends store$channelArgs<ExtArgs> = {}>(args?: Subset<T, store$channelArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the store model
   */
  interface storeFieldRefs {
    readonly id: FieldRef<"store", 'Int'>
    readonly name: FieldRef<"store", 'String'>
    readonly origin_id: FieldRef<"store", 'String'>
    readonly channelId: FieldRef<"store", 'Int'>
    readonly refresh_token: FieldRef<"store", 'String'>
    readonly token: FieldRef<"store", 'String'>
    readonly secondary_refresh_token: FieldRef<"store", 'String'>
    readonly secondary_token: FieldRef<"store", 'String'>
    readonly url: FieldRef<"store", 'String'>
    readonly status: FieldRef<"store", 'String'>
  }
    

  // Custom InputTypes
  /**
   * store findUnique
   */
  export type storeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter, which store to fetch.
     */
    where: storeWhereUniqueInput
  }

  /**
   * store findUniqueOrThrow
   */
  export type storeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter, which store to fetch.
     */
    where: storeWhereUniqueInput
  }

  /**
   * store findFirst
   */
  export type storeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter, which store to fetch.
     */
    where?: storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storeOrderByWithRelationInput | storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stores.
     */
    cursor?: storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * store findFirstOrThrow
   */
  export type storeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter, which store to fetch.
     */
    where?: storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storeOrderByWithRelationInput | storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stores.
     */
    cursor?: storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * store findMany
   */
  export type storeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where?: storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storeOrderByWithRelationInput | storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stores.
     */
    cursor?: storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * store create
   */
  export type storeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * The data needed to create a store.
     */
    data?: XOR<storeCreateInput, storeUncheckedCreateInput>
  }

  /**
   * store createMany
   */
  export type storeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stores.
     */
    data: storeCreateManyInput | storeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * store createManyAndReturn
   */
  export type storeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * The data used to create many stores.
     */
    data: storeCreateManyInput | storeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * store update
   */
  export type storeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * The data needed to update a store.
     */
    data: XOR<storeUpdateInput, storeUncheckedUpdateInput>
    /**
     * Choose, which store to update.
     */
    where: storeWhereUniqueInput
  }

  /**
   * store updateMany
   */
  export type storeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stores.
     */
    data: XOR<storeUpdateManyMutationInput, storeUncheckedUpdateManyInput>
    /**
     * Filter which stores to update
     */
    where?: storeWhereInput
    /**
     * Limit how many stores to update.
     */
    limit?: number
  }

  /**
   * store updateManyAndReturn
   */
  export type storeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * The data used to update stores.
     */
    data: XOR<storeUpdateManyMutationInput, storeUncheckedUpdateManyInput>
    /**
     * Filter which stores to update
     */
    where?: storeWhereInput
    /**
     * Limit how many stores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * store upsert
   */
  export type storeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * The filter to search for the store to update in case it exists.
     */
    where: storeWhereUniqueInput
    /**
     * In case the store found by the `where` argument doesn't exist, create a new store with this data.
     */
    create: XOR<storeCreateInput, storeUncheckedCreateInput>
    /**
     * In case the store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<storeUpdateInput, storeUncheckedUpdateInput>
  }

  /**
   * store delete
   */
  export type storeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter which store to delete.
     */
    where: storeWhereUniqueInput
  }

  /**
   * store deleteMany
   */
  export type storeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stores to delete
     */
    where?: storeWhereInput
    /**
     * Limit how many stores to delete.
     */
    limit?: number
  }

  /**
   * store.omnichat
   */
  export type store$omnichatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    where?: omnichatWhereInput
    orderBy?: omnichatOrderByWithRelationInput | omnichatOrderByWithRelationInput[]
    cursor?: omnichatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OmnichatScalarFieldEnum | OmnichatScalarFieldEnum[]
  }

  /**
   * store.orders
   */
  export type store$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * store.products
   */
  export type store$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    cursor?: productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * store.channel
   */
  export type store$channelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    where?: channelWhereInput
  }

  /**
   * store without action
   */
  export type storeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
  }


  /**
   * Model products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    id: number | null
    condition: number | null
    category: number | null
    price: number | null
    weight: number | null
    stock: number | null
    storeId: number | null
  }

  export type ProductsSumAggregateOutputType = {
    id: number | null
    condition: number | null
    category: number | null
    price: number | null
    weight: number | null
    stock: number | null
    storeId: number | null
  }

  export type ProductsMinAggregateOutputType = {
    id: number | null
    origin_id: string | null
    status: string | null
    name: string | null
    condition: number | null
    desc: string | null
    category: number | null
    price: number | null
    currency: string | null
    createdAt: Date | null
    weight: number | null
    stock: number | null
    sku: string | null
    storeId: number | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: number | null
    origin_id: string | null
    status: string | null
    name: string | null
    condition: number | null
    desc: string | null
    category: number | null
    price: number | null
    currency: string | null
    createdAt: Date | null
    weight: number | null
    stock: number | null
    sku: string | null
    storeId: number | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    origin_id: number
    status: number
    name: number
    condition: number
    desc: number
    category: number
    price: number
    currency: number
    createdAt: number
    weight: number
    stock: number
    sku: number
    storeId: number
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    id?: true
    condition?: true
    category?: true
    price?: true
    weight?: true
    stock?: true
    storeId?: true
  }

  export type ProductsSumAggregateInputType = {
    id?: true
    condition?: true
    category?: true
    price?: true
    weight?: true
    stock?: true
    storeId?: true
  }

  export type ProductsMinAggregateInputType = {
    id?: true
    origin_id?: true
    status?: true
    name?: true
    condition?: true
    desc?: true
    category?: true
    price?: true
    currency?: true
    createdAt?: true
    weight?: true
    stock?: true
    sku?: true
    storeId?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    origin_id?: true
    status?: true
    name?: true
    condition?: true
    desc?: true
    category?: true
    price?: true
    currency?: true
    createdAt?: true
    weight?: true
    stock?: true
    sku?: true
    storeId?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    origin_id?: true
    status?: true
    name?: true
    condition?: true
    desc?: true
    category?: true
    price?: true
    currency?: true
    createdAt?: true
    weight?: true
    stock?: true
    sku?: true
    storeId?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to aggregate.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
    orderBy?: productsOrderByWithAggregationInput | productsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _avg?: ProductsAvgAggregateInputType
    _sum?: ProductsSumAggregateInputType
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: number
    origin_id: string | null
    status: string | null
    name: string | null
    condition: number | null
    desc: string | null
    category: number | null
    price: number | null
    currency: string | null
    createdAt: Date
    weight: number | null
    stock: number | null
    sku: string | null
    storeId: number | null
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    status?: boolean
    name?: boolean
    condition?: boolean
    desc?: boolean
    category?: boolean
    price?: boolean
    currency?: boolean
    createdAt?: boolean
    weight?: boolean
    stock?: boolean
    sku?: boolean
    storeId?: boolean
    order_items?: boolean | products$order_itemsArgs<ExtArgs>
    store?: boolean | products$storeArgs<ExtArgs>
    product_img?: boolean | products$product_imgArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    status?: boolean
    name?: boolean
    condition?: boolean
    desc?: boolean
    category?: boolean
    price?: boolean
    currency?: boolean
    createdAt?: boolean
    weight?: boolean
    stock?: boolean
    sku?: boolean
    storeId?: boolean
    store?: boolean | products$storeArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    status?: boolean
    name?: boolean
    condition?: boolean
    desc?: boolean
    category?: boolean
    price?: boolean
    currency?: boolean
    createdAt?: boolean
    weight?: boolean
    stock?: boolean
    sku?: boolean
    storeId?: boolean
    store?: boolean | products$storeArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectScalar = {
    id?: boolean
    origin_id?: boolean
    status?: boolean
    name?: boolean
    condition?: boolean
    desc?: boolean
    category?: boolean
    price?: boolean
    currency?: boolean
    createdAt?: boolean
    weight?: boolean
    stock?: boolean
    sku?: boolean
    storeId?: boolean
  }

  export type productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "origin_id" | "status" | "name" | "condition" | "desc" | "category" | "price" | "currency" | "createdAt" | "weight" | "stock" | "sku" | "storeId", ExtArgs["result"]["products"]>
  export type productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_items?: boolean | products$order_itemsArgs<ExtArgs>
    store?: boolean | products$storeArgs<ExtArgs>
    product_img?: boolean | products$product_imgArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | products$storeArgs<ExtArgs>
  }
  export type productsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | products$storeArgs<ExtArgs>
  }

  export type $productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "products"
    objects: {
      order_items: Prisma.$order_itemsPayload<ExtArgs>[]
      store: Prisma.$storePayload<ExtArgs> | null
      product_img: Prisma.$products_imgPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      origin_id: string | null
      status: string | null
      name: string | null
      condition: number | null
      desc: string | null
      category: number | null
      price: number | null
      currency: string | null
      createdAt: Date
      weight: number | null
      stock: number | null
      sku: string | null
      storeId: number | null
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type productsGetPayload<S extends boolean | null | undefined | productsDefaultArgs> = $Result.GetResult<Prisma.$productsPayload, S>

  type productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['products'], meta: { name: 'products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {productsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productsFindUniqueArgs>(args: SelectSubset<T, productsFindUniqueArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productsFindUniqueOrThrowArgs>(args: SelectSubset<T, productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productsFindFirstArgs>(args?: SelectSubset<T, productsFindFirstArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productsFindFirstOrThrowArgs>(args?: SelectSubset<T, productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productsFindManyArgs>(args?: SelectSubset<T, productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Products.
     * @param {productsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends productsCreateArgs>(args: SelectSubset<T, productsCreateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {productsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productsCreateManyArgs>(args?: SelectSubset<T, productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {productsCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productsCreateManyAndReturnArgs>(args?: SelectSubset<T, productsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Products.
     * @param {productsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends productsDeleteArgs>(args: SelectSubset<T, productsDeleteArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Products.
     * @param {productsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productsUpdateArgs>(args: SelectSubset<T, productsUpdateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productsDeleteManyArgs>(args?: SelectSubset<T, productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productsUpdateManyArgs>(args: SelectSubset<T, productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {productsUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends productsUpdateManyAndReturnArgs>(args: SelectSubset<T, productsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Products.
     * @param {productsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends productsUpsertArgs>(args: SelectSubset<T, productsUpsertArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productsCountArgs>(
      args?: Subset<T, productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productsGroupByArgs['orderBy'] }
        : { orderBy?: productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the products model
   */
  readonly fields: productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order_items<T extends products$order_itemsArgs<ExtArgs> = {}>(args?: Subset<T, products$order_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    store<T extends products$storeArgs<ExtArgs> = {}>(args?: Subset<T, products$storeArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product_img<T extends products$product_imgArgs<ExtArgs> = {}>(args?: Subset<T, products$product_imgArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$products_imgPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the products model
   */
  interface productsFieldRefs {
    readonly id: FieldRef<"products", 'Int'>
    readonly origin_id: FieldRef<"products", 'String'>
    readonly status: FieldRef<"products", 'String'>
    readonly name: FieldRef<"products", 'String'>
    readonly condition: FieldRef<"products", 'Int'>
    readonly desc: FieldRef<"products", 'String'>
    readonly category: FieldRef<"products", 'Int'>
    readonly price: FieldRef<"products", 'Int'>
    readonly currency: FieldRef<"products", 'String'>
    readonly createdAt: FieldRef<"products", 'DateTime'>
    readonly weight: FieldRef<"products", 'Int'>
    readonly stock: FieldRef<"products", 'Int'>
    readonly sku: FieldRef<"products", 'String'>
    readonly storeId: FieldRef<"products", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * products findUnique
   */
  export type productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findUniqueOrThrow
   */
  export type productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findFirst
   */
  export type productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findFirstOrThrow
   */
  export type productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findMany
   */
  export type productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products create
   */
  export type productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to create a products.
     */
    data?: XOR<productsCreateInput, productsUncheckedCreateInput>
  }

  /**
   * products createMany
   */
  export type productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * products createManyAndReturn
   */
  export type productsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * products update
   */
  export type productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to update a products.
     */
    data: XOR<productsUpdateInput, productsUncheckedUpdateInput>
    /**
     * Choose, which products to update.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products updateMany
   */
  export type productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
  }

  /**
   * products updateManyAndReturn
   */
  export type productsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * products upsert
   */
  export type productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The filter to search for the products to update in case it exists.
     */
    where: productsWhereUniqueInput
    /**
     * In case the products found by the `where` argument doesn't exist, create a new products with this data.
     */
    create: XOR<productsCreateInput, productsUncheckedCreateInput>
    /**
     * In case the products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productsUpdateInput, productsUncheckedUpdateInput>
  }

  /**
   * products delete
   */
  export type productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter which products to delete.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products deleteMany
   */
  export type productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productsWhereInput
    /**
     * Limit how many products to delete.
     */
    limit?: number
  }

  /**
   * products.order_items
   */
  export type products$order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    where?: order_itemsWhereInput
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    cursor?: order_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_itemsScalarFieldEnum | Order_itemsScalarFieldEnum[]
  }

  /**
   * products.store
   */
  export type products$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    where?: storeWhereInput
  }

  /**
   * products.product_img
   */
  export type products$product_imgArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products_img
     */
    select?: products_imgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products_img
     */
    omit?: products_imgOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: products_imgInclude<ExtArgs> | null
    where?: products_imgWhereInput
    orderBy?: products_imgOrderByWithRelationInput | products_imgOrderByWithRelationInput[]
    cursor?: products_imgWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Products_imgScalarFieldEnum | Products_imgScalarFieldEnum[]
  }

  /**
   * products without action
   */
  export type productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
  }


  /**
   * Model order_items
   */

  export type AggregateOrder_items = {
    _count: Order_itemsCountAggregateOutputType | null
    _avg: Order_itemsAvgAggregateOutputType | null
    _sum: Order_itemsSumAggregateOutputType | null
    _min: Order_itemsMinAggregateOutputType | null
    _max: Order_itemsMaxAggregateOutputType | null
  }

  export type Order_itemsAvgAggregateOutputType = {
    id: number | null
    qty: number | null
    total_price: number | null
    ordersId: number | null
    productsId: number | null
  }

  export type Order_itemsSumAggregateOutputType = {
    id: number | null
    qty: number | null
    total_price: number | null
    ordersId: number | null
    productsId: number | null
  }

  export type Order_itemsMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    qty: number | null
    package_id: string | null
    invoice: string | null
    total_price: number | null
    notes: string | null
    ordersId: number | null
    productsId: number | null
    origin_id: string | null
  }

  export type Order_itemsMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    qty: number | null
    package_id: string | null
    invoice: string | null
    total_price: number | null
    notes: string | null
    ordersId: number | null
    productsId: number | null
    origin_id: string | null
  }

  export type Order_itemsCountAggregateOutputType = {
    id: number
    createdAt: number
    qty: number
    package_id: number
    invoice: number
    total_price: number
    notes: number
    ordersId: number
    productsId: number
    origin_id: number
    _all: number
  }


  export type Order_itemsAvgAggregateInputType = {
    id?: true
    qty?: true
    total_price?: true
    ordersId?: true
    productsId?: true
  }

  export type Order_itemsSumAggregateInputType = {
    id?: true
    qty?: true
    total_price?: true
    ordersId?: true
    productsId?: true
  }

  export type Order_itemsMinAggregateInputType = {
    id?: true
    createdAt?: true
    qty?: true
    package_id?: true
    invoice?: true
    total_price?: true
    notes?: true
    ordersId?: true
    productsId?: true
    origin_id?: true
  }

  export type Order_itemsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    qty?: true
    package_id?: true
    invoice?: true
    total_price?: true
    notes?: true
    ordersId?: true
    productsId?: true
    origin_id?: true
  }

  export type Order_itemsCountAggregateInputType = {
    id?: true
    createdAt?: true
    qty?: true
    package_id?: true
    invoice?: true
    total_price?: true
    notes?: true
    ordersId?: true
    productsId?: true
    origin_id?: true
    _all?: true
  }

  export type Order_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_items to aggregate.
     */
    where?: order_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_items
    **/
    _count?: true | Order_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_itemsMaxAggregateInputType
  }

  export type GetOrder_itemsAggregateType<T extends Order_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_items[P]>
      : GetScalarType<T[P], AggregateOrder_items[P]>
  }




  export type order_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_itemsWhereInput
    orderBy?: order_itemsOrderByWithAggregationInput | order_itemsOrderByWithAggregationInput[]
    by: Order_itemsScalarFieldEnum[] | Order_itemsScalarFieldEnum
    having?: order_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_itemsCountAggregateInputType | true
    _avg?: Order_itemsAvgAggregateInputType
    _sum?: Order_itemsSumAggregateInputType
    _min?: Order_itemsMinAggregateInputType
    _max?: Order_itemsMaxAggregateInputType
  }

  export type Order_itemsGroupByOutputType = {
    id: number
    createdAt: Date
    qty: number
    package_id: string | null
    invoice: string | null
    total_price: number
    notes: string | null
    ordersId: number | null
    productsId: number | null
    origin_id: string | null
    _count: Order_itemsCountAggregateOutputType | null
    _avg: Order_itemsAvgAggregateOutputType | null
    _sum: Order_itemsSumAggregateOutputType | null
    _min: Order_itemsMinAggregateOutputType | null
    _max: Order_itemsMaxAggregateOutputType | null
  }

  type GetOrder_itemsGroupByPayload<T extends order_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Order_itemsGroupByOutputType[P]>
        }
      >
    >


  export type order_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    qty?: boolean
    package_id?: boolean
    invoice?: boolean
    total_price?: boolean
    notes?: boolean
    ordersId?: boolean
    productsId?: boolean
    origin_id?: boolean
    orders?: boolean | order_items$ordersArgs<ExtArgs>
    products?: boolean | order_items$productsArgs<ExtArgs>
    return_line_item?: boolean | order_items$return_line_itemArgs<ExtArgs>
    _count?: boolean | Order_itemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_items"]>

  export type order_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    qty?: boolean
    package_id?: boolean
    invoice?: boolean
    total_price?: boolean
    notes?: boolean
    ordersId?: boolean
    productsId?: boolean
    origin_id?: boolean
    orders?: boolean | order_items$ordersArgs<ExtArgs>
    products?: boolean | order_items$productsArgs<ExtArgs>
  }, ExtArgs["result"]["order_items"]>

  export type order_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    qty?: boolean
    package_id?: boolean
    invoice?: boolean
    total_price?: boolean
    notes?: boolean
    ordersId?: boolean
    productsId?: boolean
    origin_id?: boolean
    orders?: boolean | order_items$ordersArgs<ExtArgs>
    products?: boolean | order_items$productsArgs<ExtArgs>
  }, ExtArgs["result"]["order_items"]>

  export type order_itemsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    qty?: boolean
    package_id?: boolean
    invoice?: boolean
    total_price?: boolean
    notes?: boolean
    ordersId?: boolean
    productsId?: boolean
    origin_id?: boolean
  }

  export type order_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "qty" | "package_id" | "invoice" | "total_price" | "notes" | "ordersId" | "productsId" | "origin_id", ExtArgs["result"]["order_items"]>
  export type order_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | order_items$ordersArgs<ExtArgs>
    products?: boolean | order_items$productsArgs<ExtArgs>
    return_line_item?: boolean | order_items$return_line_itemArgs<ExtArgs>
    _count?: boolean | Order_itemsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type order_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | order_items$ordersArgs<ExtArgs>
    products?: boolean | order_items$productsArgs<ExtArgs>
  }
  export type order_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | order_items$ordersArgs<ExtArgs>
    products?: boolean | order_items$productsArgs<ExtArgs>
  }

  export type $order_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_items"
    objects: {
      orders: Prisma.$ordersPayload<ExtArgs> | null
      products: Prisma.$productsPayload<ExtArgs> | null
      return_line_item: Prisma.$return_line_itemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      qty: number
      package_id: string | null
      invoice: string | null
      total_price: number
      notes: string | null
      ordersId: number | null
      productsId: number | null
      origin_id: string | null
    }, ExtArgs["result"]["order_items"]>
    composites: {}
  }

  type order_itemsGetPayload<S extends boolean | null | undefined | order_itemsDefaultArgs> = $Result.GetResult<Prisma.$order_itemsPayload, S>

  type order_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<order_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Order_itemsCountAggregateInputType | true
    }

  export interface order_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_items'], meta: { name: 'order_items' } }
    /**
     * Find zero or one Order_items that matches the filter.
     * @param {order_itemsFindUniqueArgs} args - Arguments to find a Order_items
     * @example
     * // Get one Order_items
     * const order_items = await prisma.order_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends order_itemsFindUniqueArgs>(args: SelectSubset<T, order_itemsFindUniqueArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order_items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {order_itemsFindUniqueOrThrowArgs} args - Arguments to find a Order_items
     * @example
     * // Get one Order_items
     * const order_items = await prisma.order_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends order_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, order_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsFindFirstArgs} args - Arguments to find a Order_items
     * @example
     * // Get one Order_items
     * const order_items = await prisma.order_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends order_itemsFindFirstArgs>(args?: SelectSubset<T, order_itemsFindFirstArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsFindFirstOrThrowArgs} args - Arguments to find a Order_items
     * @example
     * // Get one Order_items
     * const order_items = await prisma.order_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends order_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, order_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Order_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_items
     * const order_items = await prisma.order_items.findMany()
     * 
     * // Get first 10 Order_items
     * const order_items = await prisma.order_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const order_itemsWithIdOnly = await prisma.order_items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends order_itemsFindManyArgs>(args?: SelectSubset<T, order_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order_items.
     * @param {order_itemsCreateArgs} args - Arguments to create a Order_items.
     * @example
     * // Create one Order_items
     * const Order_items = await prisma.order_items.create({
     *   data: {
     *     // ... data to create a Order_items
     *   }
     * })
     * 
     */
    create<T extends order_itemsCreateArgs>(args: SelectSubset<T, order_itemsCreateArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Order_items.
     * @param {order_itemsCreateManyArgs} args - Arguments to create many Order_items.
     * @example
     * // Create many Order_items
     * const order_items = await prisma.order_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends order_itemsCreateManyArgs>(args?: SelectSubset<T, order_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Order_items and returns the data saved in the database.
     * @param {order_itemsCreateManyAndReturnArgs} args - Arguments to create many Order_items.
     * @example
     * // Create many Order_items
     * const order_items = await prisma.order_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Order_items and only return the `id`
     * const order_itemsWithIdOnly = await prisma.order_items.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends order_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, order_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order_items.
     * @param {order_itemsDeleteArgs} args - Arguments to delete one Order_items.
     * @example
     * // Delete one Order_items
     * const Order_items = await prisma.order_items.delete({
     *   where: {
     *     // ... filter to delete one Order_items
     *   }
     * })
     * 
     */
    delete<T extends order_itemsDeleteArgs>(args: SelectSubset<T, order_itemsDeleteArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order_items.
     * @param {order_itemsUpdateArgs} args - Arguments to update one Order_items.
     * @example
     * // Update one Order_items
     * const order_items = await prisma.order_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends order_itemsUpdateArgs>(args: SelectSubset<T, order_itemsUpdateArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Order_items.
     * @param {order_itemsDeleteManyArgs} args - Arguments to filter Order_items to delete.
     * @example
     * // Delete a few Order_items
     * const { count } = await prisma.order_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends order_itemsDeleteManyArgs>(args?: SelectSubset<T, order_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_items
     * const order_items = await prisma.order_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends order_itemsUpdateManyArgs>(args: SelectSubset<T, order_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_items and returns the data updated in the database.
     * @param {order_itemsUpdateManyAndReturnArgs} args - Arguments to update many Order_items.
     * @example
     * // Update many Order_items
     * const order_items = await prisma.order_items.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Order_items and only return the `id`
     * const order_itemsWithIdOnly = await prisma.order_items.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends order_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, order_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order_items.
     * @param {order_itemsUpsertArgs} args - Arguments to update or create a Order_items.
     * @example
     * // Update or create a Order_items
     * const order_items = await prisma.order_items.upsert({
     *   create: {
     *     // ... data to create a Order_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_items we want to update
     *   }
     * })
     */
    upsert<T extends order_itemsUpsertArgs>(args: SelectSubset<T, order_itemsUpsertArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Order_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsCountArgs} args - Arguments to filter Order_items to count.
     * @example
     * // Count the number of Order_items
     * const count = await prisma.order_items.count({
     *   where: {
     *     // ... the filter for the Order_items we want to count
     *   }
     * })
    **/
    count<T extends order_itemsCountArgs>(
      args?: Subset<T, order_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_itemsAggregateArgs>(args: Subset<T, Order_itemsAggregateArgs>): Prisma.PrismaPromise<GetOrder_itemsAggregateType<T>>

    /**
     * Group by Order_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_itemsGroupByArgs['orderBy'] }
        : { orderBy?: order_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_items model
   */
  readonly fields: order_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends order_items$ordersArgs<ExtArgs> = {}>(args?: Subset<T, order_items$ordersArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends order_items$productsArgs<ExtArgs> = {}>(args?: Subset<T, order_items$productsArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    return_line_item<T extends order_items$return_line_itemArgs<ExtArgs> = {}>(args?: Subset<T, order_items$return_line_itemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the order_items model
   */
  interface order_itemsFieldRefs {
    readonly id: FieldRef<"order_items", 'Int'>
    readonly createdAt: FieldRef<"order_items", 'DateTime'>
    readonly qty: FieldRef<"order_items", 'Int'>
    readonly package_id: FieldRef<"order_items", 'String'>
    readonly invoice: FieldRef<"order_items", 'String'>
    readonly total_price: FieldRef<"order_items", 'Int'>
    readonly notes: FieldRef<"order_items", 'String'>
    readonly ordersId: FieldRef<"order_items", 'Int'>
    readonly productsId: FieldRef<"order_items", 'Int'>
    readonly origin_id: FieldRef<"order_items", 'String'>
  }
    

  // Custom InputTypes
  /**
   * order_items findUnique
   */
  export type order_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter, which order_items to fetch.
     */
    where: order_itemsWhereUniqueInput
  }

  /**
   * order_items findUniqueOrThrow
   */
  export type order_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter, which order_items to fetch.
     */
    where: order_itemsWhereUniqueInput
  }

  /**
   * order_items findFirst
   */
  export type order_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter, which order_items to fetch.
     */
    where?: order_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_items.
     */
    cursor?: order_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_items.
     */
    distinct?: Order_itemsScalarFieldEnum | Order_itemsScalarFieldEnum[]
  }

  /**
   * order_items findFirstOrThrow
   */
  export type order_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter, which order_items to fetch.
     */
    where?: order_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_items.
     */
    cursor?: order_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_items.
     */
    distinct?: Order_itemsScalarFieldEnum | Order_itemsScalarFieldEnum[]
  }

  /**
   * order_items findMany
   */
  export type order_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter, which order_items to fetch.
     */
    where?: order_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_items.
     */
    cursor?: order_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    distinct?: Order_itemsScalarFieldEnum | Order_itemsScalarFieldEnum[]
  }

  /**
   * order_items create
   */
  export type order_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a order_items.
     */
    data: XOR<order_itemsCreateInput, order_itemsUncheckedCreateInput>
  }

  /**
   * order_items createMany
   */
  export type order_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_items.
     */
    data: order_itemsCreateManyInput | order_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * order_items createManyAndReturn
   */
  export type order_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * The data used to create many order_items.
     */
    data: order_itemsCreateManyInput | order_itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_items update
   */
  export type order_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a order_items.
     */
    data: XOR<order_itemsUpdateInput, order_itemsUncheckedUpdateInput>
    /**
     * Choose, which order_items to update.
     */
    where: order_itemsWhereUniqueInput
  }

  /**
   * order_items updateMany
   */
  export type order_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_items.
     */
    data: XOR<order_itemsUpdateManyMutationInput, order_itemsUncheckedUpdateManyInput>
    /**
     * Filter which order_items to update
     */
    where?: order_itemsWhereInput
    /**
     * Limit how many order_items to update.
     */
    limit?: number
  }

  /**
   * order_items updateManyAndReturn
   */
  export type order_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * The data used to update order_items.
     */
    data: XOR<order_itemsUpdateManyMutationInput, order_itemsUncheckedUpdateManyInput>
    /**
     * Filter which order_items to update
     */
    where?: order_itemsWhereInput
    /**
     * Limit how many order_items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_items upsert
   */
  export type order_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the order_items to update in case it exists.
     */
    where: order_itemsWhereUniqueInput
    /**
     * In case the order_items found by the `where` argument doesn't exist, create a new order_items with this data.
     */
    create: XOR<order_itemsCreateInput, order_itemsUncheckedCreateInput>
    /**
     * In case the order_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_itemsUpdateInput, order_itemsUncheckedUpdateInput>
  }

  /**
   * order_items delete
   */
  export type order_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter which order_items to delete.
     */
    where: order_itemsWhereUniqueInput
  }

  /**
   * order_items deleteMany
   */
  export type order_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_items to delete
     */
    where?: order_itemsWhereInput
    /**
     * Limit how many order_items to delete.
     */
    limit?: number
  }

  /**
   * order_items.orders
   */
  export type order_items$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
  }

  /**
   * order_items.products
   */
  export type order_items$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
  }

  /**
   * order_items.return_line_item
   */
  export type order_items$return_line_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
    where?: return_line_itemWhereInput
    orderBy?: return_line_itemOrderByWithRelationInput | return_line_itemOrderByWithRelationInput[]
    cursor?: return_line_itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Return_line_itemScalarFieldEnum | Return_line_itemScalarFieldEnum[]
  }

  /**
   * order_items without action
   */
  export type order_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
  }


  /**
   * Model logistic
   */

  export type AggregateLogistic = {
    _count: LogisticCountAggregateOutputType | null
    _avg: LogisticAvgAggregateOutputType | null
    _sum: LogisticSumAggregateOutputType | null
    _min: LogisticMinAggregateOutputType | null
    _max: LogisticMaxAggregateOutputType | null
  }

  export type LogisticAvgAggregateOutputType = {
    id: number | null
  }

  export type LogisticSumAggregateOutputType = {
    id: number | null
  }

  export type LogisticMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
  }

  export type LogisticMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
  }

  export type LogisticCountAggregateOutputType = {
    id: number
    name: number
    type: number
    _all: number
  }


  export type LogisticAvgAggregateInputType = {
    id?: true
  }

  export type LogisticSumAggregateInputType = {
    id?: true
  }

  export type LogisticMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
  }

  export type LogisticMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
  }

  export type LogisticCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    _all?: true
  }

  export type LogisticAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logistic to aggregate.
     */
    where?: logisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logistics to fetch.
     */
    orderBy?: logisticOrderByWithRelationInput | logisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: logisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logistics
    **/
    _count?: true | LogisticCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogisticAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogisticSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogisticMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogisticMaxAggregateInputType
  }

  export type GetLogisticAggregateType<T extends LogisticAggregateArgs> = {
        [P in keyof T & keyof AggregateLogistic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogistic[P]>
      : GetScalarType<T[P], AggregateLogistic[P]>
  }




  export type logisticGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logisticWhereInput
    orderBy?: logisticOrderByWithAggregationInput | logisticOrderByWithAggregationInput[]
    by: LogisticScalarFieldEnum[] | LogisticScalarFieldEnum
    having?: logisticScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogisticCountAggregateInputType | true
    _avg?: LogisticAvgAggregateInputType
    _sum?: LogisticSumAggregateInputType
    _min?: LogisticMinAggregateInputType
    _max?: LogisticMaxAggregateInputType
  }

  export type LogisticGroupByOutputType = {
    id: number
    name: string | null
    type: string | null
    _count: LogisticCountAggregateOutputType | null
    _avg: LogisticAvgAggregateOutputType | null
    _sum: LogisticSumAggregateOutputType | null
    _min: LogisticMinAggregateOutputType | null
    _max: LogisticMaxAggregateOutputType | null
  }

  type GetLogisticGroupByPayload<T extends logisticGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogisticGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogisticGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogisticGroupByOutputType[P]>
            : GetScalarType<T[P], LogisticGroupByOutputType[P]>
        }
      >
    >


  export type logisticSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    orders?: boolean | logistic$ordersArgs<ExtArgs>
    _count?: boolean | LogisticCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logistic"]>

  export type logisticSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
  }, ExtArgs["result"]["logistic"]>

  export type logisticSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
  }, ExtArgs["result"]["logistic"]>

  export type logisticSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
  }

  export type logisticOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type", ExtArgs["result"]["logistic"]>
  export type logisticInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | logistic$ordersArgs<ExtArgs>
    _count?: boolean | LogisticCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type logisticIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type logisticIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $logisticPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "logistic"
    objects: {
      orders: Prisma.$ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      type: string | null
    }, ExtArgs["result"]["logistic"]>
    composites: {}
  }

  type logisticGetPayload<S extends boolean | null | undefined | logisticDefaultArgs> = $Result.GetResult<Prisma.$logisticPayload, S>

  type logisticCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<logisticFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogisticCountAggregateInputType | true
    }

  export interface logisticDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['logistic'], meta: { name: 'logistic' } }
    /**
     * Find zero or one Logistic that matches the filter.
     * @param {logisticFindUniqueArgs} args - Arguments to find a Logistic
     * @example
     * // Get one Logistic
     * const logistic = await prisma.logistic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends logisticFindUniqueArgs>(args: SelectSubset<T, logisticFindUniqueArgs<ExtArgs>>): Prisma__logisticClient<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Logistic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {logisticFindUniqueOrThrowArgs} args - Arguments to find a Logistic
     * @example
     * // Get one Logistic
     * const logistic = await prisma.logistic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends logisticFindUniqueOrThrowArgs>(args: SelectSubset<T, logisticFindUniqueOrThrowArgs<ExtArgs>>): Prisma__logisticClient<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logistic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logisticFindFirstArgs} args - Arguments to find a Logistic
     * @example
     * // Get one Logistic
     * const logistic = await prisma.logistic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends logisticFindFirstArgs>(args?: SelectSubset<T, logisticFindFirstArgs<ExtArgs>>): Prisma__logisticClient<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logistic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logisticFindFirstOrThrowArgs} args - Arguments to find a Logistic
     * @example
     * // Get one Logistic
     * const logistic = await prisma.logistic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends logisticFindFirstOrThrowArgs>(args?: SelectSubset<T, logisticFindFirstOrThrowArgs<ExtArgs>>): Prisma__logisticClient<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logisticFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logistics
     * const logistics = await prisma.logistic.findMany()
     * 
     * // Get first 10 Logistics
     * const logistics = await prisma.logistic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logisticWithIdOnly = await prisma.logistic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends logisticFindManyArgs>(args?: SelectSubset<T, logisticFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Logistic.
     * @param {logisticCreateArgs} args - Arguments to create a Logistic.
     * @example
     * // Create one Logistic
     * const Logistic = await prisma.logistic.create({
     *   data: {
     *     // ... data to create a Logistic
     *   }
     * })
     * 
     */
    create<T extends logisticCreateArgs>(args: SelectSubset<T, logisticCreateArgs<ExtArgs>>): Prisma__logisticClient<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logistics.
     * @param {logisticCreateManyArgs} args - Arguments to create many Logistics.
     * @example
     * // Create many Logistics
     * const logistic = await prisma.logistic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends logisticCreateManyArgs>(args?: SelectSubset<T, logisticCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logistics and returns the data saved in the database.
     * @param {logisticCreateManyAndReturnArgs} args - Arguments to create many Logistics.
     * @example
     * // Create many Logistics
     * const logistic = await prisma.logistic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logistics and only return the `id`
     * const logisticWithIdOnly = await prisma.logistic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends logisticCreateManyAndReturnArgs>(args?: SelectSubset<T, logisticCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Logistic.
     * @param {logisticDeleteArgs} args - Arguments to delete one Logistic.
     * @example
     * // Delete one Logistic
     * const Logistic = await prisma.logistic.delete({
     *   where: {
     *     // ... filter to delete one Logistic
     *   }
     * })
     * 
     */
    delete<T extends logisticDeleteArgs>(args: SelectSubset<T, logisticDeleteArgs<ExtArgs>>): Prisma__logisticClient<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Logistic.
     * @param {logisticUpdateArgs} args - Arguments to update one Logistic.
     * @example
     * // Update one Logistic
     * const logistic = await prisma.logistic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends logisticUpdateArgs>(args: SelectSubset<T, logisticUpdateArgs<ExtArgs>>): Prisma__logisticClient<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logistics.
     * @param {logisticDeleteManyArgs} args - Arguments to filter Logistics to delete.
     * @example
     * // Delete a few Logistics
     * const { count } = await prisma.logistic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends logisticDeleteManyArgs>(args?: SelectSubset<T, logisticDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logisticUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logistics
     * const logistic = await prisma.logistic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends logisticUpdateManyArgs>(args: SelectSubset<T, logisticUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logistics and returns the data updated in the database.
     * @param {logisticUpdateManyAndReturnArgs} args - Arguments to update many Logistics.
     * @example
     * // Update many Logistics
     * const logistic = await prisma.logistic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logistics and only return the `id`
     * const logisticWithIdOnly = await prisma.logistic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends logisticUpdateManyAndReturnArgs>(args: SelectSubset<T, logisticUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Logistic.
     * @param {logisticUpsertArgs} args - Arguments to update or create a Logistic.
     * @example
     * // Update or create a Logistic
     * const logistic = await prisma.logistic.upsert({
     *   create: {
     *     // ... data to create a Logistic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logistic we want to update
     *   }
     * })
     */
    upsert<T extends logisticUpsertArgs>(args: SelectSubset<T, logisticUpsertArgs<ExtArgs>>): Prisma__logisticClient<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logisticCountArgs} args - Arguments to filter Logistics to count.
     * @example
     * // Count the number of Logistics
     * const count = await prisma.logistic.count({
     *   where: {
     *     // ... the filter for the Logistics we want to count
     *   }
     * })
    **/
    count<T extends logisticCountArgs>(
      args?: Subset<T, logisticCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogisticCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogisticAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogisticAggregateArgs>(args: Subset<T, LogisticAggregateArgs>): Prisma.PrismaPromise<GetLogisticAggregateType<T>>

    /**
     * Group by Logistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logisticGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends logisticGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: logisticGroupByArgs['orderBy'] }
        : { orderBy?: logisticGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, logisticGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogisticGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the logistic model
   */
  readonly fields: logisticFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for logistic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__logisticClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends logistic$ordersArgs<ExtArgs> = {}>(args?: Subset<T, logistic$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the logistic model
   */
  interface logisticFieldRefs {
    readonly id: FieldRef<"logistic", 'Int'>
    readonly name: FieldRef<"logistic", 'String'>
    readonly type: FieldRef<"logistic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * logistic findUnique
   */
  export type logisticFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logisticInclude<ExtArgs> | null
    /**
     * Filter, which logistic to fetch.
     */
    where: logisticWhereUniqueInput
  }

  /**
   * logistic findUniqueOrThrow
   */
  export type logisticFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logisticInclude<ExtArgs> | null
    /**
     * Filter, which logistic to fetch.
     */
    where: logisticWhereUniqueInput
  }

  /**
   * logistic findFirst
   */
  export type logisticFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logisticInclude<ExtArgs> | null
    /**
     * Filter, which logistic to fetch.
     */
    where?: logisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logistics to fetch.
     */
    orderBy?: logisticOrderByWithRelationInput | logisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logistics.
     */
    cursor?: logisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logistics.
     */
    distinct?: LogisticScalarFieldEnum | LogisticScalarFieldEnum[]
  }

  /**
   * logistic findFirstOrThrow
   */
  export type logisticFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logisticInclude<ExtArgs> | null
    /**
     * Filter, which logistic to fetch.
     */
    where?: logisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logistics to fetch.
     */
    orderBy?: logisticOrderByWithRelationInput | logisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logistics.
     */
    cursor?: logisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logistics.
     */
    distinct?: LogisticScalarFieldEnum | LogisticScalarFieldEnum[]
  }

  /**
   * logistic findMany
   */
  export type logisticFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logisticInclude<ExtArgs> | null
    /**
     * Filter, which logistics to fetch.
     */
    where?: logisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logistics to fetch.
     */
    orderBy?: logisticOrderByWithRelationInput | logisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logistics.
     */
    cursor?: logisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logistics.
     */
    skip?: number
    distinct?: LogisticScalarFieldEnum | LogisticScalarFieldEnum[]
  }

  /**
   * logistic create
   */
  export type logisticCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logisticInclude<ExtArgs> | null
    /**
     * The data needed to create a logistic.
     */
    data?: XOR<logisticCreateInput, logisticUncheckedCreateInput>
  }

  /**
   * logistic createMany
   */
  export type logisticCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many logistics.
     */
    data: logisticCreateManyInput | logisticCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * logistic createManyAndReturn
   */
  export type logisticCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * The data used to create many logistics.
     */
    data: logisticCreateManyInput | logisticCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * logistic update
   */
  export type logisticUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logisticInclude<ExtArgs> | null
    /**
     * The data needed to update a logistic.
     */
    data: XOR<logisticUpdateInput, logisticUncheckedUpdateInput>
    /**
     * Choose, which logistic to update.
     */
    where: logisticWhereUniqueInput
  }

  /**
   * logistic updateMany
   */
  export type logisticUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update logistics.
     */
    data: XOR<logisticUpdateManyMutationInput, logisticUncheckedUpdateManyInput>
    /**
     * Filter which logistics to update
     */
    where?: logisticWhereInput
    /**
     * Limit how many logistics to update.
     */
    limit?: number
  }

  /**
   * logistic updateManyAndReturn
   */
  export type logisticUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * The data used to update logistics.
     */
    data: XOR<logisticUpdateManyMutationInput, logisticUncheckedUpdateManyInput>
    /**
     * Filter which logistics to update
     */
    where?: logisticWhereInput
    /**
     * Limit how many logistics to update.
     */
    limit?: number
  }

  /**
   * logistic upsert
   */
  export type logisticUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logisticInclude<ExtArgs> | null
    /**
     * The filter to search for the logistic to update in case it exists.
     */
    where: logisticWhereUniqueInput
    /**
     * In case the logistic found by the `where` argument doesn't exist, create a new logistic with this data.
     */
    create: XOR<logisticCreateInput, logisticUncheckedCreateInput>
    /**
     * In case the logistic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<logisticUpdateInput, logisticUncheckedUpdateInput>
  }

  /**
   * logistic delete
   */
  export type logisticDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logisticInclude<ExtArgs> | null
    /**
     * Filter which logistic to delete.
     */
    where: logisticWhereUniqueInput
  }

  /**
   * logistic deleteMany
   */
  export type logisticDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logistics to delete
     */
    where?: logisticWhereInput
    /**
     * Limit how many logistics to delete.
     */
    limit?: number
  }

  /**
   * logistic.orders
   */
  export type logistic$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * logistic without action
   */
  export type logisticDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logisticInclude<ExtArgs> | null
  }


  /**
   * Model orders
   */

  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
    customersId: number | null
    logisticId: number | null
    total_product_price: number | null
    shipping_price: number | null
    seller_discount: number | null
    platform_discount: number | null
    shipping_seller_discount: number | null
    shipping_platform_discount: number | null
    buyer_service_fee: number | null
    handling_fee: number | null
    shipping_insurance_fee: number | null
    item_insurance_fee: number | null
    total_amount: number | null
  }

  export type OrdersSumAggregateOutputType = {
    id: number | null
    storeId: number | null
    customersId: number | null
    logisticId: number | null
    total_product_price: number | null
    shipping_price: number | null
    seller_discount: number | null
    platform_discount: number | null
    shipping_seller_discount: number | null
    shipping_platform_discount: number | null
    buyer_service_fee: number | null
    handling_fee: number | null
    shipping_insurance_fee: number | null
    item_insurance_fee: number | null
    total_amount: number | null
  }

  export type OrdersMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    status: string | null
    shop_id: string | null
    payment_id: string | null
    temp_id: string | null
    origin_id: string | null
    package_id: string | null
    invoice: string | null
    recp_name: string | null
    recp_phone: string | null
    recp_addr_full: string | null
    recp_addr_district: string | null
    recp_addr_city: string | null
    recp_addr_province: string | null
    recp_addr_country: string | null
    recp_addr_postal_code: string | null
    recp_addr_district_id: string | null
    recp_addr_city_id: string | null
    tracking_number: string | null
    ship_document_url: string | null
    recp_addr_province_id: string | null
    recp_addr_geo: string | null
    logistic_service: string | null
    origin_createdAt: Date | null
    accept_partial: boolean | null
    device: string | null
    storeId: number | null
    customersId: number | null
    logisticId: number | null
    total_product_price: number | null
    shipping_price: number | null
    seller_discount: number | null
    platform_discount: number | null
    shipping_seller_discount: number | null
    shipping_platform_discount: number | null
    buyer_service_fee: number | null
    handling_fee: number | null
    shipping_insurance_fee: number | null
    item_insurance_fee: number | null
    total_amount: number | null
    updatedAt: Date | null
  }

  export type OrdersMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    status: string | null
    shop_id: string | null
    payment_id: string | null
    temp_id: string | null
    origin_id: string | null
    package_id: string | null
    invoice: string | null
    recp_name: string | null
    recp_phone: string | null
    recp_addr_full: string | null
    recp_addr_district: string | null
    recp_addr_city: string | null
    recp_addr_province: string | null
    recp_addr_country: string | null
    recp_addr_postal_code: string | null
    recp_addr_district_id: string | null
    recp_addr_city_id: string | null
    tracking_number: string | null
    ship_document_url: string | null
    recp_addr_province_id: string | null
    recp_addr_geo: string | null
    logistic_service: string | null
    origin_createdAt: Date | null
    accept_partial: boolean | null
    device: string | null
    storeId: number | null
    customersId: number | null
    logisticId: number | null
    total_product_price: number | null
    shipping_price: number | null
    seller_discount: number | null
    platform_discount: number | null
    shipping_seller_discount: number | null
    shipping_platform_discount: number | null
    buyer_service_fee: number | null
    handling_fee: number | null
    shipping_insurance_fee: number | null
    item_insurance_fee: number | null
    total_amount: number | null
    updatedAt: Date | null
  }

  export type OrdersCountAggregateOutputType = {
    id: number
    createdAt: number
    status: number
    shop_id: number
    payment_id: number
    temp_id: number
    origin_id: number
    package_id: number
    invoice: number
    recp_name: number
    recp_phone: number
    recp_addr_full: number
    recp_addr_district: number
    recp_addr_city: number
    recp_addr_province: number
    recp_addr_country: number
    recp_addr_postal_code: number
    recp_addr_district_id: number
    recp_addr_city_id: number
    tracking_number: number
    ship_document_url: number
    recp_addr_province_id: number
    recp_addr_geo: number
    logistic_service: number
    origin_createdAt: number
    accept_partial: number
    device: number
    storeId: number
    customersId: number
    logisticId: number
    total_product_price: number
    shipping_price: number
    seller_discount: number
    platform_discount: number
    shipping_seller_discount: number
    shipping_platform_discount: number
    buyer_service_fee: number
    handling_fee: number
    shipping_insurance_fee: number
    item_insurance_fee: number
    total_amount: number
    updatedAt: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    id?: true
    storeId?: true
    customersId?: true
    logisticId?: true
    total_product_price?: true
    shipping_price?: true
    seller_discount?: true
    platform_discount?: true
    shipping_seller_discount?: true
    shipping_platform_discount?: true
    buyer_service_fee?: true
    handling_fee?: true
    shipping_insurance_fee?: true
    item_insurance_fee?: true
    total_amount?: true
  }

  export type OrdersSumAggregateInputType = {
    id?: true
    storeId?: true
    customersId?: true
    logisticId?: true
    total_product_price?: true
    shipping_price?: true
    seller_discount?: true
    platform_discount?: true
    shipping_seller_discount?: true
    shipping_platform_discount?: true
    buyer_service_fee?: true
    handling_fee?: true
    shipping_insurance_fee?: true
    item_insurance_fee?: true
    total_amount?: true
  }

  export type OrdersMinAggregateInputType = {
    id?: true
    createdAt?: true
    status?: true
    shop_id?: true
    payment_id?: true
    temp_id?: true
    origin_id?: true
    package_id?: true
    invoice?: true
    recp_name?: true
    recp_phone?: true
    recp_addr_full?: true
    recp_addr_district?: true
    recp_addr_city?: true
    recp_addr_province?: true
    recp_addr_country?: true
    recp_addr_postal_code?: true
    recp_addr_district_id?: true
    recp_addr_city_id?: true
    tracking_number?: true
    ship_document_url?: true
    recp_addr_province_id?: true
    recp_addr_geo?: true
    logistic_service?: true
    origin_createdAt?: true
    accept_partial?: true
    device?: true
    storeId?: true
    customersId?: true
    logisticId?: true
    total_product_price?: true
    shipping_price?: true
    seller_discount?: true
    platform_discount?: true
    shipping_seller_discount?: true
    shipping_platform_discount?: true
    buyer_service_fee?: true
    handling_fee?: true
    shipping_insurance_fee?: true
    item_insurance_fee?: true
    total_amount?: true
    updatedAt?: true
  }

  export type OrdersMaxAggregateInputType = {
    id?: true
    createdAt?: true
    status?: true
    shop_id?: true
    payment_id?: true
    temp_id?: true
    origin_id?: true
    package_id?: true
    invoice?: true
    recp_name?: true
    recp_phone?: true
    recp_addr_full?: true
    recp_addr_district?: true
    recp_addr_city?: true
    recp_addr_province?: true
    recp_addr_country?: true
    recp_addr_postal_code?: true
    recp_addr_district_id?: true
    recp_addr_city_id?: true
    tracking_number?: true
    ship_document_url?: true
    recp_addr_province_id?: true
    recp_addr_geo?: true
    logistic_service?: true
    origin_createdAt?: true
    accept_partial?: true
    device?: true
    storeId?: true
    customersId?: true
    logisticId?: true
    total_product_price?: true
    shipping_price?: true
    seller_discount?: true
    platform_discount?: true
    shipping_seller_discount?: true
    shipping_platform_discount?: true
    buyer_service_fee?: true
    handling_fee?: true
    shipping_insurance_fee?: true
    item_insurance_fee?: true
    total_amount?: true
    updatedAt?: true
  }

  export type OrdersCountAggregateInputType = {
    id?: true
    createdAt?: true
    status?: true
    shop_id?: true
    payment_id?: true
    temp_id?: true
    origin_id?: true
    package_id?: true
    invoice?: true
    recp_name?: true
    recp_phone?: true
    recp_addr_full?: true
    recp_addr_district?: true
    recp_addr_city?: true
    recp_addr_province?: true
    recp_addr_country?: true
    recp_addr_postal_code?: true
    recp_addr_district_id?: true
    recp_addr_city_id?: true
    tracking_number?: true
    ship_document_url?: true
    recp_addr_province_id?: true
    recp_addr_geo?: true
    logistic_service?: true
    origin_createdAt?: true
    accept_partial?: true
    device?: true
    storeId?: true
    customersId?: true
    logisticId?: true
    total_product_price?: true
    shipping_price?: true
    seller_discount?: true
    platform_discount?: true
    shipping_seller_discount?: true
    shipping_platform_discount?: true
    buyer_service_fee?: true
    handling_fee?: true
    shipping_insurance_fee?: true
    item_insurance_fee?: true
    total_amount?: true
    updatedAt?: true
    _all?: true
  }

  export type OrdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to aggregate.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithAggregationInput | ordersOrderByWithAggregationInput[]
    by: OrdersScalarFieldEnum[] | OrdersScalarFieldEnum
    having?: ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }

  export type OrdersGroupByOutputType = {
    id: number
    createdAt: Date
    status: string | null
    shop_id: string | null
    payment_id: string | null
    temp_id: string | null
    origin_id: string | null
    package_id: string | null
    invoice: string | null
    recp_name: string | null
    recp_phone: string | null
    recp_addr_full: string | null
    recp_addr_district: string | null
    recp_addr_city: string | null
    recp_addr_province: string | null
    recp_addr_country: string | null
    recp_addr_postal_code: string | null
    recp_addr_district_id: string | null
    recp_addr_city_id: string | null
    tracking_number: string | null
    ship_document_url: string | null
    recp_addr_province_id: string | null
    recp_addr_geo: string | null
    logistic_service: string | null
    origin_createdAt: Date
    accept_partial: boolean | null
    device: string | null
    storeId: number | null
    customersId: number | null
    logisticId: number | null
    total_product_price: number | null
    shipping_price: number | null
    seller_discount: number | null
    platform_discount: number | null
    shipping_seller_discount: number | null
    shipping_platform_discount: number | null
    buyer_service_fee: number | null
    handling_fee: number | null
    shipping_insurance_fee: number | null
    item_insurance_fee: number | null
    total_amount: number | null
    updatedAt: Date
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends ordersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    status?: boolean
    shop_id?: boolean
    payment_id?: boolean
    temp_id?: boolean
    origin_id?: boolean
    package_id?: boolean
    invoice?: boolean
    recp_name?: boolean
    recp_phone?: boolean
    recp_addr_full?: boolean
    recp_addr_district?: boolean
    recp_addr_city?: boolean
    recp_addr_province?: boolean
    recp_addr_country?: boolean
    recp_addr_postal_code?: boolean
    recp_addr_district_id?: boolean
    recp_addr_city_id?: boolean
    tracking_number?: boolean
    ship_document_url?: boolean
    recp_addr_province_id?: boolean
    recp_addr_geo?: boolean
    logistic_service?: boolean
    origin_createdAt?: boolean
    accept_partial?: boolean
    device?: boolean
    storeId?: boolean
    customersId?: boolean
    logisticId?: boolean
    total_product_price?: boolean
    shipping_price?: boolean
    seller_discount?: boolean
    platform_discount?: boolean
    shipping_seller_discount?: boolean
    shipping_platform_discount?: boolean
    buyer_service_fee?: boolean
    handling_fee?: boolean
    shipping_insurance_fee?: boolean
    item_insurance_fee?: boolean
    total_amount?: boolean
    updatedAt?: boolean
    order_items?: boolean | orders$order_itemsArgs<ExtArgs>
    customers?: boolean | orders$customersArgs<ExtArgs>
    logistic?: boolean | orders$logisticArgs<ExtArgs>
    store?: boolean | orders$storeArgs<ExtArgs>
    return_refund?: boolean | orders$return_refundArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    status?: boolean
    shop_id?: boolean
    payment_id?: boolean
    temp_id?: boolean
    origin_id?: boolean
    package_id?: boolean
    invoice?: boolean
    recp_name?: boolean
    recp_phone?: boolean
    recp_addr_full?: boolean
    recp_addr_district?: boolean
    recp_addr_city?: boolean
    recp_addr_province?: boolean
    recp_addr_country?: boolean
    recp_addr_postal_code?: boolean
    recp_addr_district_id?: boolean
    recp_addr_city_id?: boolean
    tracking_number?: boolean
    ship_document_url?: boolean
    recp_addr_province_id?: boolean
    recp_addr_geo?: boolean
    logistic_service?: boolean
    origin_createdAt?: boolean
    accept_partial?: boolean
    device?: boolean
    storeId?: boolean
    customersId?: boolean
    logisticId?: boolean
    total_product_price?: boolean
    shipping_price?: boolean
    seller_discount?: boolean
    platform_discount?: boolean
    shipping_seller_discount?: boolean
    shipping_platform_discount?: boolean
    buyer_service_fee?: boolean
    handling_fee?: boolean
    shipping_insurance_fee?: boolean
    item_insurance_fee?: boolean
    total_amount?: boolean
    updatedAt?: boolean
    customers?: boolean | orders$customersArgs<ExtArgs>
    logistic?: boolean | orders$logisticArgs<ExtArgs>
    store?: boolean | orders$storeArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    status?: boolean
    shop_id?: boolean
    payment_id?: boolean
    temp_id?: boolean
    origin_id?: boolean
    package_id?: boolean
    invoice?: boolean
    recp_name?: boolean
    recp_phone?: boolean
    recp_addr_full?: boolean
    recp_addr_district?: boolean
    recp_addr_city?: boolean
    recp_addr_province?: boolean
    recp_addr_country?: boolean
    recp_addr_postal_code?: boolean
    recp_addr_district_id?: boolean
    recp_addr_city_id?: boolean
    tracking_number?: boolean
    ship_document_url?: boolean
    recp_addr_province_id?: boolean
    recp_addr_geo?: boolean
    logistic_service?: boolean
    origin_createdAt?: boolean
    accept_partial?: boolean
    device?: boolean
    storeId?: boolean
    customersId?: boolean
    logisticId?: boolean
    total_product_price?: boolean
    shipping_price?: boolean
    seller_discount?: boolean
    platform_discount?: boolean
    shipping_seller_discount?: boolean
    shipping_platform_discount?: boolean
    buyer_service_fee?: boolean
    handling_fee?: boolean
    shipping_insurance_fee?: boolean
    item_insurance_fee?: boolean
    total_amount?: boolean
    updatedAt?: boolean
    customers?: boolean | orders$customersArgs<ExtArgs>
    logistic?: boolean | orders$logisticArgs<ExtArgs>
    store?: boolean | orders$storeArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectScalar = {
    id?: boolean
    createdAt?: boolean
    status?: boolean
    shop_id?: boolean
    payment_id?: boolean
    temp_id?: boolean
    origin_id?: boolean
    package_id?: boolean
    invoice?: boolean
    recp_name?: boolean
    recp_phone?: boolean
    recp_addr_full?: boolean
    recp_addr_district?: boolean
    recp_addr_city?: boolean
    recp_addr_province?: boolean
    recp_addr_country?: boolean
    recp_addr_postal_code?: boolean
    recp_addr_district_id?: boolean
    recp_addr_city_id?: boolean
    tracking_number?: boolean
    ship_document_url?: boolean
    recp_addr_province_id?: boolean
    recp_addr_geo?: boolean
    logistic_service?: boolean
    origin_createdAt?: boolean
    accept_partial?: boolean
    device?: boolean
    storeId?: boolean
    customersId?: boolean
    logisticId?: boolean
    total_product_price?: boolean
    shipping_price?: boolean
    seller_discount?: boolean
    platform_discount?: boolean
    shipping_seller_discount?: boolean
    shipping_platform_discount?: boolean
    buyer_service_fee?: boolean
    handling_fee?: boolean
    shipping_insurance_fee?: boolean
    item_insurance_fee?: boolean
    total_amount?: boolean
    updatedAt?: boolean
  }

  export type ordersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "status" | "shop_id" | "payment_id" | "temp_id" | "origin_id" | "package_id" | "invoice" | "recp_name" | "recp_phone" | "recp_addr_full" | "recp_addr_district" | "recp_addr_city" | "recp_addr_province" | "recp_addr_country" | "recp_addr_postal_code" | "recp_addr_district_id" | "recp_addr_city_id" | "tracking_number" | "ship_document_url" | "recp_addr_province_id" | "recp_addr_geo" | "logistic_service" | "origin_createdAt" | "accept_partial" | "device" | "storeId" | "customersId" | "logisticId" | "total_product_price" | "shipping_price" | "seller_discount" | "platform_discount" | "shipping_seller_discount" | "shipping_platform_discount" | "buyer_service_fee" | "handling_fee" | "shipping_insurance_fee" | "item_insurance_fee" | "total_amount" | "updatedAt", ExtArgs["result"]["orders"]>
  export type ordersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_items?: boolean | orders$order_itemsArgs<ExtArgs>
    customers?: boolean | orders$customersArgs<ExtArgs>
    logistic?: boolean | orders$logisticArgs<ExtArgs>
    store?: boolean | orders$storeArgs<ExtArgs>
    return_refund?: boolean | orders$return_refundArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ordersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | orders$customersArgs<ExtArgs>
    logistic?: boolean | orders$logisticArgs<ExtArgs>
    store?: boolean | orders$storeArgs<ExtArgs>
  }
  export type ordersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | orders$customersArgs<ExtArgs>
    logistic?: boolean | orders$logisticArgs<ExtArgs>
    store?: boolean | orders$storeArgs<ExtArgs>
  }

  export type $ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orders"
    objects: {
      order_items: Prisma.$order_itemsPayload<ExtArgs>[]
      customers: Prisma.$customersPayload<ExtArgs> | null
      logistic: Prisma.$logisticPayload<ExtArgs> | null
      store: Prisma.$storePayload<ExtArgs> | null
      return_refund: Prisma.$return_refundPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      status: string | null
      shop_id: string | null
      payment_id: string | null
      temp_id: string | null
      origin_id: string | null
      package_id: string | null
      invoice: string | null
      recp_name: string | null
      recp_phone: string | null
      recp_addr_full: string | null
      recp_addr_district: string | null
      recp_addr_city: string | null
      recp_addr_province: string | null
      recp_addr_country: string | null
      recp_addr_postal_code: string | null
      recp_addr_district_id: string | null
      recp_addr_city_id: string | null
      tracking_number: string | null
      ship_document_url: string | null
      recp_addr_province_id: string | null
      recp_addr_geo: string | null
      logistic_service: string | null
      origin_createdAt: Date
      accept_partial: boolean | null
      device: string | null
      storeId: number | null
      customersId: number | null
      logisticId: number | null
      total_product_price: number | null
      shipping_price: number | null
      seller_discount: number | null
      platform_discount: number | null
      shipping_seller_discount: number | null
      shipping_platform_discount: number | null
      buyer_service_fee: number | null
      handling_fee: number | null
      shipping_insurance_fee: number | null
      item_insurance_fee: number | null
      total_amount: number | null
      updatedAt: Date
    }, ExtArgs["result"]["orders"]>
    composites: {}
  }

  type ordersGetPayload<S extends boolean | null | undefined | ordersDefaultArgs> = $Result.GetResult<Prisma.$ordersPayload, S>

  type ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ordersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrdersCountAggregateInputType | true
    }

  export interface ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orders'], meta: { name: 'orders' } }
    /**
     * Find zero or one Orders that matches the filter.
     * @param {ordersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ordersFindUniqueArgs>(args: SelectSubset<T, ordersFindUniqueArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Orders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ordersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ordersFindFirstArgs>(args?: SelectSubset<T, ordersFindFirstArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordersWithIdOnly = await prisma.orders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ordersFindManyArgs>(args?: SelectSubset<T, ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Orders.
     * @param {ordersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
     */
    create<T extends ordersCreateArgs>(args: SelectSubset<T, ordersCreateArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {ordersCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ordersCreateManyArgs>(args?: SelectSubset<T, ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {ordersCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const ordersWithIdOnly = await prisma.orders.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ordersCreateManyAndReturnArgs>(args?: SelectSubset<T, ordersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Orders.
     * @param {ordersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
     */
    delete<T extends ordersDeleteArgs>(args: SelectSubset<T, ordersDeleteArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Orders.
     * @param {ordersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ordersUpdateArgs>(args: SelectSubset<T, ordersUpdateArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {ordersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ordersDeleteManyArgs>(args?: SelectSubset<T, ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ordersUpdateManyArgs>(args: SelectSubset<T, ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {ordersUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const ordersWithIdOnly = await prisma.orders.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ordersUpdateManyAndReturnArgs>(args: SelectSubset<T, ordersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Orders.
     * @param {ordersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
     */
    upsert<T extends ordersUpsertArgs>(args: SelectSubset<T, ordersUpsertArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends ordersCountArgs>(
      args?: Subset<T, ordersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): Prisma.PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ordersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ordersGroupByArgs['orderBy'] }
        : { orderBy?: ordersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orders model
   */
  readonly fields: ordersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order_items<T extends orders$order_itemsArgs<ExtArgs> = {}>(args?: Subset<T, orders$order_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends orders$customersArgs<ExtArgs> = {}>(args?: Subset<T, orders$customersArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    logistic<T extends orders$logisticArgs<ExtArgs> = {}>(args?: Subset<T, orders$logisticArgs<ExtArgs>>): Prisma__logisticClient<$Result.GetResult<Prisma.$logisticPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    store<T extends orders$storeArgs<ExtArgs> = {}>(args?: Subset<T, orders$storeArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    return_refund<T extends orders$return_refundArgs<ExtArgs> = {}>(args?: Subset<T, orders$return_refundArgs<ExtArgs>>): Prisma__return_refundClient<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the orders model
   */
  interface ordersFieldRefs {
    readonly id: FieldRef<"orders", 'Int'>
    readonly createdAt: FieldRef<"orders", 'DateTime'>
    readonly status: FieldRef<"orders", 'String'>
    readonly shop_id: FieldRef<"orders", 'String'>
    readonly payment_id: FieldRef<"orders", 'String'>
    readonly temp_id: FieldRef<"orders", 'String'>
    readonly origin_id: FieldRef<"orders", 'String'>
    readonly package_id: FieldRef<"orders", 'String'>
    readonly invoice: FieldRef<"orders", 'String'>
    readonly recp_name: FieldRef<"orders", 'String'>
    readonly recp_phone: FieldRef<"orders", 'String'>
    readonly recp_addr_full: FieldRef<"orders", 'String'>
    readonly recp_addr_district: FieldRef<"orders", 'String'>
    readonly recp_addr_city: FieldRef<"orders", 'String'>
    readonly recp_addr_province: FieldRef<"orders", 'String'>
    readonly recp_addr_country: FieldRef<"orders", 'String'>
    readonly recp_addr_postal_code: FieldRef<"orders", 'String'>
    readonly recp_addr_district_id: FieldRef<"orders", 'String'>
    readonly recp_addr_city_id: FieldRef<"orders", 'String'>
    readonly tracking_number: FieldRef<"orders", 'String'>
    readonly ship_document_url: FieldRef<"orders", 'String'>
    readonly recp_addr_province_id: FieldRef<"orders", 'String'>
    readonly recp_addr_geo: FieldRef<"orders", 'String'>
    readonly logistic_service: FieldRef<"orders", 'String'>
    readonly origin_createdAt: FieldRef<"orders", 'DateTime'>
    readonly accept_partial: FieldRef<"orders", 'Boolean'>
    readonly device: FieldRef<"orders", 'String'>
    readonly storeId: FieldRef<"orders", 'Int'>
    readonly customersId: FieldRef<"orders", 'Int'>
    readonly logisticId: FieldRef<"orders", 'Int'>
    readonly total_product_price: FieldRef<"orders", 'Int'>
    readonly shipping_price: FieldRef<"orders", 'Int'>
    readonly seller_discount: FieldRef<"orders", 'Int'>
    readonly platform_discount: FieldRef<"orders", 'Int'>
    readonly shipping_seller_discount: FieldRef<"orders", 'Int'>
    readonly shipping_platform_discount: FieldRef<"orders", 'Int'>
    readonly buyer_service_fee: FieldRef<"orders", 'Int'>
    readonly handling_fee: FieldRef<"orders", 'Int'>
    readonly shipping_insurance_fee: FieldRef<"orders", 'Int'>
    readonly item_insurance_fee: FieldRef<"orders", 'Int'>
    readonly total_amount: FieldRef<"orders", 'Int'>
    readonly updatedAt: FieldRef<"orders", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * orders findUnique
   */
  export type ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders findUniqueOrThrow
   */
  export type ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders findFirst
   */
  export type ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders findFirstOrThrow
   */
  export type ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders findMany
   */
  export type ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders create
   */
  export type ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The data needed to create a orders.
     */
    data: XOR<ordersCreateInput, ordersUncheckedCreateInput>
  }

  /**
   * orders createMany
   */
  export type ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orders.
     */
    data: ordersCreateManyInput | ordersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orders createManyAndReturn
   */
  export type ordersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * The data used to create many orders.
     */
    data: ordersCreateManyInput | ordersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * orders update
   */
  export type ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The data needed to update a orders.
     */
    data: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
    /**
     * Choose, which orders to update.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders updateMany
   */
  export type ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orders.
     */
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to update.
     */
    limit?: number
  }

  /**
   * orders updateManyAndReturn
   */
  export type ordersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * The data used to update orders.
     */
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * orders upsert
   */
  export type ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The filter to search for the orders to update in case it exists.
     */
    where: ordersWhereUniqueInput
    /**
     * In case the orders found by the `where` argument doesn't exist, create a new orders with this data.
     */
    create: XOR<ordersCreateInput, ordersUncheckedCreateInput>
    /**
     * In case the orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
  }

  /**
   * orders delete
   */
  export type ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter which orders to delete.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders deleteMany
   */
  export type ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to delete
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to delete.
     */
    limit?: number
  }

  /**
   * orders.order_items
   */
  export type orders$order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the order_items
     */
    omit?: order_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    where?: order_itemsWhereInput
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    cursor?: order_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_itemsScalarFieldEnum | Order_itemsScalarFieldEnum[]
  }

  /**
   * orders.customers
   */
  export type orders$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    where?: customersWhereInput
  }

  /**
   * orders.logistic
   */
  export type orders$logisticArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logistic
     */
    select?: logisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the logistic
     */
    omit?: logisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logisticInclude<ExtArgs> | null
    where?: logisticWhereInput
  }

  /**
   * orders.store
   */
  export type orders$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    where?: storeWhereInput
  }

  /**
   * orders.return_refund
   */
  export type orders$return_refundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
    where?: return_refundWhereInput
  }

  /**
   * orders without action
   */
  export type ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
  }


  /**
   * Model omnichat_user
   */

  export type AggregateOmnichat_user = {
    _count: Omnichat_userCountAggregateOutputType | null
    _avg: Omnichat_userAvgAggregateOutputType | null
    _sum: Omnichat_userSumAggregateOutputType | null
    _min: Omnichat_userMinAggregateOutputType | null
    _max: Omnichat_userMaxAggregateOutputType | null
  }

  export type Omnichat_userAvgAggregateOutputType = {
    id: number | null
  }

  export type Omnichat_userSumAggregateOutputType = {
    id: number | null
  }

  export type Omnichat_userMinAggregateOutputType = {
    id: number | null
    username: string | null
    thumbnailUrl: string | null
    origin_id: string | null
    createdAt: Date | null
    externalId: string | null
  }

  export type Omnichat_userMaxAggregateOutputType = {
    id: number | null
    username: string | null
    thumbnailUrl: string | null
    origin_id: string | null
    createdAt: Date | null
    externalId: string | null
  }

  export type Omnichat_userCountAggregateOutputType = {
    id: number
    username: number
    thumbnailUrl: number
    origin_id: number
    createdAt: number
    externalId: number
    _all: number
  }


  export type Omnichat_userAvgAggregateInputType = {
    id?: true
  }

  export type Omnichat_userSumAggregateInputType = {
    id?: true
  }

  export type Omnichat_userMinAggregateInputType = {
    id?: true
    username?: true
    thumbnailUrl?: true
    origin_id?: true
    createdAt?: true
    externalId?: true
  }

  export type Omnichat_userMaxAggregateInputType = {
    id?: true
    username?: true
    thumbnailUrl?: true
    origin_id?: true
    createdAt?: true
    externalId?: true
  }

  export type Omnichat_userCountAggregateInputType = {
    id?: true
    username?: true
    thumbnailUrl?: true
    origin_id?: true
    createdAt?: true
    externalId?: true
    _all?: true
  }

  export type Omnichat_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which omnichat_user to aggregate.
     */
    where?: omnichat_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichat_users to fetch.
     */
    orderBy?: omnichat_userOrderByWithRelationInput | omnichat_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: omnichat_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichat_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichat_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned omnichat_users
    **/
    _count?: true | Omnichat_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Omnichat_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Omnichat_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Omnichat_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Omnichat_userMaxAggregateInputType
  }

  export type GetOmnichat_userAggregateType<T extends Omnichat_userAggregateArgs> = {
        [P in keyof T & keyof AggregateOmnichat_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOmnichat_user[P]>
      : GetScalarType<T[P], AggregateOmnichat_user[P]>
  }




  export type omnichat_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: omnichat_userWhereInput
    orderBy?: omnichat_userOrderByWithAggregationInput | omnichat_userOrderByWithAggregationInput[]
    by: Omnichat_userScalarFieldEnum[] | Omnichat_userScalarFieldEnum
    having?: omnichat_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Omnichat_userCountAggregateInputType | true
    _avg?: Omnichat_userAvgAggregateInputType
    _sum?: Omnichat_userSumAggregateInputType
    _min?: Omnichat_userMinAggregateInputType
    _max?: Omnichat_userMaxAggregateInputType
  }

  export type Omnichat_userGroupByOutputType = {
    id: number
    username: string | null
    thumbnailUrl: string | null
    origin_id: string | null
    createdAt: Date
    externalId: string | null
    _count: Omnichat_userCountAggregateOutputType | null
    _avg: Omnichat_userAvgAggregateOutputType | null
    _sum: Omnichat_userSumAggregateOutputType | null
    _min: Omnichat_userMinAggregateOutputType | null
    _max: Omnichat_userMaxAggregateOutputType | null
  }

  type GetOmnichat_userGroupByPayload<T extends omnichat_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Omnichat_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Omnichat_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Omnichat_userGroupByOutputType[P]>
            : GetScalarType<T[P], Omnichat_userGroupByOutputType[P]>
        }
      >
    >


  export type omnichat_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    thumbnailUrl?: boolean
    origin_id?: boolean
    createdAt?: boolean
    externalId?: boolean
    omnichat?: boolean | omnichat_user$omnichatArgs<ExtArgs>
    omnichat_line?: boolean | omnichat_user$omnichat_lineArgs<ExtArgs>
    _count?: boolean | Omnichat_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["omnichat_user"]>

  export type omnichat_userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    thumbnailUrl?: boolean
    origin_id?: boolean
    createdAt?: boolean
    externalId?: boolean
  }, ExtArgs["result"]["omnichat_user"]>

  export type omnichat_userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    thumbnailUrl?: boolean
    origin_id?: boolean
    createdAt?: boolean
    externalId?: boolean
  }, ExtArgs["result"]["omnichat_user"]>

  export type omnichat_userSelectScalar = {
    id?: boolean
    username?: boolean
    thumbnailUrl?: boolean
    origin_id?: boolean
    createdAt?: boolean
    externalId?: boolean
  }

  export type omnichat_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "thumbnailUrl" | "origin_id" | "createdAt" | "externalId", ExtArgs["result"]["omnichat_user"]>
  export type omnichat_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    omnichat?: boolean | omnichat_user$omnichatArgs<ExtArgs>
    omnichat_line?: boolean | omnichat_user$omnichat_lineArgs<ExtArgs>
    _count?: boolean | Omnichat_userCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type omnichat_userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type omnichat_userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $omnichat_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "omnichat_user"
    objects: {
      omnichat: Prisma.$omnichatPayload<ExtArgs>[]
      omnichat_line: Prisma.$omnichat_linePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string | null
      thumbnailUrl: string | null
      origin_id: string | null
      createdAt: Date
      externalId: string | null
    }, ExtArgs["result"]["omnichat_user"]>
    composites: {}
  }

  type omnichat_userGetPayload<S extends boolean | null | undefined | omnichat_userDefaultArgs> = $Result.GetResult<Prisma.$omnichat_userPayload, S>

  type omnichat_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<omnichat_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Omnichat_userCountAggregateInputType | true
    }

  export interface omnichat_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['omnichat_user'], meta: { name: 'omnichat_user' } }
    /**
     * Find zero or one Omnichat_user that matches the filter.
     * @param {omnichat_userFindUniqueArgs} args - Arguments to find a Omnichat_user
     * @example
     * // Get one Omnichat_user
     * const omnichat_user = await prisma.omnichat_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends omnichat_userFindUniqueArgs>(args: SelectSubset<T, omnichat_userFindUniqueArgs<ExtArgs>>): Prisma__omnichat_userClient<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Omnichat_user that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {omnichat_userFindUniqueOrThrowArgs} args - Arguments to find a Omnichat_user
     * @example
     * // Get one Omnichat_user
     * const omnichat_user = await prisma.omnichat_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends omnichat_userFindUniqueOrThrowArgs>(args: SelectSubset<T, omnichat_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__omnichat_userClient<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Omnichat_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_userFindFirstArgs} args - Arguments to find a Omnichat_user
     * @example
     * // Get one Omnichat_user
     * const omnichat_user = await prisma.omnichat_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends omnichat_userFindFirstArgs>(args?: SelectSubset<T, omnichat_userFindFirstArgs<ExtArgs>>): Prisma__omnichat_userClient<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Omnichat_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_userFindFirstOrThrowArgs} args - Arguments to find a Omnichat_user
     * @example
     * // Get one Omnichat_user
     * const omnichat_user = await prisma.omnichat_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends omnichat_userFindFirstOrThrowArgs>(args?: SelectSubset<T, omnichat_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__omnichat_userClient<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Omnichat_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Omnichat_users
     * const omnichat_users = await prisma.omnichat_user.findMany()
     * 
     * // Get first 10 Omnichat_users
     * const omnichat_users = await prisma.omnichat_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const omnichat_userWithIdOnly = await prisma.omnichat_user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends omnichat_userFindManyArgs>(args?: SelectSubset<T, omnichat_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Omnichat_user.
     * @param {omnichat_userCreateArgs} args - Arguments to create a Omnichat_user.
     * @example
     * // Create one Omnichat_user
     * const Omnichat_user = await prisma.omnichat_user.create({
     *   data: {
     *     // ... data to create a Omnichat_user
     *   }
     * })
     * 
     */
    create<T extends omnichat_userCreateArgs>(args: SelectSubset<T, omnichat_userCreateArgs<ExtArgs>>): Prisma__omnichat_userClient<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Omnichat_users.
     * @param {omnichat_userCreateManyArgs} args - Arguments to create many Omnichat_users.
     * @example
     * // Create many Omnichat_users
     * const omnichat_user = await prisma.omnichat_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends omnichat_userCreateManyArgs>(args?: SelectSubset<T, omnichat_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Omnichat_users and returns the data saved in the database.
     * @param {omnichat_userCreateManyAndReturnArgs} args - Arguments to create many Omnichat_users.
     * @example
     * // Create many Omnichat_users
     * const omnichat_user = await prisma.omnichat_user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Omnichat_users and only return the `id`
     * const omnichat_userWithIdOnly = await prisma.omnichat_user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends omnichat_userCreateManyAndReturnArgs>(args?: SelectSubset<T, omnichat_userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Omnichat_user.
     * @param {omnichat_userDeleteArgs} args - Arguments to delete one Omnichat_user.
     * @example
     * // Delete one Omnichat_user
     * const Omnichat_user = await prisma.omnichat_user.delete({
     *   where: {
     *     // ... filter to delete one Omnichat_user
     *   }
     * })
     * 
     */
    delete<T extends omnichat_userDeleteArgs>(args: SelectSubset<T, omnichat_userDeleteArgs<ExtArgs>>): Prisma__omnichat_userClient<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Omnichat_user.
     * @param {omnichat_userUpdateArgs} args - Arguments to update one Omnichat_user.
     * @example
     * // Update one Omnichat_user
     * const omnichat_user = await prisma.omnichat_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends omnichat_userUpdateArgs>(args: SelectSubset<T, omnichat_userUpdateArgs<ExtArgs>>): Prisma__omnichat_userClient<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Omnichat_users.
     * @param {omnichat_userDeleteManyArgs} args - Arguments to filter Omnichat_users to delete.
     * @example
     * // Delete a few Omnichat_users
     * const { count } = await prisma.omnichat_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends omnichat_userDeleteManyArgs>(args?: SelectSubset<T, omnichat_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Omnichat_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Omnichat_users
     * const omnichat_user = await prisma.omnichat_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends omnichat_userUpdateManyArgs>(args: SelectSubset<T, omnichat_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Omnichat_users and returns the data updated in the database.
     * @param {omnichat_userUpdateManyAndReturnArgs} args - Arguments to update many Omnichat_users.
     * @example
     * // Update many Omnichat_users
     * const omnichat_user = await prisma.omnichat_user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Omnichat_users and only return the `id`
     * const omnichat_userWithIdOnly = await prisma.omnichat_user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends omnichat_userUpdateManyAndReturnArgs>(args: SelectSubset<T, omnichat_userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Omnichat_user.
     * @param {omnichat_userUpsertArgs} args - Arguments to update or create a Omnichat_user.
     * @example
     * // Update or create a Omnichat_user
     * const omnichat_user = await prisma.omnichat_user.upsert({
     *   create: {
     *     // ... data to create a Omnichat_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Omnichat_user we want to update
     *   }
     * })
     */
    upsert<T extends omnichat_userUpsertArgs>(args: SelectSubset<T, omnichat_userUpsertArgs<ExtArgs>>): Prisma__omnichat_userClient<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Omnichat_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_userCountArgs} args - Arguments to filter Omnichat_users to count.
     * @example
     * // Count the number of Omnichat_users
     * const count = await prisma.omnichat_user.count({
     *   where: {
     *     // ... the filter for the Omnichat_users we want to count
     *   }
     * })
    **/
    count<T extends omnichat_userCountArgs>(
      args?: Subset<T, omnichat_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Omnichat_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Omnichat_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Omnichat_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Omnichat_userAggregateArgs>(args: Subset<T, Omnichat_userAggregateArgs>): Prisma.PrismaPromise<GetOmnichat_userAggregateType<T>>

    /**
     * Group by Omnichat_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends omnichat_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: omnichat_userGroupByArgs['orderBy'] }
        : { orderBy?: omnichat_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, omnichat_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOmnichat_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the omnichat_user model
   */
  readonly fields: omnichat_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for omnichat_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__omnichat_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    omnichat<T extends omnichat_user$omnichatArgs<ExtArgs> = {}>(args?: Subset<T, omnichat_user$omnichatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    omnichat_line<T extends omnichat_user$omnichat_lineArgs<ExtArgs> = {}>(args?: Subset<T, omnichat_user$omnichat_lineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the omnichat_user model
   */
  interface omnichat_userFieldRefs {
    readonly id: FieldRef<"omnichat_user", 'Int'>
    readonly username: FieldRef<"omnichat_user", 'String'>
    readonly thumbnailUrl: FieldRef<"omnichat_user", 'String'>
    readonly origin_id: FieldRef<"omnichat_user", 'String'>
    readonly createdAt: FieldRef<"omnichat_user", 'DateTime'>
    readonly externalId: FieldRef<"omnichat_user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * omnichat_user findUnique
   */
  export type omnichat_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
    /**
     * Filter, which omnichat_user to fetch.
     */
    where: omnichat_userWhereUniqueInput
  }

  /**
   * omnichat_user findUniqueOrThrow
   */
  export type omnichat_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
    /**
     * Filter, which omnichat_user to fetch.
     */
    where: omnichat_userWhereUniqueInput
  }

  /**
   * omnichat_user findFirst
   */
  export type omnichat_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
    /**
     * Filter, which omnichat_user to fetch.
     */
    where?: omnichat_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichat_users to fetch.
     */
    orderBy?: omnichat_userOrderByWithRelationInput | omnichat_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for omnichat_users.
     */
    cursor?: omnichat_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichat_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichat_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of omnichat_users.
     */
    distinct?: Omnichat_userScalarFieldEnum | Omnichat_userScalarFieldEnum[]
  }

  /**
   * omnichat_user findFirstOrThrow
   */
  export type omnichat_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
    /**
     * Filter, which omnichat_user to fetch.
     */
    where?: omnichat_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichat_users to fetch.
     */
    orderBy?: omnichat_userOrderByWithRelationInput | omnichat_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for omnichat_users.
     */
    cursor?: omnichat_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichat_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichat_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of omnichat_users.
     */
    distinct?: Omnichat_userScalarFieldEnum | Omnichat_userScalarFieldEnum[]
  }

  /**
   * omnichat_user findMany
   */
  export type omnichat_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
    /**
     * Filter, which omnichat_users to fetch.
     */
    where?: omnichat_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichat_users to fetch.
     */
    orderBy?: omnichat_userOrderByWithRelationInput | omnichat_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing omnichat_users.
     */
    cursor?: omnichat_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichat_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichat_users.
     */
    skip?: number
    distinct?: Omnichat_userScalarFieldEnum | Omnichat_userScalarFieldEnum[]
  }

  /**
   * omnichat_user create
   */
  export type omnichat_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
    /**
     * The data needed to create a omnichat_user.
     */
    data?: XOR<omnichat_userCreateInput, omnichat_userUncheckedCreateInput>
  }

  /**
   * omnichat_user createMany
   */
  export type omnichat_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many omnichat_users.
     */
    data: omnichat_userCreateManyInput | omnichat_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * omnichat_user createManyAndReturn
   */
  export type omnichat_userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * The data used to create many omnichat_users.
     */
    data: omnichat_userCreateManyInput | omnichat_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * omnichat_user update
   */
  export type omnichat_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
    /**
     * The data needed to update a omnichat_user.
     */
    data: XOR<omnichat_userUpdateInput, omnichat_userUncheckedUpdateInput>
    /**
     * Choose, which omnichat_user to update.
     */
    where: omnichat_userWhereUniqueInput
  }

  /**
   * omnichat_user updateMany
   */
  export type omnichat_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update omnichat_users.
     */
    data: XOR<omnichat_userUpdateManyMutationInput, omnichat_userUncheckedUpdateManyInput>
    /**
     * Filter which omnichat_users to update
     */
    where?: omnichat_userWhereInput
    /**
     * Limit how many omnichat_users to update.
     */
    limit?: number
  }

  /**
   * omnichat_user updateManyAndReturn
   */
  export type omnichat_userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * The data used to update omnichat_users.
     */
    data: XOR<omnichat_userUpdateManyMutationInput, omnichat_userUncheckedUpdateManyInput>
    /**
     * Filter which omnichat_users to update
     */
    where?: omnichat_userWhereInput
    /**
     * Limit how many omnichat_users to update.
     */
    limit?: number
  }

  /**
   * omnichat_user upsert
   */
  export type omnichat_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
    /**
     * The filter to search for the omnichat_user to update in case it exists.
     */
    where: omnichat_userWhereUniqueInput
    /**
     * In case the omnichat_user found by the `where` argument doesn't exist, create a new omnichat_user with this data.
     */
    create: XOR<omnichat_userCreateInput, omnichat_userUncheckedCreateInput>
    /**
     * In case the omnichat_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<omnichat_userUpdateInput, omnichat_userUncheckedUpdateInput>
  }

  /**
   * omnichat_user delete
   */
  export type omnichat_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
    /**
     * Filter which omnichat_user to delete.
     */
    where: omnichat_userWhereUniqueInput
  }

  /**
   * omnichat_user deleteMany
   */
  export type omnichat_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which omnichat_users to delete
     */
    where?: omnichat_userWhereInput
    /**
     * Limit how many omnichat_users to delete.
     */
    limit?: number
  }

  /**
   * omnichat_user.omnichat
   */
  export type omnichat_user$omnichatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    where?: omnichatWhereInput
    orderBy?: omnichatOrderByWithRelationInput | omnichatOrderByWithRelationInput[]
    cursor?: omnichatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OmnichatScalarFieldEnum | OmnichatScalarFieldEnum[]
  }

  /**
   * omnichat_user.omnichat_line
   */
  export type omnichat_user$omnichat_lineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
    where?: omnichat_lineWhereInput
    orderBy?: omnichat_lineOrderByWithRelationInput | omnichat_lineOrderByWithRelationInput[]
    cursor?: omnichat_lineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Omnichat_lineScalarFieldEnum | Omnichat_lineScalarFieldEnum[]
  }

  /**
   * omnichat_user without action
   */
  export type omnichat_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
  }


  /**
   * Model omnichat
   */

  export type AggregateOmnichat = {
    _count: OmnichatCountAggregateOutputType | null
    _avg: OmnichatAvgAggregateOutputType | null
    _sum: OmnichatSumAggregateOutputType | null
    _min: OmnichatMinAggregateOutputType | null
    _max: OmnichatMaxAggregateOutputType | null
  }

  export type OmnichatAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
    omnichat_userId: number | null
  }

  export type OmnichatSumAggregateOutputType = {
    id: number | null
    storeId: number | null
    omnichat_userId: number | null
  }

  export type OmnichatMinAggregateOutputType = {
    id: number | null
    origin_id: string | null
    last_message: string | null
    last_messageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: number | null
    omnichat_userId: number | null
    externalId: string | null
  }

  export type OmnichatMaxAggregateOutputType = {
    id: number | null
    origin_id: string | null
    last_message: string | null
    last_messageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    storeId: number | null
    omnichat_userId: number | null
    externalId: string | null
  }

  export type OmnichatCountAggregateOutputType = {
    id: number
    origin_id: number
    last_message: number
    last_messageId: number
    createdAt: number
    updatedAt: number
    storeId: number
    omnichat_userId: number
    externalId: number
    _all: number
  }


  export type OmnichatAvgAggregateInputType = {
    id?: true
    storeId?: true
    omnichat_userId?: true
  }

  export type OmnichatSumAggregateInputType = {
    id?: true
    storeId?: true
    omnichat_userId?: true
  }

  export type OmnichatMinAggregateInputType = {
    id?: true
    origin_id?: true
    last_message?: true
    last_messageId?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    omnichat_userId?: true
    externalId?: true
  }

  export type OmnichatMaxAggregateInputType = {
    id?: true
    origin_id?: true
    last_message?: true
    last_messageId?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    omnichat_userId?: true
    externalId?: true
  }

  export type OmnichatCountAggregateInputType = {
    id?: true
    origin_id?: true
    last_message?: true
    last_messageId?: true
    createdAt?: true
    updatedAt?: true
    storeId?: true
    omnichat_userId?: true
    externalId?: true
    _all?: true
  }

  export type OmnichatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which omnichat to aggregate.
     */
    where?: omnichatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichats to fetch.
     */
    orderBy?: omnichatOrderByWithRelationInput | omnichatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: omnichatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned omnichats
    **/
    _count?: true | OmnichatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OmnichatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OmnichatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OmnichatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OmnichatMaxAggregateInputType
  }

  export type GetOmnichatAggregateType<T extends OmnichatAggregateArgs> = {
        [P in keyof T & keyof AggregateOmnichat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOmnichat[P]>
      : GetScalarType<T[P], AggregateOmnichat[P]>
  }




  export type omnichatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: omnichatWhereInput
    orderBy?: omnichatOrderByWithAggregationInput | omnichatOrderByWithAggregationInput[]
    by: OmnichatScalarFieldEnum[] | OmnichatScalarFieldEnum
    having?: omnichatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OmnichatCountAggregateInputType | true
    _avg?: OmnichatAvgAggregateInputType
    _sum?: OmnichatSumAggregateInputType
    _min?: OmnichatMinAggregateInputType
    _max?: OmnichatMaxAggregateInputType
  }

  export type OmnichatGroupByOutputType = {
    id: number
    origin_id: string | null
    last_message: string
    last_messageId: string | null
    createdAt: Date
    updatedAt: Date
    storeId: number | null
    omnichat_userId: number | null
    externalId: string | null
    _count: OmnichatCountAggregateOutputType | null
    _avg: OmnichatAvgAggregateOutputType | null
    _sum: OmnichatSumAggregateOutputType | null
    _min: OmnichatMinAggregateOutputType | null
    _max: OmnichatMaxAggregateOutputType | null
  }

  type GetOmnichatGroupByPayload<T extends omnichatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OmnichatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OmnichatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OmnichatGroupByOutputType[P]>
            : GetScalarType<T[P], OmnichatGroupByOutputType[P]>
        }
      >
    >


  export type omnichatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    last_message?: boolean
    last_messageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    omnichat_userId?: boolean
    externalId?: boolean
    omnichat_user?: boolean | omnichat$omnichat_userArgs<ExtArgs>
    store?: boolean | omnichat$storeArgs<ExtArgs>
    messages?: boolean | omnichat$messagesArgs<ExtArgs>
    _count?: boolean | OmnichatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["omnichat"]>

  export type omnichatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    last_message?: boolean
    last_messageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    omnichat_userId?: boolean
    externalId?: boolean
    omnichat_user?: boolean | omnichat$omnichat_userArgs<ExtArgs>
    store?: boolean | omnichat$storeArgs<ExtArgs>
  }, ExtArgs["result"]["omnichat"]>

  export type omnichatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    last_message?: boolean
    last_messageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    omnichat_userId?: boolean
    externalId?: boolean
    omnichat_user?: boolean | omnichat$omnichat_userArgs<ExtArgs>
    store?: boolean | omnichat$storeArgs<ExtArgs>
  }, ExtArgs["result"]["omnichat"]>

  export type omnichatSelectScalar = {
    id?: boolean
    origin_id?: boolean
    last_message?: boolean
    last_messageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storeId?: boolean
    omnichat_userId?: boolean
    externalId?: boolean
  }

  export type omnichatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "origin_id" | "last_message" | "last_messageId" | "createdAt" | "updatedAt" | "storeId" | "omnichat_userId" | "externalId", ExtArgs["result"]["omnichat"]>
  export type omnichatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    omnichat_user?: boolean | omnichat$omnichat_userArgs<ExtArgs>
    store?: boolean | omnichat$storeArgs<ExtArgs>
    messages?: boolean | omnichat$messagesArgs<ExtArgs>
    _count?: boolean | OmnichatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type omnichatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    omnichat_user?: boolean | omnichat$omnichat_userArgs<ExtArgs>
    store?: boolean | omnichat$storeArgs<ExtArgs>
  }
  export type omnichatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    omnichat_user?: boolean | omnichat$omnichat_userArgs<ExtArgs>
    store?: boolean | omnichat$storeArgs<ExtArgs>
  }

  export type $omnichatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "omnichat"
    objects: {
      omnichat_user: Prisma.$omnichat_userPayload<ExtArgs> | null
      store: Prisma.$storePayload<ExtArgs> | null
      messages: Prisma.$omnichat_linePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      origin_id: string | null
      last_message: string
      last_messageId: string | null
      createdAt: Date
      updatedAt: Date
      storeId: number | null
      omnichat_userId: number | null
      externalId: string | null
    }, ExtArgs["result"]["omnichat"]>
    composites: {}
  }

  type omnichatGetPayload<S extends boolean | null | undefined | omnichatDefaultArgs> = $Result.GetResult<Prisma.$omnichatPayload, S>

  type omnichatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<omnichatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OmnichatCountAggregateInputType | true
    }

  export interface omnichatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['omnichat'], meta: { name: 'omnichat' } }
    /**
     * Find zero or one Omnichat that matches the filter.
     * @param {omnichatFindUniqueArgs} args - Arguments to find a Omnichat
     * @example
     * // Get one Omnichat
     * const omnichat = await prisma.omnichat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends omnichatFindUniqueArgs>(args: SelectSubset<T, omnichatFindUniqueArgs<ExtArgs>>): Prisma__omnichatClient<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Omnichat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {omnichatFindUniqueOrThrowArgs} args - Arguments to find a Omnichat
     * @example
     * // Get one Omnichat
     * const omnichat = await prisma.omnichat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends omnichatFindUniqueOrThrowArgs>(args: SelectSubset<T, omnichatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__omnichatClient<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Omnichat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichatFindFirstArgs} args - Arguments to find a Omnichat
     * @example
     * // Get one Omnichat
     * const omnichat = await prisma.omnichat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends omnichatFindFirstArgs>(args?: SelectSubset<T, omnichatFindFirstArgs<ExtArgs>>): Prisma__omnichatClient<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Omnichat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichatFindFirstOrThrowArgs} args - Arguments to find a Omnichat
     * @example
     * // Get one Omnichat
     * const omnichat = await prisma.omnichat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends omnichatFindFirstOrThrowArgs>(args?: SelectSubset<T, omnichatFindFirstOrThrowArgs<ExtArgs>>): Prisma__omnichatClient<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Omnichats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Omnichats
     * const omnichats = await prisma.omnichat.findMany()
     * 
     * // Get first 10 Omnichats
     * const omnichats = await prisma.omnichat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const omnichatWithIdOnly = await prisma.omnichat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends omnichatFindManyArgs>(args?: SelectSubset<T, omnichatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Omnichat.
     * @param {omnichatCreateArgs} args - Arguments to create a Omnichat.
     * @example
     * // Create one Omnichat
     * const Omnichat = await prisma.omnichat.create({
     *   data: {
     *     // ... data to create a Omnichat
     *   }
     * })
     * 
     */
    create<T extends omnichatCreateArgs>(args: SelectSubset<T, omnichatCreateArgs<ExtArgs>>): Prisma__omnichatClient<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Omnichats.
     * @param {omnichatCreateManyArgs} args - Arguments to create many Omnichats.
     * @example
     * // Create many Omnichats
     * const omnichat = await prisma.omnichat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends omnichatCreateManyArgs>(args?: SelectSubset<T, omnichatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Omnichats and returns the data saved in the database.
     * @param {omnichatCreateManyAndReturnArgs} args - Arguments to create many Omnichats.
     * @example
     * // Create many Omnichats
     * const omnichat = await prisma.omnichat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Omnichats and only return the `id`
     * const omnichatWithIdOnly = await prisma.omnichat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends omnichatCreateManyAndReturnArgs>(args?: SelectSubset<T, omnichatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Omnichat.
     * @param {omnichatDeleteArgs} args - Arguments to delete one Omnichat.
     * @example
     * // Delete one Omnichat
     * const Omnichat = await prisma.omnichat.delete({
     *   where: {
     *     // ... filter to delete one Omnichat
     *   }
     * })
     * 
     */
    delete<T extends omnichatDeleteArgs>(args: SelectSubset<T, omnichatDeleteArgs<ExtArgs>>): Prisma__omnichatClient<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Omnichat.
     * @param {omnichatUpdateArgs} args - Arguments to update one Omnichat.
     * @example
     * // Update one Omnichat
     * const omnichat = await prisma.omnichat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends omnichatUpdateArgs>(args: SelectSubset<T, omnichatUpdateArgs<ExtArgs>>): Prisma__omnichatClient<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Omnichats.
     * @param {omnichatDeleteManyArgs} args - Arguments to filter Omnichats to delete.
     * @example
     * // Delete a few Omnichats
     * const { count } = await prisma.omnichat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends omnichatDeleteManyArgs>(args?: SelectSubset<T, omnichatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Omnichats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Omnichats
     * const omnichat = await prisma.omnichat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends omnichatUpdateManyArgs>(args: SelectSubset<T, omnichatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Omnichats and returns the data updated in the database.
     * @param {omnichatUpdateManyAndReturnArgs} args - Arguments to update many Omnichats.
     * @example
     * // Update many Omnichats
     * const omnichat = await prisma.omnichat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Omnichats and only return the `id`
     * const omnichatWithIdOnly = await prisma.omnichat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends omnichatUpdateManyAndReturnArgs>(args: SelectSubset<T, omnichatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Omnichat.
     * @param {omnichatUpsertArgs} args - Arguments to update or create a Omnichat.
     * @example
     * // Update or create a Omnichat
     * const omnichat = await prisma.omnichat.upsert({
     *   create: {
     *     // ... data to create a Omnichat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Omnichat we want to update
     *   }
     * })
     */
    upsert<T extends omnichatUpsertArgs>(args: SelectSubset<T, omnichatUpsertArgs<ExtArgs>>): Prisma__omnichatClient<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Omnichats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichatCountArgs} args - Arguments to filter Omnichats to count.
     * @example
     * // Count the number of Omnichats
     * const count = await prisma.omnichat.count({
     *   where: {
     *     // ... the filter for the Omnichats we want to count
     *   }
     * })
    **/
    count<T extends omnichatCountArgs>(
      args?: Subset<T, omnichatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OmnichatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Omnichat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OmnichatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OmnichatAggregateArgs>(args: Subset<T, OmnichatAggregateArgs>): Prisma.PrismaPromise<GetOmnichatAggregateType<T>>

    /**
     * Group by Omnichat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends omnichatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: omnichatGroupByArgs['orderBy'] }
        : { orderBy?: omnichatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, omnichatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOmnichatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the omnichat model
   */
  readonly fields: omnichatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for omnichat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__omnichatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    omnichat_user<T extends omnichat$omnichat_userArgs<ExtArgs> = {}>(args?: Subset<T, omnichat$omnichat_userArgs<ExtArgs>>): Prisma__omnichat_userClient<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    store<T extends omnichat$storeArgs<ExtArgs> = {}>(args?: Subset<T, omnichat$storeArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends omnichat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, omnichat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the omnichat model
   */
  interface omnichatFieldRefs {
    readonly id: FieldRef<"omnichat", 'Int'>
    readonly origin_id: FieldRef<"omnichat", 'String'>
    readonly last_message: FieldRef<"omnichat", 'String'>
    readonly last_messageId: FieldRef<"omnichat", 'String'>
    readonly createdAt: FieldRef<"omnichat", 'DateTime'>
    readonly updatedAt: FieldRef<"omnichat", 'DateTime'>
    readonly storeId: FieldRef<"omnichat", 'Int'>
    readonly omnichat_userId: FieldRef<"omnichat", 'Int'>
    readonly externalId: FieldRef<"omnichat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * omnichat findUnique
   */
  export type omnichatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    /**
     * Filter, which omnichat to fetch.
     */
    where: omnichatWhereUniqueInput
  }

  /**
   * omnichat findUniqueOrThrow
   */
  export type omnichatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    /**
     * Filter, which omnichat to fetch.
     */
    where: omnichatWhereUniqueInput
  }

  /**
   * omnichat findFirst
   */
  export type omnichatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    /**
     * Filter, which omnichat to fetch.
     */
    where?: omnichatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichats to fetch.
     */
    orderBy?: omnichatOrderByWithRelationInput | omnichatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for omnichats.
     */
    cursor?: omnichatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of omnichats.
     */
    distinct?: OmnichatScalarFieldEnum | OmnichatScalarFieldEnum[]
  }

  /**
   * omnichat findFirstOrThrow
   */
  export type omnichatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    /**
     * Filter, which omnichat to fetch.
     */
    where?: omnichatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichats to fetch.
     */
    orderBy?: omnichatOrderByWithRelationInput | omnichatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for omnichats.
     */
    cursor?: omnichatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of omnichats.
     */
    distinct?: OmnichatScalarFieldEnum | OmnichatScalarFieldEnum[]
  }

  /**
   * omnichat findMany
   */
  export type omnichatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    /**
     * Filter, which omnichats to fetch.
     */
    where?: omnichatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichats to fetch.
     */
    orderBy?: omnichatOrderByWithRelationInput | omnichatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing omnichats.
     */
    cursor?: omnichatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichats.
     */
    skip?: number
    distinct?: OmnichatScalarFieldEnum | OmnichatScalarFieldEnum[]
  }

  /**
   * omnichat create
   */
  export type omnichatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    /**
     * The data needed to create a omnichat.
     */
    data: XOR<omnichatCreateInput, omnichatUncheckedCreateInput>
  }

  /**
   * omnichat createMany
   */
  export type omnichatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many omnichats.
     */
    data: omnichatCreateManyInput | omnichatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * omnichat createManyAndReturn
   */
  export type omnichatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * The data used to create many omnichats.
     */
    data: omnichatCreateManyInput | omnichatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * omnichat update
   */
  export type omnichatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    /**
     * The data needed to update a omnichat.
     */
    data: XOR<omnichatUpdateInput, omnichatUncheckedUpdateInput>
    /**
     * Choose, which omnichat to update.
     */
    where: omnichatWhereUniqueInput
  }

  /**
   * omnichat updateMany
   */
  export type omnichatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update omnichats.
     */
    data: XOR<omnichatUpdateManyMutationInput, omnichatUncheckedUpdateManyInput>
    /**
     * Filter which omnichats to update
     */
    where?: omnichatWhereInput
    /**
     * Limit how many omnichats to update.
     */
    limit?: number
  }

  /**
   * omnichat updateManyAndReturn
   */
  export type omnichatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * The data used to update omnichats.
     */
    data: XOR<omnichatUpdateManyMutationInput, omnichatUncheckedUpdateManyInput>
    /**
     * Filter which omnichats to update
     */
    where?: omnichatWhereInput
    /**
     * Limit how many omnichats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * omnichat upsert
   */
  export type omnichatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    /**
     * The filter to search for the omnichat to update in case it exists.
     */
    where: omnichatWhereUniqueInput
    /**
     * In case the omnichat found by the `where` argument doesn't exist, create a new omnichat with this data.
     */
    create: XOR<omnichatCreateInput, omnichatUncheckedCreateInput>
    /**
     * In case the omnichat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<omnichatUpdateInput, omnichatUncheckedUpdateInput>
  }

  /**
   * omnichat delete
   */
  export type omnichatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    /**
     * Filter which omnichat to delete.
     */
    where: omnichatWhereUniqueInput
  }

  /**
   * omnichat deleteMany
   */
  export type omnichatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which omnichats to delete
     */
    where?: omnichatWhereInput
    /**
     * Limit how many omnichats to delete.
     */
    limit?: number
  }

  /**
   * omnichat.omnichat_user
   */
  export type omnichat$omnichat_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
    where?: omnichat_userWhereInput
  }

  /**
   * omnichat.store
   */
  export type omnichat$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    where?: storeWhereInput
  }

  /**
   * omnichat.messages
   */
  export type omnichat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
    where?: omnichat_lineWhereInput
    orderBy?: omnichat_lineOrderByWithRelationInput | omnichat_lineOrderByWithRelationInput[]
    cursor?: omnichat_lineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Omnichat_lineScalarFieldEnum | Omnichat_lineScalarFieldEnum[]
  }

  /**
   * omnichat without action
   */
  export type omnichatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
  }


  /**
   * Model omnichat_line
   */

  export type AggregateOmnichat_line = {
    _count: Omnichat_lineCountAggregateOutputType | null
    _avg: Omnichat_lineAvgAggregateOutputType | null
    _sum: Omnichat_lineSumAggregateOutputType | null
    _min: Omnichat_lineMinAggregateOutputType | null
    _max: Omnichat_lineMaxAggregateOutputType | null
  }

  export type Omnichat_lineAvgAggregateOutputType = {
    id: number | null
    omnichatId: number | null
    omnichat_userId: number | null
  }

  export type Omnichat_lineSumAggregateOutputType = {
    id: number | null
    omnichatId: number | null
    omnichat_userId: number | null
  }

  export type Omnichat_lineMinAggregateOutputType = {
    id: number | null
    origin_id: string | null
    createdAt: Date | null
    line_text: string | null
    omnichatId: number | null
    author: string | null
    omnichat_userId: number | null
    chat_type: string | null
  }

  export type Omnichat_lineMaxAggregateOutputType = {
    id: number | null
    origin_id: string | null
    createdAt: Date | null
    line_text: string | null
    omnichatId: number | null
    author: string | null
    omnichat_userId: number | null
    chat_type: string | null
  }

  export type Omnichat_lineCountAggregateOutputType = {
    id: number
    origin_id: number
    createdAt: number
    line_text: number
    omnichatId: number
    author: number
    omnichat_userId: number
    chat_type: number
    _all: number
  }


  export type Omnichat_lineAvgAggregateInputType = {
    id?: true
    omnichatId?: true
    omnichat_userId?: true
  }

  export type Omnichat_lineSumAggregateInputType = {
    id?: true
    omnichatId?: true
    omnichat_userId?: true
  }

  export type Omnichat_lineMinAggregateInputType = {
    id?: true
    origin_id?: true
    createdAt?: true
    line_text?: true
    omnichatId?: true
    author?: true
    omnichat_userId?: true
    chat_type?: true
  }

  export type Omnichat_lineMaxAggregateInputType = {
    id?: true
    origin_id?: true
    createdAt?: true
    line_text?: true
    omnichatId?: true
    author?: true
    omnichat_userId?: true
    chat_type?: true
  }

  export type Omnichat_lineCountAggregateInputType = {
    id?: true
    origin_id?: true
    createdAt?: true
    line_text?: true
    omnichatId?: true
    author?: true
    omnichat_userId?: true
    chat_type?: true
    _all?: true
  }

  export type Omnichat_lineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which omnichat_line to aggregate.
     */
    where?: omnichat_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichat_lines to fetch.
     */
    orderBy?: omnichat_lineOrderByWithRelationInput | omnichat_lineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: omnichat_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichat_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichat_lines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned omnichat_lines
    **/
    _count?: true | Omnichat_lineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Omnichat_lineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Omnichat_lineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Omnichat_lineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Omnichat_lineMaxAggregateInputType
  }

  export type GetOmnichat_lineAggregateType<T extends Omnichat_lineAggregateArgs> = {
        [P in keyof T & keyof AggregateOmnichat_line]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOmnichat_line[P]>
      : GetScalarType<T[P], AggregateOmnichat_line[P]>
  }




  export type omnichat_lineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: omnichat_lineWhereInput
    orderBy?: omnichat_lineOrderByWithAggregationInput | omnichat_lineOrderByWithAggregationInput[]
    by: Omnichat_lineScalarFieldEnum[] | Omnichat_lineScalarFieldEnum
    having?: omnichat_lineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Omnichat_lineCountAggregateInputType | true
    _avg?: Omnichat_lineAvgAggregateInputType
    _sum?: Omnichat_lineSumAggregateInputType
    _min?: Omnichat_lineMinAggregateInputType
    _max?: Omnichat_lineMaxAggregateInputType
  }

  export type Omnichat_lineGroupByOutputType = {
    id: number
    origin_id: string | null
    createdAt: Date
    line_text: string
    omnichatId: number | null
    author: string | null
    omnichat_userId: number | null
    chat_type: string | null
    _count: Omnichat_lineCountAggregateOutputType | null
    _avg: Omnichat_lineAvgAggregateOutputType | null
    _sum: Omnichat_lineSumAggregateOutputType | null
    _min: Omnichat_lineMinAggregateOutputType | null
    _max: Omnichat_lineMaxAggregateOutputType | null
  }

  type GetOmnichat_lineGroupByPayload<T extends omnichat_lineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Omnichat_lineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Omnichat_lineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Omnichat_lineGroupByOutputType[P]>
            : GetScalarType<T[P], Omnichat_lineGroupByOutputType[P]>
        }
      >
    >


  export type omnichat_lineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    createdAt?: boolean
    line_text?: boolean
    omnichatId?: boolean
    author?: boolean
    omnichat_userId?: boolean
    chat_type?: boolean
    omnichat?: boolean | omnichat_line$omnichatArgs<ExtArgs>
    omnichat_user?: boolean | omnichat_line$omnichat_userArgs<ExtArgs>
  }, ExtArgs["result"]["omnichat_line"]>

  export type omnichat_lineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    createdAt?: boolean
    line_text?: boolean
    omnichatId?: boolean
    author?: boolean
    omnichat_userId?: boolean
    chat_type?: boolean
    omnichat?: boolean | omnichat_line$omnichatArgs<ExtArgs>
    omnichat_user?: boolean | omnichat_line$omnichat_userArgs<ExtArgs>
  }, ExtArgs["result"]["omnichat_line"]>

  export type omnichat_lineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    createdAt?: boolean
    line_text?: boolean
    omnichatId?: boolean
    author?: boolean
    omnichat_userId?: boolean
    chat_type?: boolean
    omnichat?: boolean | omnichat_line$omnichatArgs<ExtArgs>
    omnichat_user?: boolean | omnichat_line$omnichat_userArgs<ExtArgs>
  }, ExtArgs["result"]["omnichat_line"]>

  export type omnichat_lineSelectScalar = {
    id?: boolean
    origin_id?: boolean
    createdAt?: boolean
    line_text?: boolean
    omnichatId?: boolean
    author?: boolean
    omnichat_userId?: boolean
    chat_type?: boolean
  }

  export type omnichat_lineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "origin_id" | "createdAt" | "line_text" | "omnichatId" | "author" | "omnichat_userId" | "chat_type", ExtArgs["result"]["omnichat_line"]>
  export type omnichat_lineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    omnichat?: boolean | omnichat_line$omnichatArgs<ExtArgs>
    omnichat_user?: boolean | omnichat_line$omnichat_userArgs<ExtArgs>
  }
  export type omnichat_lineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    omnichat?: boolean | omnichat_line$omnichatArgs<ExtArgs>
    omnichat_user?: boolean | omnichat_line$omnichat_userArgs<ExtArgs>
  }
  export type omnichat_lineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    omnichat?: boolean | omnichat_line$omnichatArgs<ExtArgs>
    omnichat_user?: boolean | omnichat_line$omnichat_userArgs<ExtArgs>
  }

  export type $omnichat_linePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "omnichat_line"
    objects: {
      omnichat: Prisma.$omnichatPayload<ExtArgs> | null
      omnichat_user: Prisma.$omnichat_userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      origin_id: string | null
      createdAt: Date
      line_text: string
      omnichatId: number | null
      author: string | null
      omnichat_userId: number | null
      chat_type: string | null
    }, ExtArgs["result"]["omnichat_line"]>
    composites: {}
  }

  type omnichat_lineGetPayload<S extends boolean | null | undefined | omnichat_lineDefaultArgs> = $Result.GetResult<Prisma.$omnichat_linePayload, S>

  type omnichat_lineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<omnichat_lineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Omnichat_lineCountAggregateInputType | true
    }

  export interface omnichat_lineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['omnichat_line'], meta: { name: 'omnichat_line' } }
    /**
     * Find zero or one Omnichat_line that matches the filter.
     * @param {omnichat_lineFindUniqueArgs} args - Arguments to find a Omnichat_line
     * @example
     * // Get one Omnichat_line
     * const omnichat_line = await prisma.omnichat_line.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends omnichat_lineFindUniqueArgs>(args: SelectSubset<T, omnichat_lineFindUniqueArgs<ExtArgs>>): Prisma__omnichat_lineClient<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Omnichat_line that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {omnichat_lineFindUniqueOrThrowArgs} args - Arguments to find a Omnichat_line
     * @example
     * // Get one Omnichat_line
     * const omnichat_line = await prisma.omnichat_line.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends omnichat_lineFindUniqueOrThrowArgs>(args: SelectSubset<T, omnichat_lineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__omnichat_lineClient<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Omnichat_line that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_lineFindFirstArgs} args - Arguments to find a Omnichat_line
     * @example
     * // Get one Omnichat_line
     * const omnichat_line = await prisma.omnichat_line.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends omnichat_lineFindFirstArgs>(args?: SelectSubset<T, omnichat_lineFindFirstArgs<ExtArgs>>): Prisma__omnichat_lineClient<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Omnichat_line that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_lineFindFirstOrThrowArgs} args - Arguments to find a Omnichat_line
     * @example
     * // Get one Omnichat_line
     * const omnichat_line = await prisma.omnichat_line.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends omnichat_lineFindFirstOrThrowArgs>(args?: SelectSubset<T, omnichat_lineFindFirstOrThrowArgs<ExtArgs>>): Prisma__omnichat_lineClient<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Omnichat_lines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_lineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Omnichat_lines
     * const omnichat_lines = await prisma.omnichat_line.findMany()
     * 
     * // Get first 10 Omnichat_lines
     * const omnichat_lines = await prisma.omnichat_line.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const omnichat_lineWithIdOnly = await prisma.omnichat_line.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends omnichat_lineFindManyArgs>(args?: SelectSubset<T, omnichat_lineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Omnichat_line.
     * @param {omnichat_lineCreateArgs} args - Arguments to create a Omnichat_line.
     * @example
     * // Create one Omnichat_line
     * const Omnichat_line = await prisma.omnichat_line.create({
     *   data: {
     *     // ... data to create a Omnichat_line
     *   }
     * })
     * 
     */
    create<T extends omnichat_lineCreateArgs>(args: SelectSubset<T, omnichat_lineCreateArgs<ExtArgs>>): Prisma__omnichat_lineClient<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Omnichat_lines.
     * @param {omnichat_lineCreateManyArgs} args - Arguments to create many Omnichat_lines.
     * @example
     * // Create many Omnichat_lines
     * const omnichat_line = await prisma.omnichat_line.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends omnichat_lineCreateManyArgs>(args?: SelectSubset<T, omnichat_lineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Omnichat_lines and returns the data saved in the database.
     * @param {omnichat_lineCreateManyAndReturnArgs} args - Arguments to create many Omnichat_lines.
     * @example
     * // Create many Omnichat_lines
     * const omnichat_line = await prisma.omnichat_line.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Omnichat_lines and only return the `id`
     * const omnichat_lineWithIdOnly = await prisma.omnichat_line.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends omnichat_lineCreateManyAndReturnArgs>(args?: SelectSubset<T, omnichat_lineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Omnichat_line.
     * @param {omnichat_lineDeleteArgs} args - Arguments to delete one Omnichat_line.
     * @example
     * // Delete one Omnichat_line
     * const Omnichat_line = await prisma.omnichat_line.delete({
     *   where: {
     *     // ... filter to delete one Omnichat_line
     *   }
     * })
     * 
     */
    delete<T extends omnichat_lineDeleteArgs>(args: SelectSubset<T, omnichat_lineDeleteArgs<ExtArgs>>): Prisma__omnichat_lineClient<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Omnichat_line.
     * @param {omnichat_lineUpdateArgs} args - Arguments to update one Omnichat_line.
     * @example
     * // Update one Omnichat_line
     * const omnichat_line = await prisma.omnichat_line.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends omnichat_lineUpdateArgs>(args: SelectSubset<T, omnichat_lineUpdateArgs<ExtArgs>>): Prisma__omnichat_lineClient<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Omnichat_lines.
     * @param {omnichat_lineDeleteManyArgs} args - Arguments to filter Omnichat_lines to delete.
     * @example
     * // Delete a few Omnichat_lines
     * const { count } = await prisma.omnichat_line.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends omnichat_lineDeleteManyArgs>(args?: SelectSubset<T, omnichat_lineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Omnichat_lines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_lineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Omnichat_lines
     * const omnichat_line = await prisma.omnichat_line.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends omnichat_lineUpdateManyArgs>(args: SelectSubset<T, omnichat_lineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Omnichat_lines and returns the data updated in the database.
     * @param {omnichat_lineUpdateManyAndReturnArgs} args - Arguments to update many Omnichat_lines.
     * @example
     * // Update many Omnichat_lines
     * const omnichat_line = await prisma.omnichat_line.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Omnichat_lines and only return the `id`
     * const omnichat_lineWithIdOnly = await prisma.omnichat_line.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends omnichat_lineUpdateManyAndReturnArgs>(args: SelectSubset<T, omnichat_lineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Omnichat_line.
     * @param {omnichat_lineUpsertArgs} args - Arguments to update or create a Omnichat_line.
     * @example
     * // Update or create a Omnichat_line
     * const omnichat_line = await prisma.omnichat_line.upsert({
     *   create: {
     *     // ... data to create a Omnichat_line
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Omnichat_line we want to update
     *   }
     * })
     */
    upsert<T extends omnichat_lineUpsertArgs>(args: SelectSubset<T, omnichat_lineUpsertArgs<ExtArgs>>): Prisma__omnichat_lineClient<$Result.GetResult<Prisma.$omnichat_linePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Omnichat_lines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_lineCountArgs} args - Arguments to filter Omnichat_lines to count.
     * @example
     * // Count the number of Omnichat_lines
     * const count = await prisma.omnichat_line.count({
     *   where: {
     *     // ... the filter for the Omnichat_lines we want to count
     *   }
     * })
    **/
    count<T extends omnichat_lineCountArgs>(
      args?: Subset<T, omnichat_lineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Omnichat_lineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Omnichat_line.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Omnichat_lineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Omnichat_lineAggregateArgs>(args: Subset<T, Omnichat_lineAggregateArgs>): Prisma.PrismaPromise<GetOmnichat_lineAggregateType<T>>

    /**
     * Group by Omnichat_line.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnichat_lineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends omnichat_lineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: omnichat_lineGroupByArgs['orderBy'] }
        : { orderBy?: omnichat_lineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, omnichat_lineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOmnichat_lineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the omnichat_line model
   */
  readonly fields: omnichat_lineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for omnichat_line.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__omnichat_lineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    omnichat<T extends omnichat_line$omnichatArgs<ExtArgs> = {}>(args?: Subset<T, omnichat_line$omnichatArgs<ExtArgs>>): Prisma__omnichatClient<$Result.GetResult<Prisma.$omnichatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    omnichat_user<T extends omnichat_line$omnichat_userArgs<ExtArgs> = {}>(args?: Subset<T, omnichat_line$omnichat_userArgs<ExtArgs>>): Prisma__omnichat_userClient<$Result.GetResult<Prisma.$omnichat_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the omnichat_line model
   */
  interface omnichat_lineFieldRefs {
    readonly id: FieldRef<"omnichat_line", 'Int'>
    readonly origin_id: FieldRef<"omnichat_line", 'String'>
    readonly createdAt: FieldRef<"omnichat_line", 'DateTime'>
    readonly line_text: FieldRef<"omnichat_line", 'String'>
    readonly omnichatId: FieldRef<"omnichat_line", 'Int'>
    readonly author: FieldRef<"omnichat_line", 'String'>
    readonly omnichat_userId: FieldRef<"omnichat_line", 'Int'>
    readonly chat_type: FieldRef<"omnichat_line", 'String'>
  }
    

  // Custom InputTypes
  /**
   * omnichat_line findUnique
   */
  export type omnichat_lineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
    /**
     * Filter, which omnichat_line to fetch.
     */
    where: omnichat_lineWhereUniqueInput
  }

  /**
   * omnichat_line findUniqueOrThrow
   */
  export type omnichat_lineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
    /**
     * Filter, which omnichat_line to fetch.
     */
    where: omnichat_lineWhereUniqueInput
  }

  /**
   * omnichat_line findFirst
   */
  export type omnichat_lineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
    /**
     * Filter, which omnichat_line to fetch.
     */
    where?: omnichat_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichat_lines to fetch.
     */
    orderBy?: omnichat_lineOrderByWithRelationInput | omnichat_lineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for omnichat_lines.
     */
    cursor?: omnichat_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichat_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichat_lines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of omnichat_lines.
     */
    distinct?: Omnichat_lineScalarFieldEnum | Omnichat_lineScalarFieldEnum[]
  }

  /**
   * omnichat_line findFirstOrThrow
   */
  export type omnichat_lineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
    /**
     * Filter, which omnichat_line to fetch.
     */
    where?: omnichat_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichat_lines to fetch.
     */
    orderBy?: omnichat_lineOrderByWithRelationInput | omnichat_lineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for omnichat_lines.
     */
    cursor?: omnichat_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichat_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichat_lines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of omnichat_lines.
     */
    distinct?: Omnichat_lineScalarFieldEnum | Omnichat_lineScalarFieldEnum[]
  }

  /**
   * omnichat_line findMany
   */
  export type omnichat_lineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
    /**
     * Filter, which omnichat_lines to fetch.
     */
    where?: omnichat_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnichat_lines to fetch.
     */
    orderBy?: omnichat_lineOrderByWithRelationInput | omnichat_lineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing omnichat_lines.
     */
    cursor?: omnichat_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnichat_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnichat_lines.
     */
    skip?: number
    distinct?: Omnichat_lineScalarFieldEnum | Omnichat_lineScalarFieldEnum[]
  }

  /**
   * omnichat_line create
   */
  export type omnichat_lineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
    /**
     * The data needed to create a omnichat_line.
     */
    data: XOR<omnichat_lineCreateInput, omnichat_lineUncheckedCreateInput>
  }

  /**
   * omnichat_line createMany
   */
  export type omnichat_lineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many omnichat_lines.
     */
    data: omnichat_lineCreateManyInput | omnichat_lineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * omnichat_line createManyAndReturn
   */
  export type omnichat_lineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * The data used to create many omnichat_lines.
     */
    data: omnichat_lineCreateManyInput | omnichat_lineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * omnichat_line update
   */
  export type omnichat_lineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
    /**
     * The data needed to update a omnichat_line.
     */
    data: XOR<omnichat_lineUpdateInput, omnichat_lineUncheckedUpdateInput>
    /**
     * Choose, which omnichat_line to update.
     */
    where: omnichat_lineWhereUniqueInput
  }

  /**
   * omnichat_line updateMany
   */
  export type omnichat_lineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update omnichat_lines.
     */
    data: XOR<omnichat_lineUpdateManyMutationInput, omnichat_lineUncheckedUpdateManyInput>
    /**
     * Filter which omnichat_lines to update
     */
    where?: omnichat_lineWhereInput
    /**
     * Limit how many omnichat_lines to update.
     */
    limit?: number
  }

  /**
   * omnichat_line updateManyAndReturn
   */
  export type omnichat_lineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * The data used to update omnichat_lines.
     */
    data: XOR<omnichat_lineUpdateManyMutationInput, omnichat_lineUncheckedUpdateManyInput>
    /**
     * Filter which omnichat_lines to update
     */
    where?: omnichat_lineWhereInput
    /**
     * Limit how many omnichat_lines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * omnichat_line upsert
   */
  export type omnichat_lineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
    /**
     * The filter to search for the omnichat_line to update in case it exists.
     */
    where: omnichat_lineWhereUniqueInput
    /**
     * In case the omnichat_line found by the `where` argument doesn't exist, create a new omnichat_line with this data.
     */
    create: XOR<omnichat_lineCreateInput, omnichat_lineUncheckedCreateInput>
    /**
     * In case the omnichat_line was found with the provided `where` argument, update it with this data.
     */
    update: XOR<omnichat_lineUpdateInput, omnichat_lineUncheckedUpdateInput>
  }

  /**
   * omnichat_line delete
   */
  export type omnichat_lineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
    /**
     * Filter which omnichat_line to delete.
     */
    where: omnichat_lineWhereUniqueInput
  }

  /**
   * omnichat_line deleteMany
   */
  export type omnichat_lineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which omnichat_lines to delete
     */
    where?: omnichat_lineWhereInput
    /**
     * Limit how many omnichat_lines to delete.
     */
    limit?: number
  }

  /**
   * omnichat_line.omnichat
   */
  export type omnichat_line$omnichatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat
     */
    select?: omnichatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat
     */
    omit?: omnichatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichatInclude<ExtArgs> | null
    where?: omnichatWhereInput
  }

  /**
   * omnichat_line.omnichat_user
   */
  export type omnichat_line$omnichat_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_user
     */
    select?: omnichat_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_user
     */
    omit?: omnichat_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_userInclude<ExtArgs> | null
    where?: omnichat_userWhereInput
  }

  /**
   * omnichat_line without action
   */
  export type omnichat_lineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnichat_line
     */
    select?: omnichat_lineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnichat_line
     */
    omit?: omnichat_lineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: omnichat_lineInclude<ExtArgs> | null
  }


  /**
   * Model zdconnector
   */

  export type AggregateZdconnector = {
    _count: ZdconnectorCountAggregateOutputType | null
    _avg: ZdconnectorAvgAggregateOutputType | null
    _sum: ZdconnectorSumAggregateOutputType | null
    _min: ZdconnectorMinAggregateOutputType | null
    _max: ZdconnectorMaxAggregateOutputType | null
  }

  export type ZdconnectorAvgAggregateOutputType = {
    id: number | null
    clientsId: number | null
  }

  export type ZdconnectorSumAggregateOutputType = {
    id: number | null
    clientsId: number | null
  }

  export type ZdconnectorMinAggregateOutputType = {
    id: number | null
    name: string | null
    host: string | null
    createdAt: Date | null
    updatedAt: Date | null
    suncoAppId: string | null
    suncoAppKey: string | null
    suncoAppSecret: string | null
    zdAPIToken: string | null
    resource: string | null
    clientsId: number | null
  }

  export type ZdconnectorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    host: string | null
    createdAt: Date | null
    updatedAt: Date | null
    suncoAppId: string | null
    suncoAppKey: string | null
    suncoAppSecret: string | null
    zdAPIToken: string | null
    resource: string | null
    clientsId: number | null
  }

  export type ZdconnectorCountAggregateOutputType = {
    id: number
    name: number
    host: number
    createdAt: number
    updatedAt: number
    suncoAppId: number
    suncoAppKey: number
    suncoAppSecret: number
    zdAPIToken: number
    resource: number
    clientsId: number
    _all: number
  }


  export type ZdconnectorAvgAggregateInputType = {
    id?: true
    clientsId?: true
  }

  export type ZdconnectorSumAggregateInputType = {
    id?: true
    clientsId?: true
  }

  export type ZdconnectorMinAggregateInputType = {
    id?: true
    name?: true
    host?: true
    createdAt?: true
    updatedAt?: true
    suncoAppId?: true
    suncoAppKey?: true
    suncoAppSecret?: true
    zdAPIToken?: true
    resource?: true
    clientsId?: true
  }

  export type ZdconnectorMaxAggregateInputType = {
    id?: true
    name?: true
    host?: true
    createdAt?: true
    updatedAt?: true
    suncoAppId?: true
    suncoAppKey?: true
    suncoAppSecret?: true
    zdAPIToken?: true
    resource?: true
    clientsId?: true
  }

  export type ZdconnectorCountAggregateInputType = {
    id?: true
    name?: true
    host?: true
    createdAt?: true
    updatedAt?: true
    suncoAppId?: true
    suncoAppKey?: true
    suncoAppSecret?: true
    zdAPIToken?: true
    resource?: true
    clientsId?: true
    _all?: true
  }

  export type ZdconnectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zdconnector to aggregate.
     */
    where?: zdconnectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zdconnectors to fetch.
     */
    orderBy?: zdconnectorOrderByWithRelationInput | zdconnectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: zdconnectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zdconnectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zdconnectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned zdconnectors
    **/
    _count?: true | ZdconnectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZdconnectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZdconnectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZdconnectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZdconnectorMaxAggregateInputType
  }

  export type GetZdconnectorAggregateType<T extends ZdconnectorAggregateArgs> = {
        [P in keyof T & keyof AggregateZdconnector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZdconnector[P]>
      : GetScalarType<T[P], AggregateZdconnector[P]>
  }




  export type zdconnectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zdconnectorWhereInput
    orderBy?: zdconnectorOrderByWithAggregationInput | zdconnectorOrderByWithAggregationInput[]
    by: ZdconnectorScalarFieldEnum[] | ZdconnectorScalarFieldEnum
    having?: zdconnectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZdconnectorCountAggregateInputType | true
    _avg?: ZdconnectorAvgAggregateInputType
    _sum?: ZdconnectorSumAggregateInputType
    _min?: ZdconnectorMinAggregateInputType
    _max?: ZdconnectorMaxAggregateInputType
  }

  export type ZdconnectorGroupByOutputType = {
    id: number
    name: string
    host: string
    createdAt: Date
    updatedAt: Date
    suncoAppId: string
    suncoAppKey: string
    suncoAppSecret: string
    zdAPIToken: string
    resource: string | null
    clientsId: number | null
    _count: ZdconnectorCountAggregateOutputType | null
    _avg: ZdconnectorAvgAggregateOutputType | null
    _sum: ZdconnectorSumAggregateOutputType | null
    _min: ZdconnectorMinAggregateOutputType | null
    _max: ZdconnectorMaxAggregateOutputType | null
  }

  type GetZdconnectorGroupByPayload<T extends zdconnectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZdconnectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZdconnectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZdconnectorGroupByOutputType[P]>
            : GetScalarType<T[P], ZdconnectorGroupByOutputType[P]>
        }
      >
    >


  export type zdconnectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    host?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suncoAppId?: boolean
    suncoAppKey?: boolean
    suncoAppSecret?: boolean
    zdAPIToken?: boolean
    resource?: boolean
    clientsId?: boolean
  }, ExtArgs["result"]["zdconnector"]>

  export type zdconnectorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    host?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suncoAppId?: boolean
    suncoAppKey?: boolean
    suncoAppSecret?: boolean
    zdAPIToken?: boolean
    resource?: boolean
    clientsId?: boolean
  }, ExtArgs["result"]["zdconnector"]>

  export type zdconnectorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    host?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suncoAppId?: boolean
    suncoAppKey?: boolean
    suncoAppSecret?: boolean
    zdAPIToken?: boolean
    resource?: boolean
    clientsId?: boolean
  }, ExtArgs["result"]["zdconnector"]>

  export type zdconnectorSelectScalar = {
    id?: boolean
    name?: boolean
    host?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    suncoAppId?: boolean
    suncoAppKey?: boolean
    suncoAppSecret?: boolean
    zdAPIToken?: boolean
    resource?: boolean
    clientsId?: boolean
  }

  export type zdconnectorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "host" | "createdAt" | "updatedAt" | "suncoAppId" | "suncoAppKey" | "suncoAppSecret" | "zdAPIToken" | "resource" | "clientsId", ExtArgs["result"]["zdconnector"]>

  export type $zdconnectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "zdconnector"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      host: string
      createdAt: Date
      updatedAt: Date
      suncoAppId: string
      suncoAppKey: string
      suncoAppSecret: string
      zdAPIToken: string
      resource: string | null
      clientsId: number | null
    }, ExtArgs["result"]["zdconnector"]>
    composites: {}
  }

  type zdconnectorGetPayload<S extends boolean | null | undefined | zdconnectorDefaultArgs> = $Result.GetResult<Prisma.$zdconnectorPayload, S>

  type zdconnectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<zdconnectorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZdconnectorCountAggregateInputType | true
    }

  export interface zdconnectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['zdconnector'], meta: { name: 'zdconnector' } }
    /**
     * Find zero or one Zdconnector that matches the filter.
     * @param {zdconnectorFindUniqueArgs} args - Arguments to find a Zdconnector
     * @example
     * // Get one Zdconnector
     * const zdconnector = await prisma.zdconnector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends zdconnectorFindUniqueArgs>(args: SelectSubset<T, zdconnectorFindUniqueArgs<ExtArgs>>): Prisma__zdconnectorClient<$Result.GetResult<Prisma.$zdconnectorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zdconnector that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {zdconnectorFindUniqueOrThrowArgs} args - Arguments to find a Zdconnector
     * @example
     * // Get one Zdconnector
     * const zdconnector = await prisma.zdconnector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends zdconnectorFindUniqueOrThrowArgs>(args: SelectSubset<T, zdconnectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__zdconnectorClient<$Result.GetResult<Prisma.$zdconnectorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zdconnector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zdconnectorFindFirstArgs} args - Arguments to find a Zdconnector
     * @example
     * // Get one Zdconnector
     * const zdconnector = await prisma.zdconnector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends zdconnectorFindFirstArgs>(args?: SelectSubset<T, zdconnectorFindFirstArgs<ExtArgs>>): Prisma__zdconnectorClient<$Result.GetResult<Prisma.$zdconnectorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zdconnector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zdconnectorFindFirstOrThrowArgs} args - Arguments to find a Zdconnector
     * @example
     * // Get one Zdconnector
     * const zdconnector = await prisma.zdconnector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends zdconnectorFindFirstOrThrowArgs>(args?: SelectSubset<T, zdconnectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__zdconnectorClient<$Result.GetResult<Prisma.$zdconnectorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zdconnectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zdconnectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zdconnectors
     * const zdconnectors = await prisma.zdconnector.findMany()
     * 
     * // Get first 10 Zdconnectors
     * const zdconnectors = await prisma.zdconnector.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zdconnectorWithIdOnly = await prisma.zdconnector.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends zdconnectorFindManyArgs>(args?: SelectSubset<T, zdconnectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zdconnectorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zdconnector.
     * @param {zdconnectorCreateArgs} args - Arguments to create a Zdconnector.
     * @example
     * // Create one Zdconnector
     * const Zdconnector = await prisma.zdconnector.create({
     *   data: {
     *     // ... data to create a Zdconnector
     *   }
     * })
     * 
     */
    create<T extends zdconnectorCreateArgs>(args: SelectSubset<T, zdconnectorCreateArgs<ExtArgs>>): Prisma__zdconnectorClient<$Result.GetResult<Prisma.$zdconnectorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zdconnectors.
     * @param {zdconnectorCreateManyArgs} args - Arguments to create many Zdconnectors.
     * @example
     * // Create many Zdconnectors
     * const zdconnector = await prisma.zdconnector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends zdconnectorCreateManyArgs>(args?: SelectSubset<T, zdconnectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zdconnectors and returns the data saved in the database.
     * @param {zdconnectorCreateManyAndReturnArgs} args - Arguments to create many Zdconnectors.
     * @example
     * // Create many Zdconnectors
     * const zdconnector = await prisma.zdconnector.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zdconnectors and only return the `id`
     * const zdconnectorWithIdOnly = await prisma.zdconnector.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends zdconnectorCreateManyAndReturnArgs>(args?: SelectSubset<T, zdconnectorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zdconnectorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zdconnector.
     * @param {zdconnectorDeleteArgs} args - Arguments to delete one Zdconnector.
     * @example
     * // Delete one Zdconnector
     * const Zdconnector = await prisma.zdconnector.delete({
     *   where: {
     *     // ... filter to delete one Zdconnector
     *   }
     * })
     * 
     */
    delete<T extends zdconnectorDeleteArgs>(args: SelectSubset<T, zdconnectorDeleteArgs<ExtArgs>>): Prisma__zdconnectorClient<$Result.GetResult<Prisma.$zdconnectorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zdconnector.
     * @param {zdconnectorUpdateArgs} args - Arguments to update one Zdconnector.
     * @example
     * // Update one Zdconnector
     * const zdconnector = await prisma.zdconnector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends zdconnectorUpdateArgs>(args: SelectSubset<T, zdconnectorUpdateArgs<ExtArgs>>): Prisma__zdconnectorClient<$Result.GetResult<Prisma.$zdconnectorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zdconnectors.
     * @param {zdconnectorDeleteManyArgs} args - Arguments to filter Zdconnectors to delete.
     * @example
     * // Delete a few Zdconnectors
     * const { count } = await prisma.zdconnector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends zdconnectorDeleteManyArgs>(args?: SelectSubset<T, zdconnectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zdconnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zdconnectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zdconnectors
     * const zdconnector = await prisma.zdconnector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends zdconnectorUpdateManyArgs>(args: SelectSubset<T, zdconnectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zdconnectors and returns the data updated in the database.
     * @param {zdconnectorUpdateManyAndReturnArgs} args - Arguments to update many Zdconnectors.
     * @example
     * // Update many Zdconnectors
     * const zdconnector = await prisma.zdconnector.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zdconnectors and only return the `id`
     * const zdconnectorWithIdOnly = await prisma.zdconnector.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends zdconnectorUpdateManyAndReturnArgs>(args: SelectSubset<T, zdconnectorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zdconnectorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zdconnector.
     * @param {zdconnectorUpsertArgs} args - Arguments to update or create a Zdconnector.
     * @example
     * // Update or create a Zdconnector
     * const zdconnector = await prisma.zdconnector.upsert({
     *   create: {
     *     // ... data to create a Zdconnector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zdconnector we want to update
     *   }
     * })
     */
    upsert<T extends zdconnectorUpsertArgs>(args: SelectSubset<T, zdconnectorUpsertArgs<ExtArgs>>): Prisma__zdconnectorClient<$Result.GetResult<Prisma.$zdconnectorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zdconnectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zdconnectorCountArgs} args - Arguments to filter Zdconnectors to count.
     * @example
     * // Count the number of Zdconnectors
     * const count = await prisma.zdconnector.count({
     *   where: {
     *     // ... the filter for the Zdconnectors we want to count
     *   }
     * })
    **/
    count<T extends zdconnectorCountArgs>(
      args?: Subset<T, zdconnectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZdconnectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zdconnector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZdconnectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZdconnectorAggregateArgs>(args: Subset<T, ZdconnectorAggregateArgs>): Prisma.PrismaPromise<GetZdconnectorAggregateType<T>>

    /**
     * Group by Zdconnector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zdconnectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends zdconnectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: zdconnectorGroupByArgs['orderBy'] }
        : { orderBy?: zdconnectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, zdconnectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZdconnectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the zdconnector model
   */
  readonly fields: zdconnectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for zdconnector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__zdconnectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the zdconnector model
   */
  interface zdconnectorFieldRefs {
    readonly id: FieldRef<"zdconnector", 'Int'>
    readonly name: FieldRef<"zdconnector", 'String'>
    readonly host: FieldRef<"zdconnector", 'String'>
    readonly createdAt: FieldRef<"zdconnector", 'DateTime'>
    readonly updatedAt: FieldRef<"zdconnector", 'DateTime'>
    readonly suncoAppId: FieldRef<"zdconnector", 'String'>
    readonly suncoAppKey: FieldRef<"zdconnector", 'String'>
    readonly suncoAppSecret: FieldRef<"zdconnector", 'String'>
    readonly zdAPIToken: FieldRef<"zdconnector", 'String'>
    readonly resource: FieldRef<"zdconnector", 'String'>
    readonly clientsId: FieldRef<"zdconnector", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * zdconnector findUnique
   */
  export type zdconnectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
    /**
     * Filter, which zdconnector to fetch.
     */
    where: zdconnectorWhereUniqueInput
  }

  /**
   * zdconnector findUniqueOrThrow
   */
  export type zdconnectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
    /**
     * Filter, which zdconnector to fetch.
     */
    where: zdconnectorWhereUniqueInput
  }

  /**
   * zdconnector findFirst
   */
  export type zdconnectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
    /**
     * Filter, which zdconnector to fetch.
     */
    where?: zdconnectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zdconnectors to fetch.
     */
    orderBy?: zdconnectorOrderByWithRelationInput | zdconnectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zdconnectors.
     */
    cursor?: zdconnectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zdconnectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zdconnectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zdconnectors.
     */
    distinct?: ZdconnectorScalarFieldEnum | ZdconnectorScalarFieldEnum[]
  }

  /**
   * zdconnector findFirstOrThrow
   */
  export type zdconnectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
    /**
     * Filter, which zdconnector to fetch.
     */
    where?: zdconnectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zdconnectors to fetch.
     */
    orderBy?: zdconnectorOrderByWithRelationInput | zdconnectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zdconnectors.
     */
    cursor?: zdconnectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zdconnectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zdconnectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zdconnectors.
     */
    distinct?: ZdconnectorScalarFieldEnum | ZdconnectorScalarFieldEnum[]
  }

  /**
   * zdconnector findMany
   */
  export type zdconnectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
    /**
     * Filter, which zdconnectors to fetch.
     */
    where?: zdconnectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zdconnectors to fetch.
     */
    orderBy?: zdconnectorOrderByWithRelationInput | zdconnectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing zdconnectors.
     */
    cursor?: zdconnectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zdconnectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zdconnectors.
     */
    skip?: number
    distinct?: ZdconnectorScalarFieldEnum | ZdconnectorScalarFieldEnum[]
  }

  /**
   * zdconnector create
   */
  export type zdconnectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
    /**
     * The data needed to create a zdconnector.
     */
    data: XOR<zdconnectorCreateInput, zdconnectorUncheckedCreateInput>
  }

  /**
   * zdconnector createMany
   */
  export type zdconnectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many zdconnectors.
     */
    data: zdconnectorCreateManyInput | zdconnectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zdconnector createManyAndReturn
   */
  export type zdconnectorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
    /**
     * The data used to create many zdconnectors.
     */
    data: zdconnectorCreateManyInput | zdconnectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zdconnector update
   */
  export type zdconnectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
    /**
     * The data needed to update a zdconnector.
     */
    data: XOR<zdconnectorUpdateInput, zdconnectorUncheckedUpdateInput>
    /**
     * Choose, which zdconnector to update.
     */
    where: zdconnectorWhereUniqueInput
  }

  /**
   * zdconnector updateMany
   */
  export type zdconnectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update zdconnectors.
     */
    data: XOR<zdconnectorUpdateManyMutationInput, zdconnectorUncheckedUpdateManyInput>
    /**
     * Filter which zdconnectors to update
     */
    where?: zdconnectorWhereInput
    /**
     * Limit how many zdconnectors to update.
     */
    limit?: number
  }

  /**
   * zdconnector updateManyAndReturn
   */
  export type zdconnectorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
    /**
     * The data used to update zdconnectors.
     */
    data: XOR<zdconnectorUpdateManyMutationInput, zdconnectorUncheckedUpdateManyInput>
    /**
     * Filter which zdconnectors to update
     */
    where?: zdconnectorWhereInput
    /**
     * Limit how many zdconnectors to update.
     */
    limit?: number
  }

  /**
   * zdconnector upsert
   */
  export type zdconnectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
    /**
     * The filter to search for the zdconnector to update in case it exists.
     */
    where: zdconnectorWhereUniqueInput
    /**
     * In case the zdconnector found by the `where` argument doesn't exist, create a new zdconnector with this data.
     */
    create: XOR<zdconnectorCreateInput, zdconnectorUncheckedCreateInput>
    /**
     * In case the zdconnector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<zdconnectorUpdateInput, zdconnectorUncheckedUpdateInput>
  }

  /**
   * zdconnector delete
   */
  export type zdconnectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
    /**
     * Filter which zdconnector to delete.
     */
    where: zdconnectorWhereUniqueInput
  }

  /**
   * zdconnector deleteMany
   */
  export type zdconnectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zdconnectors to delete
     */
    where?: zdconnectorWhereInput
    /**
     * Limit how many zdconnectors to delete.
     */
    limit?: number
  }

  /**
   * zdconnector without action
   */
  export type zdconnectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zdconnector
     */
    select?: zdconnectorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zdconnector
     */
    omit?: zdconnectorOmit<ExtArgs> | null
  }


  /**
   * Model omnicrm
   */

  export type AggregateOmnicrm = {
    _count: OmnicrmCountAggregateOutputType | null
    _avg: OmnicrmAvgAggregateOutputType | null
    _sum: OmnicrmSumAggregateOutputType | null
    _min: OmnicrmMinAggregateOutputType | null
    _max: OmnicrmMaxAggregateOutputType | null
  }

  export type OmnicrmAvgAggregateOutputType = {
    id: number | null
  }

  export type OmnicrmSumAggregateOutputType = {
    id: number | null
  }

  export type OmnicrmMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    type: string | null
  }

  export type OmnicrmMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    type: string | null
  }

  export type OmnicrmCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    type: number
    _all: number
  }


  export type OmnicrmAvgAggregateInputType = {
    id?: true
  }

  export type OmnicrmSumAggregateInputType = {
    id?: true
  }

  export type OmnicrmMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    type?: true
  }

  export type OmnicrmMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    type?: true
  }

  export type OmnicrmCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    type?: true
    _all?: true
  }

  export type OmnicrmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which omnicrm to aggregate.
     */
    where?: omnicrmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnicrms to fetch.
     */
    orderBy?: omnicrmOrderByWithRelationInput | omnicrmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: omnicrmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnicrms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnicrms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned omnicrms
    **/
    _count?: true | OmnicrmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OmnicrmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OmnicrmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OmnicrmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OmnicrmMaxAggregateInputType
  }

  export type GetOmnicrmAggregateType<T extends OmnicrmAggregateArgs> = {
        [P in keyof T & keyof AggregateOmnicrm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOmnicrm[P]>
      : GetScalarType<T[P], AggregateOmnicrm[P]>
  }




  export type omnicrmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: omnicrmWhereInput
    orderBy?: omnicrmOrderByWithAggregationInput | omnicrmOrderByWithAggregationInput[]
    by: OmnicrmScalarFieldEnum[] | OmnicrmScalarFieldEnum
    having?: omnicrmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OmnicrmCountAggregateInputType | true
    _avg?: OmnicrmAvgAggregateInputType
    _sum?: OmnicrmSumAggregateInputType
    _min?: OmnicrmMinAggregateInputType
    _max?: OmnicrmMaxAggregateInputType
  }

  export type OmnicrmGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string | null
    type: string | null
    _count: OmnicrmCountAggregateOutputType | null
    _avg: OmnicrmAvgAggregateOutputType | null
    _sum: OmnicrmSumAggregateOutputType | null
    _min: OmnicrmMinAggregateOutputType | null
    _max: OmnicrmMaxAggregateOutputType | null
  }

  type GetOmnicrmGroupByPayload<T extends omnicrmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OmnicrmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OmnicrmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OmnicrmGroupByOutputType[P]>
            : GetScalarType<T[P], OmnicrmGroupByOutputType[P]>
        }
      >
    >


  export type omnicrmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    type?: boolean
  }, ExtArgs["result"]["omnicrm"]>

  export type omnicrmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    type?: boolean
  }, ExtArgs["result"]["omnicrm"]>

  export type omnicrmSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    type?: boolean
  }, ExtArgs["result"]["omnicrm"]>

  export type omnicrmSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    type?: boolean
  }

  export type omnicrmOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "type", ExtArgs["result"]["omnicrm"]>

  export type $omnicrmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "omnicrm"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      name: string | null
      type: string | null
    }, ExtArgs["result"]["omnicrm"]>
    composites: {}
  }

  type omnicrmGetPayload<S extends boolean | null | undefined | omnicrmDefaultArgs> = $Result.GetResult<Prisma.$omnicrmPayload, S>

  type omnicrmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<omnicrmFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OmnicrmCountAggregateInputType | true
    }

  export interface omnicrmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['omnicrm'], meta: { name: 'omnicrm' } }
    /**
     * Find zero or one Omnicrm that matches the filter.
     * @param {omnicrmFindUniqueArgs} args - Arguments to find a Omnicrm
     * @example
     * // Get one Omnicrm
     * const omnicrm = await prisma.omnicrm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends omnicrmFindUniqueArgs>(args: SelectSubset<T, omnicrmFindUniqueArgs<ExtArgs>>): Prisma__omnicrmClient<$Result.GetResult<Prisma.$omnicrmPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Omnicrm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {omnicrmFindUniqueOrThrowArgs} args - Arguments to find a Omnicrm
     * @example
     * // Get one Omnicrm
     * const omnicrm = await prisma.omnicrm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends omnicrmFindUniqueOrThrowArgs>(args: SelectSubset<T, omnicrmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__omnicrmClient<$Result.GetResult<Prisma.$omnicrmPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Omnicrm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnicrmFindFirstArgs} args - Arguments to find a Omnicrm
     * @example
     * // Get one Omnicrm
     * const omnicrm = await prisma.omnicrm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends omnicrmFindFirstArgs>(args?: SelectSubset<T, omnicrmFindFirstArgs<ExtArgs>>): Prisma__omnicrmClient<$Result.GetResult<Prisma.$omnicrmPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Omnicrm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnicrmFindFirstOrThrowArgs} args - Arguments to find a Omnicrm
     * @example
     * // Get one Omnicrm
     * const omnicrm = await prisma.omnicrm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends omnicrmFindFirstOrThrowArgs>(args?: SelectSubset<T, omnicrmFindFirstOrThrowArgs<ExtArgs>>): Prisma__omnicrmClient<$Result.GetResult<Prisma.$omnicrmPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Omnicrms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnicrmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Omnicrms
     * const omnicrms = await prisma.omnicrm.findMany()
     * 
     * // Get first 10 Omnicrms
     * const omnicrms = await prisma.omnicrm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const omnicrmWithIdOnly = await prisma.omnicrm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends omnicrmFindManyArgs>(args?: SelectSubset<T, omnicrmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnicrmPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Omnicrm.
     * @param {omnicrmCreateArgs} args - Arguments to create a Omnicrm.
     * @example
     * // Create one Omnicrm
     * const Omnicrm = await prisma.omnicrm.create({
     *   data: {
     *     // ... data to create a Omnicrm
     *   }
     * })
     * 
     */
    create<T extends omnicrmCreateArgs>(args: SelectSubset<T, omnicrmCreateArgs<ExtArgs>>): Prisma__omnicrmClient<$Result.GetResult<Prisma.$omnicrmPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Omnicrms.
     * @param {omnicrmCreateManyArgs} args - Arguments to create many Omnicrms.
     * @example
     * // Create many Omnicrms
     * const omnicrm = await prisma.omnicrm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends omnicrmCreateManyArgs>(args?: SelectSubset<T, omnicrmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Omnicrms and returns the data saved in the database.
     * @param {omnicrmCreateManyAndReturnArgs} args - Arguments to create many Omnicrms.
     * @example
     * // Create many Omnicrms
     * const omnicrm = await prisma.omnicrm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Omnicrms and only return the `id`
     * const omnicrmWithIdOnly = await prisma.omnicrm.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends omnicrmCreateManyAndReturnArgs>(args?: SelectSubset<T, omnicrmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnicrmPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Omnicrm.
     * @param {omnicrmDeleteArgs} args - Arguments to delete one Omnicrm.
     * @example
     * // Delete one Omnicrm
     * const Omnicrm = await prisma.omnicrm.delete({
     *   where: {
     *     // ... filter to delete one Omnicrm
     *   }
     * })
     * 
     */
    delete<T extends omnicrmDeleteArgs>(args: SelectSubset<T, omnicrmDeleteArgs<ExtArgs>>): Prisma__omnicrmClient<$Result.GetResult<Prisma.$omnicrmPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Omnicrm.
     * @param {omnicrmUpdateArgs} args - Arguments to update one Omnicrm.
     * @example
     * // Update one Omnicrm
     * const omnicrm = await prisma.omnicrm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends omnicrmUpdateArgs>(args: SelectSubset<T, omnicrmUpdateArgs<ExtArgs>>): Prisma__omnicrmClient<$Result.GetResult<Prisma.$omnicrmPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Omnicrms.
     * @param {omnicrmDeleteManyArgs} args - Arguments to filter Omnicrms to delete.
     * @example
     * // Delete a few Omnicrms
     * const { count } = await prisma.omnicrm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends omnicrmDeleteManyArgs>(args?: SelectSubset<T, omnicrmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Omnicrms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnicrmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Omnicrms
     * const omnicrm = await prisma.omnicrm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends omnicrmUpdateManyArgs>(args: SelectSubset<T, omnicrmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Omnicrms and returns the data updated in the database.
     * @param {omnicrmUpdateManyAndReturnArgs} args - Arguments to update many Omnicrms.
     * @example
     * // Update many Omnicrms
     * const omnicrm = await prisma.omnicrm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Omnicrms and only return the `id`
     * const omnicrmWithIdOnly = await prisma.omnicrm.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends omnicrmUpdateManyAndReturnArgs>(args: SelectSubset<T, omnicrmUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$omnicrmPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Omnicrm.
     * @param {omnicrmUpsertArgs} args - Arguments to update or create a Omnicrm.
     * @example
     * // Update or create a Omnicrm
     * const omnicrm = await prisma.omnicrm.upsert({
     *   create: {
     *     // ... data to create a Omnicrm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Omnicrm we want to update
     *   }
     * })
     */
    upsert<T extends omnicrmUpsertArgs>(args: SelectSubset<T, omnicrmUpsertArgs<ExtArgs>>): Prisma__omnicrmClient<$Result.GetResult<Prisma.$omnicrmPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Omnicrms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnicrmCountArgs} args - Arguments to filter Omnicrms to count.
     * @example
     * // Count the number of Omnicrms
     * const count = await prisma.omnicrm.count({
     *   where: {
     *     // ... the filter for the Omnicrms we want to count
     *   }
     * })
    **/
    count<T extends omnicrmCountArgs>(
      args?: Subset<T, omnicrmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OmnicrmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Omnicrm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OmnicrmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OmnicrmAggregateArgs>(args: Subset<T, OmnicrmAggregateArgs>): Prisma.PrismaPromise<GetOmnicrmAggregateType<T>>

    /**
     * Group by Omnicrm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {omnicrmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends omnicrmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: omnicrmGroupByArgs['orderBy'] }
        : { orderBy?: omnicrmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, omnicrmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOmnicrmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the omnicrm model
   */
  readonly fields: omnicrmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for omnicrm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__omnicrmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the omnicrm model
   */
  interface omnicrmFieldRefs {
    readonly id: FieldRef<"omnicrm", 'Int'>
    readonly createdAt: FieldRef<"omnicrm", 'DateTime'>
    readonly updatedAt: FieldRef<"omnicrm", 'DateTime'>
    readonly name: FieldRef<"omnicrm", 'String'>
    readonly type: FieldRef<"omnicrm", 'String'>
  }
    

  // Custom InputTypes
  /**
   * omnicrm findUnique
   */
  export type omnicrmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
    /**
     * Filter, which omnicrm to fetch.
     */
    where: omnicrmWhereUniqueInput
  }

  /**
   * omnicrm findUniqueOrThrow
   */
  export type omnicrmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
    /**
     * Filter, which omnicrm to fetch.
     */
    where: omnicrmWhereUniqueInput
  }

  /**
   * omnicrm findFirst
   */
  export type omnicrmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
    /**
     * Filter, which omnicrm to fetch.
     */
    where?: omnicrmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnicrms to fetch.
     */
    orderBy?: omnicrmOrderByWithRelationInput | omnicrmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for omnicrms.
     */
    cursor?: omnicrmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnicrms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnicrms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of omnicrms.
     */
    distinct?: OmnicrmScalarFieldEnum | OmnicrmScalarFieldEnum[]
  }

  /**
   * omnicrm findFirstOrThrow
   */
  export type omnicrmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
    /**
     * Filter, which omnicrm to fetch.
     */
    where?: omnicrmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnicrms to fetch.
     */
    orderBy?: omnicrmOrderByWithRelationInput | omnicrmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for omnicrms.
     */
    cursor?: omnicrmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnicrms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnicrms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of omnicrms.
     */
    distinct?: OmnicrmScalarFieldEnum | OmnicrmScalarFieldEnum[]
  }

  /**
   * omnicrm findMany
   */
  export type omnicrmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
    /**
     * Filter, which omnicrms to fetch.
     */
    where?: omnicrmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of omnicrms to fetch.
     */
    orderBy?: omnicrmOrderByWithRelationInput | omnicrmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing omnicrms.
     */
    cursor?: omnicrmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` omnicrms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` omnicrms.
     */
    skip?: number
    distinct?: OmnicrmScalarFieldEnum | OmnicrmScalarFieldEnum[]
  }

  /**
   * omnicrm create
   */
  export type omnicrmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
    /**
     * The data needed to create a omnicrm.
     */
    data?: XOR<omnicrmCreateInput, omnicrmUncheckedCreateInput>
  }

  /**
   * omnicrm createMany
   */
  export type omnicrmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many omnicrms.
     */
    data: omnicrmCreateManyInput | omnicrmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * omnicrm createManyAndReturn
   */
  export type omnicrmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
    /**
     * The data used to create many omnicrms.
     */
    data: omnicrmCreateManyInput | omnicrmCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * omnicrm update
   */
  export type omnicrmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
    /**
     * The data needed to update a omnicrm.
     */
    data: XOR<omnicrmUpdateInput, omnicrmUncheckedUpdateInput>
    /**
     * Choose, which omnicrm to update.
     */
    where: omnicrmWhereUniqueInput
  }

  /**
   * omnicrm updateMany
   */
  export type omnicrmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update omnicrms.
     */
    data: XOR<omnicrmUpdateManyMutationInput, omnicrmUncheckedUpdateManyInput>
    /**
     * Filter which omnicrms to update
     */
    where?: omnicrmWhereInput
    /**
     * Limit how many omnicrms to update.
     */
    limit?: number
  }

  /**
   * omnicrm updateManyAndReturn
   */
  export type omnicrmUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
    /**
     * The data used to update omnicrms.
     */
    data: XOR<omnicrmUpdateManyMutationInput, omnicrmUncheckedUpdateManyInput>
    /**
     * Filter which omnicrms to update
     */
    where?: omnicrmWhereInput
    /**
     * Limit how many omnicrms to update.
     */
    limit?: number
  }

  /**
   * omnicrm upsert
   */
  export type omnicrmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
    /**
     * The filter to search for the omnicrm to update in case it exists.
     */
    where: omnicrmWhereUniqueInput
    /**
     * In case the omnicrm found by the `where` argument doesn't exist, create a new omnicrm with this data.
     */
    create: XOR<omnicrmCreateInput, omnicrmUncheckedCreateInput>
    /**
     * In case the omnicrm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<omnicrmUpdateInput, omnicrmUncheckedUpdateInput>
  }

  /**
   * omnicrm delete
   */
  export type omnicrmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
    /**
     * Filter which omnicrm to delete.
     */
    where: omnicrmWhereUniqueInput
  }

  /**
   * omnicrm deleteMany
   */
  export type omnicrmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which omnicrms to delete
     */
    where?: omnicrmWhereInput
    /**
     * Limit how many omnicrms to delete.
     */
    limit?: number
  }

  /**
   * omnicrm without action
   */
  export type omnicrmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the omnicrm
     */
    select?: omnicrmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the omnicrm
     */
    omit?: omnicrmOmit<ExtArgs> | null
  }


  /**
   * Model clients
   */

  export type AggregateClients = {
    _count: ClientsCountAggregateOutputType | null
    _avg: ClientsAvgAggregateOutputType | null
    _sum: ClientsSumAggregateOutputType | null
    _min: ClientsMinAggregateOutputType | null
    _max: ClientsMaxAggregateOutputType | null
  }

  export type ClientsAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientsSumAggregateOutputType = {
    id: number | null
  }

  export type ClientsMinAggregateOutputType = {
    id: number | null
    name: string | null
    origin_id: string | null
  }

  export type ClientsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    origin_id: string | null
  }

  export type ClientsCountAggregateOutputType = {
    id: number
    name: number
    origin_id: number
    _all: number
  }


  export type ClientsAvgAggregateInputType = {
    id?: true
  }

  export type ClientsSumAggregateInputType = {
    id?: true
  }

  export type ClientsMinAggregateInputType = {
    id?: true
    name?: true
    origin_id?: true
  }

  export type ClientsMaxAggregateInputType = {
    id?: true
    name?: true
    origin_id?: true
  }

  export type ClientsCountAggregateInputType = {
    id?: true
    name?: true
    origin_id?: true
    _all?: true
  }

  export type ClientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clients to aggregate.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clients
    **/
    _count?: true | ClientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientsMaxAggregateInputType
  }

  export type GetClientsAggregateType<T extends ClientsAggregateArgs> = {
        [P in keyof T & keyof AggregateClients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClients[P]>
      : GetScalarType<T[P], AggregateClients[P]>
  }




  export type clientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientsWhereInput
    orderBy?: clientsOrderByWithAggregationInput | clientsOrderByWithAggregationInput[]
    by: ClientsScalarFieldEnum[] | ClientsScalarFieldEnum
    having?: clientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientsCountAggregateInputType | true
    _avg?: ClientsAvgAggregateInputType
    _sum?: ClientsSumAggregateInputType
    _min?: ClientsMinAggregateInputType
    _max?: ClientsMaxAggregateInputType
  }

  export type ClientsGroupByOutputType = {
    id: number
    name: string
    origin_id: string | null
    _count: ClientsCountAggregateOutputType | null
    _avg: ClientsAvgAggregateOutputType | null
    _sum: ClientsSumAggregateOutputType | null
    _min: ClientsMinAggregateOutputType | null
    _max: ClientsMaxAggregateOutputType | null
  }

  type GetClientsGroupByPayload<T extends clientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientsGroupByOutputType[P]>
            : GetScalarType<T[P], ClientsGroupByOutputType[P]>
        }
      >
    >


  export type clientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    origin_id?: boolean
    channel?: boolean | clients$channelArgs<ExtArgs>
    integration?: boolean | clients$integrationArgs<ExtArgs>
    _count?: boolean | ClientsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clients"]>

  export type clientsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    origin_id?: boolean
  }, ExtArgs["result"]["clients"]>

  export type clientsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    origin_id?: boolean
  }, ExtArgs["result"]["clients"]>

  export type clientsSelectScalar = {
    id?: boolean
    name?: boolean
    origin_id?: boolean
  }

  export type clientsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "origin_id", ExtArgs["result"]["clients"]>
  export type clientsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | clients$channelArgs<ExtArgs>
    integration?: boolean | clients$integrationArgs<ExtArgs>
    _count?: boolean | ClientsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clientsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type clientsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $clientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clients"
    objects: {
      channel: Prisma.$channelPayload<ExtArgs>[]
      integration: Prisma.$integrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      origin_id: string | null
    }, ExtArgs["result"]["clients"]>
    composites: {}
  }

  type clientsGetPayload<S extends boolean | null | undefined | clientsDefaultArgs> = $Result.GetResult<Prisma.$clientsPayload, S>

  type clientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clientsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientsCountAggregateInputType | true
    }

  export interface clientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clients'], meta: { name: 'clients' } }
    /**
     * Find zero or one Clients that matches the filter.
     * @param {clientsFindUniqueArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientsFindUniqueArgs>(args: SelectSubset<T, clientsFindUniqueArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clients that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clientsFindUniqueOrThrowArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientsFindUniqueOrThrowArgs>(args: SelectSubset<T, clientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsFindFirstArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientsFindFirstArgs>(args?: SelectSubset<T, clientsFindFirstArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsFindFirstOrThrowArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientsFindFirstOrThrowArgs>(args?: SelectSubset<T, clientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.clients.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.clients.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientsWithIdOnly = await prisma.clients.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clientsFindManyArgs>(args?: SelectSubset<T, clientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clients.
     * @param {clientsCreateArgs} args - Arguments to create a Clients.
     * @example
     * // Create one Clients
     * const Clients = await prisma.clients.create({
     *   data: {
     *     // ... data to create a Clients
     *   }
     * })
     * 
     */
    create<T extends clientsCreateArgs>(args: SelectSubset<T, clientsCreateArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {clientsCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const clients = await prisma.clients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientsCreateManyArgs>(args?: SelectSubset<T, clientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {clientsCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const clients = await prisma.clients.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientsWithIdOnly = await prisma.clients.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clientsCreateManyAndReturnArgs>(args?: SelectSubset<T, clientsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clients.
     * @param {clientsDeleteArgs} args - Arguments to delete one Clients.
     * @example
     * // Delete one Clients
     * const Clients = await prisma.clients.delete({
     *   where: {
     *     // ... filter to delete one Clients
     *   }
     * })
     * 
     */
    delete<T extends clientsDeleteArgs>(args: SelectSubset<T, clientsDeleteArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clients.
     * @param {clientsUpdateArgs} args - Arguments to update one Clients.
     * @example
     * // Update one Clients
     * const clients = await prisma.clients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientsUpdateArgs>(args: SelectSubset<T, clientsUpdateArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {clientsDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.clients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientsDeleteManyArgs>(args?: SelectSubset<T, clientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const clients = await prisma.clients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientsUpdateManyArgs>(args: SelectSubset<T, clientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {clientsUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const clients = await prisma.clients.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientsWithIdOnly = await prisma.clients.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clientsUpdateManyAndReturnArgs>(args: SelectSubset<T, clientsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clients.
     * @param {clientsUpsertArgs} args - Arguments to update or create a Clients.
     * @example
     * // Update or create a Clients
     * const clients = await prisma.clients.upsert({
     *   create: {
     *     // ... data to create a Clients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clients we want to update
     *   }
     * })
     */
    upsert<T extends clientsUpsertArgs>(args: SelectSubset<T, clientsUpsertArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.clients.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends clientsCountArgs>(
      args?: Subset<T, clientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientsAggregateArgs>(args: Subset<T, ClientsAggregateArgs>): Prisma.PrismaPromise<GetClientsAggregateType<T>>

    /**
     * Group by Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientsGroupByArgs['orderBy'] }
        : { orderBy?: clientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clients model
   */
  readonly fields: clientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends clients$channelArgs<ExtArgs> = {}>(args?: Subset<T, clients$channelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integration<T extends clients$integrationArgs<ExtArgs> = {}>(args?: Subset<T, clients$integrationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clients model
   */
  interface clientsFieldRefs {
    readonly id: FieldRef<"clients", 'Int'>
    readonly name: FieldRef<"clients", 'String'>
    readonly origin_id: FieldRef<"clients", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clients findUnique
   */
  export type clientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients findUniqueOrThrow
   */
  export type clientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients findFirst
   */
  export type clientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * clients findFirstOrThrow
   */
  export type clientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * clients findMany
   */
  export type clientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clients.
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * clients create
   */
  export type clientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * The data needed to create a clients.
     */
    data: XOR<clientsCreateInput, clientsUncheckedCreateInput>
  }

  /**
   * clients createMany
   */
  export type clientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clients.
     */
    data: clientsCreateManyInput | clientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clients createManyAndReturn
   */
  export type clientsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * The data used to create many clients.
     */
    data: clientsCreateManyInput | clientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clients update
   */
  export type clientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * The data needed to update a clients.
     */
    data: XOR<clientsUpdateInput, clientsUncheckedUpdateInput>
    /**
     * Choose, which clients to update.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients updateMany
   */
  export type clientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clients.
     */
    data: XOR<clientsUpdateManyMutationInput, clientsUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     */
    where?: clientsWhereInput
    /**
     * Limit how many clients to update.
     */
    limit?: number
  }

  /**
   * clients updateManyAndReturn
   */
  export type clientsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * The data used to update clients.
     */
    data: XOR<clientsUpdateManyMutationInput, clientsUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     */
    where?: clientsWhereInput
    /**
     * Limit how many clients to update.
     */
    limit?: number
  }

  /**
   * clients upsert
   */
  export type clientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * The filter to search for the clients to update in case it exists.
     */
    where: clientsWhereUniqueInput
    /**
     * In case the clients found by the `where` argument doesn't exist, create a new clients with this data.
     */
    create: XOR<clientsCreateInput, clientsUncheckedCreateInput>
    /**
     * In case the clients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientsUpdateInput, clientsUncheckedUpdateInput>
  }

  /**
   * clients delete
   */
  export type clientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter which clients to delete.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients deleteMany
   */
  export type clientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clients to delete
     */
    where?: clientsWhereInput
    /**
     * Limit how many clients to delete.
     */
    limit?: number
  }

  /**
   * clients.channel
   */
  export type clients$channelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    where?: channelWhereInput
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    cursor?: channelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * clients.integration
   */
  export type clients$integrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
    where?: integrationWhereInput
    orderBy?: integrationOrderByWithRelationInput | integrationOrderByWithRelationInput[]
    cursor?: integrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * clients without action
   */
  export type clientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
  }


  /**
   * Model credent
   */

  export type AggregateCredent = {
    _count: CredentCountAggregateOutputType | null
    _avg: CredentAvgAggregateOutputType | null
    _sum: CredentSumAggregateOutputType | null
    _min: CredentMinAggregateOutputType | null
    _max: CredentMaxAggregateOutputType | null
  }

  export type CredentAvgAggregateOutputType = {
    id: number | null
    integrationId: number | null
  }

  export type CredentSumAggregateOutputType = {
    id: number | null
    integrationId: number | null
  }

  export type CredentMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    integrationId: number | null
  }

  export type CredentMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    integrationId: number | null
  }

  export type CredentCountAggregateOutputType = {
    id: number
    key: number
    value: number
    integrationId: number
    _all: number
  }


  export type CredentAvgAggregateInputType = {
    id?: true
    integrationId?: true
  }

  export type CredentSumAggregateInputType = {
    id?: true
    integrationId?: true
  }

  export type CredentMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    integrationId?: true
  }

  export type CredentMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    integrationId?: true
  }

  export type CredentCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    integrationId?: true
    _all?: true
  }

  export type CredentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credent to aggregate.
     */
    where?: credentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credents to fetch.
     */
    orderBy?: credentOrderByWithRelationInput | credentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: credentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned credents
    **/
    _count?: true | CredentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CredentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CredentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredentMaxAggregateInputType
  }

  export type GetCredentAggregateType<T extends CredentAggregateArgs> = {
        [P in keyof T & keyof AggregateCredent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredent[P]>
      : GetScalarType<T[P], AggregateCredent[P]>
  }




  export type credentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: credentWhereInput
    orderBy?: credentOrderByWithAggregationInput | credentOrderByWithAggregationInput[]
    by: CredentScalarFieldEnum[] | CredentScalarFieldEnum
    having?: credentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredentCountAggregateInputType | true
    _avg?: CredentAvgAggregateInputType
    _sum?: CredentSumAggregateInputType
    _min?: CredentMinAggregateInputType
    _max?: CredentMaxAggregateInputType
  }

  export type CredentGroupByOutputType = {
    id: number
    key: string | null
    value: string | null
    integrationId: number | null
    _count: CredentCountAggregateOutputType | null
    _avg: CredentAvgAggregateOutputType | null
    _sum: CredentSumAggregateOutputType | null
    _min: CredentMinAggregateOutputType | null
    _max: CredentMaxAggregateOutputType | null
  }

  type GetCredentGroupByPayload<T extends credentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CredentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredentGroupByOutputType[P]>
            : GetScalarType<T[P], CredentGroupByOutputType[P]>
        }
      >
    >


  export type credentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    integrationId?: boolean
    integration?: boolean | credent$integrationArgs<ExtArgs>
  }, ExtArgs["result"]["credent"]>

  export type credentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    integrationId?: boolean
    integration?: boolean | credent$integrationArgs<ExtArgs>
  }, ExtArgs["result"]["credent"]>

  export type credentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    integrationId?: boolean
    integration?: boolean | credent$integrationArgs<ExtArgs>
  }, ExtArgs["result"]["credent"]>

  export type credentSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    integrationId?: boolean
  }

  export type credentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "integrationId", ExtArgs["result"]["credent"]>
  export type credentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | credent$integrationArgs<ExtArgs>
  }
  export type credentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | credent$integrationArgs<ExtArgs>
  }
  export type credentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | credent$integrationArgs<ExtArgs>
  }

  export type $credentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "credent"
    objects: {
      integration: Prisma.$integrationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string | null
      value: string | null
      integrationId: number | null
    }, ExtArgs["result"]["credent"]>
    composites: {}
  }

  type credentGetPayload<S extends boolean | null | undefined | credentDefaultArgs> = $Result.GetResult<Prisma.$credentPayload, S>

  type credentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<credentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CredentCountAggregateInputType | true
    }

  export interface credentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['credent'], meta: { name: 'credent' } }
    /**
     * Find zero or one Credent that matches the filter.
     * @param {credentFindUniqueArgs} args - Arguments to find a Credent
     * @example
     * // Get one Credent
     * const credent = await prisma.credent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends credentFindUniqueArgs>(args: SelectSubset<T, credentFindUniqueArgs<ExtArgs>>): Prisma__credentClient<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {credentFindUniqueOrThrowArgs} args - Arguments to find a Credent
     * @example
     * // Get one Credent
     * const credent = await prisma.credent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends credentFindUniqueOrThrowArgs>(args: SelectSubset<T, credentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__credentClient<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credentFindFirstArgs} args - Arguments to find a Credent
     * @example
     * // Get one Credent
     * const credent = await prisma.credent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends credentFindFirstArgs>(args?: SelectSubset<T, credentFindFirstArgs<ExtArgs>>): Prisma__credentClient<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credentFindFirstOrThrowArgs} args - Arguments to find a Credent
     * @example
     * // Get one Credent
     * const credent = await prisma.credent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends credentFindFirstOrThrowArgs>(args?: SelectSubset<T, credentFindFirstOrThrowArgs<ExtArgs>>): Prisma__credentClient<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Credents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credents
     * const credents = await prisma.credent.findMany()
     * 
     * // Get first 10 Credents
     * const credents = await prisma.credent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credentWithIdOnly = await prisma.credent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends credentFindManyArgs>(args?: SelectSubset<T, credentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credent.
     * @param {credentCreateArgs} args - Arguments to create a Credent.
     * @example
     * // Create one Credent
     * const Credent = await prisma.credent.create({
     *   data: {
     *     // ... data to create a Credent
     *   }
     * })
     * 
     */
    create<T extends credentCreateArgs>(args: SelectSubset<T, credentCreateArgs<ExtArgs>>): Prisma__credentClient<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Credents.
     * @param {credentCreateManyArgs} args - Arguments to create many Credents.
     * @example
     * // Create many Credents
     * const credent = await prisma.credent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends credentCreateManyArgs>(args?: SelectSubset<T, credentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credents and returns the data saved in the database.
     * @param {credentCreateManyAndReturnArgs} args - Arguments to create many Credents.
     * @example
     * // Create many Credents
     * const credent = await prisma.credent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credents and only return the `id`
     * const credentWithIdOnly = await prisma.credent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends credentCreateManyAndReturnArgs>(args?: SelectSubset<T, credentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Credent.
     * @param {credentDeleteArgs} args - Arguments to delete one Credent.
     * @example
     * // Delete one Credent
     * const Credent = await prisma.credent.delete({
     *   where: {
     *     // ... filter to delete one Credent
     *   }
     * })
     * 
     */
    delete<T extends credentDeleteArgs>(args: SelectSubset<T, credentDeleteArgs<ExtArgs>>): Prisma__credentClient<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credent.
     * @param {credentUpdateArgs} args - Arguments to update one Credent.
     * @example
     * // Update one Credent
     * const credent = await prisma.credent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends credentUpdateArgs>(args: SelectSubset<T, credentUpdateArgs<ExtArgs>>): Prisma__credentClient<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Credents.
     * @param {credentDeleteManyArgs} args - Arguments to filter Credents to delete.
     * @example
     * // Delete a few Credents
     * const { count } = await prisma.credent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends credentDeleteManyArgs>(args?: SelectSubset<T, credentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credents
     * const credent = await prisma.credent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends credentUpdateManyArgs>(args: SelectSubset<T, credentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credents and returns the data updated in the database.
     * @param {credentUpdateManyAndReturnArgs} args - Arguments to update many Credents.
     * @example
     * // Update many Credents
     * const credent = await prisma.credent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Credents and only return the `id`
     * const credentWithIdOnly = await prisma.credent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends credentUpdateManyAndReturnArgs>(args: SelectSubset<T, credentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Credent.
     * @param {credentUpsertArgs} args - Arguments to update or create a Credent.
     * @example
     * // Update or create a Credent
     * const credent = await prisma.credent.upsert({
     *   create: {
     *     // ... data to create a Credent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credent we want to update
     *   }
     * })
     */
    upsert<T extends credentUpsertArgs>(args: SelectSubset<T, credentUpsertArgs<ExtArgs>>): Prisma__credentClient<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Credents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credentCountArgs} args - Arguments to filter Credents to count.
     * @example
     * // Count the number of Credents
     * const count = await prisma.credent.count({
     *   where: {
     *     // ... the filter for the Credents we want to count
     *   }
     * })
    **/
    count<T extends credentCountArgs>(
      args?: Subset<T, credentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredentAggregateArgs>(args: Subset<T, CredentAggregateArgs>): Prisma.PrismaPromise<GetCredentAggregateType<T>>

    /**
     * Group by Credent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends credentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: credentGroupByArgs['orderBy'] }
        : { orderBy?: credentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, credentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the credent model
   */
  readonly fields: credentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for credent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__credentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    integration<T extends credent$integrationArgs<ExtArgs> = {}>(args?: Subset<T, credent$integrationArgs<ExtArgs>>): Prisma__integrationClient<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the credent model
   */
  interface credentFieldRefs {
    readonly id: FieldRef<"credent", 'Int'>
    readonly key: FieldRef<"credent", 'String'>
    readonly value: FieldRef<"credent", 'String'>
    readonly integrationId: FieldRef<"credent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * credent findUnique
   */
  export type credentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentInclude<ExtArgs> | null
    /**
     * Filter, which credent to fetch.
     */
    where: credentWhereUniqueInput
  }

  /**
   * credent findUniqueOrThrow
   */
  export type credentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentInclude<ExtArgs> | null
    /**
     * Filter, which credent to fetch.
     */
    where: credentWhereUniqueInput
  }

  /**
   * credent findFirst
   */
  export type credentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentInclude<ExtArgs> | null
    /**
     * Filter, which credent to fetch.
     */
    where?: credentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credents to fetch.
     */
    orderBy?: credentOrderByWithRelationInput | credentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credents.
     */
    cursor?: credentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credents.
     */
    distinct?: CredentScalarFieldEnum | CredentScalarFieldEnum[]
  }

  /**
   * credent findFirstOrThrow
   */
  export type credentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentInclude<ExtArgs> | null
    /**
     * Filter, which credent to fetch.
     */
    where?: credentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credents to fetch.
     */
    orderBy?: credentOrderByWithRelationInput | credentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credents.
     */
    cursor?: credentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credents.
     */
    distinct?: CredentScalarFieldEnum | CredentScalarFieldEnum[]
  }

  /**
   * credent findMany
   */
  export type credentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentInclude<ExtArgs> | null
    /**
     * Filter, which credents to fetch.
     */
    where?: credentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credents to fetch.
     */
    orderBy?: credentOrderByWithRelationInput | credentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing credents.
     */
    cursor?: credentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credents.
     */
    skip?: number
    distinct?: CredentScalarFieldEnum | CredentScalarFieldEnum[]
  }

  /**
   * credent create
   */
  export type credentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentInclude<ExtArgs> | null
    /**
     * The data needed to create a credent.
     */
    data?: XOR<credentCreateInput, credentUncheckedCreateInput>
  }

  /**
   * credent createMany
   */
  export type credentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many credents.
     */
    data: credentCreateManyInput | credentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credent createManyAndReturn
   */
  export type credentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * The data used to create many credents.
     */
    data: credentCreateManyInput | credentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * credent update
   */
  export type credentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentInclude<ExtArgs> | null
    /**
     * The data needed to update a credent.
     */
    data: XOR<credentUpdateInput, credentUncheckedUpdateInput>
    /**
     * Choose, which credent to update.
     */
    where: credentWhereUniqueInput
  }

  /**
   * credent updateMany
   */
  export type credentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update credents.
     */
    data: XOR<credentUpdateManyMutationInput, credentUncheckedUpdateManyInput>
    /**
     * Filter which credents to update
     */
    where?: credentWhereInput
    /**
     * Limit how many credents to update.
     */
    limit?: number
  }

  /**
   * credent updateManyAndReturn
   */
  export type credentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * The data used to update credents.
     */
    data: XOR<credentUpdateManyMutationInput, credentUncheckedUpdateManyInput>
    /**
     * Filter which credents to update
     */
    where?: credentWhereInput
    /**
     * Limit how many credents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * credent upsert
   */
  export type credentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentInclude<ExtArgs> | null
    /**
     * The filter to search for the credent to update in case it exists.
     */
    where: credentWhereUniqueInput
    /**
     * In case the credent found by the `where` argument doesn't exist, create a new credent with this data.
     */
    create: XOR<credentCreateInput, credentUncheckedCreateInput>
    /**
     * In case the credent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<credentUpdateInput, credentUncheckedUpdateInput>
  }

  /**
   * credent delete
   */
  export type credentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentInclude<ExtArgs> | null
    /**
     * Filter which credent to delete.
     */
    where: credentWhereUniqueInput
  }

  /**
   * credent deleteMany
   */
  export type credentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credents to delete
     */
    where?: credentWhereInput
    /**
     * Limit how many credents to delete.
     */
    limit?: number
  }

  /**
   * credent.integration
   */
  export type credent$integrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
    where?: integrationWhereInput
  }

  /**
   * credent without action
   */
  export type credentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentInclude<ExtArgs> | null
  }


  /**
   * Model integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _avg: IntegrationAvgAggregateOutputType | null
    _sum: IntegrationSumAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationAvgAggregateOutputType = {
    id: number | null
    clientsId: number | null
  }

  export type IntegrationSumAggregateOutputType = {
    id: number | null
    clientsId: number | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: number | null
    name: string | null
    baseUrl: string | null
    f_chat: boolean | null
    f_review: boolean | null
    f_cancel: boolean | null
    f_rr: boolean | null
    status: string | null
    notes: string | null
    clientsId: number | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    baseUrl: string | null
    f_chat: boolean | null
    f_review: boolean | null
    f_cancel: boolean | null
    f_rr: boolean | null
    status: string | null
    notes: string | null
    clientsId: number | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    name: number
    baseUrl: number
    f_chat: number
    f_review: number
    f_cancel: number
    f_rr: number
    status: number
    notes: number
    clientsId: number
    _all: number
  }


  export type IntegrationAvgAggregateInputType = {
    id?: true
    clientsId?: true
  }

  export type IntegrationSumAggregateInputType = {
    id?: true
    clientsId?: true
  }

  export type IntegrationMinAggregateInputType = {
    id?: true
    name?: true
    baseUrl?: true
    f_chat?: true
    f_review?: true
    f_cancel?: true
    f_rr?: true
    status?: true
    notes?: true
    clientsId?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    name?: true
    baseUrl?: true
    f_chat?: true
    f_review?: true
    f_cancel?: true
    f_rr?: true
    status?: true
    notes?: true
    clientsId?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    name?: true
    baseUrl?: true
    f_chat?: true
    f_review?: true
    f_cancel?: true
    f_rr?: true
    status?: true
    notes?: true
    clientsId?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which integration to aggregate.
     */
    where?: integrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of integrations to fetch.
     */
    orderBy?: integrationOrderByWithRelationInput | integrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: integrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntegrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntegrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type integrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: integrationWhereInput
    orderBy?: integrationOrderByWithAggregationInput | integrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: integrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _avg?: IntegrationAvgAggregateInputType
    _sum?: IntegrationSumAggregateInputType
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: number
    name: string | null
    baseUrl: string | null
    f_chat: boolean | null
    f_review: boolean | null
    f_cancel: boolean | null
    f_rr: boolean | null
    status: string | null
    notes: string | null
    clientsId: number | null
    _count: IntegrationCountAggregateOutputType | null
    _avg: IntegrationAvgAggregateOutputType | null
    _sum: IntegrationSumAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends integrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type integrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    f_chat?: boolean
    f_review?: boolean
    f_cancel?: boolean
    f_rr?: boolean
    status?: boolean
    notes?: boolean
    clientsId?: boolean
    credent?: boolean | integration$credentArgs<ExtArgs>
    clients?: boolean | integration$clientsArgs<ExtArgs>
    _count?: boolean | IntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type integrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    f_chat?: boolean
    f_review?: boolean
    f_cancel?: boolean
    f_rr?: boolean
    status?: boolean
    notes?: boolean
    clientsId?: boolean
    clients?: boolean | integration$clientsArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type integrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    f_chat?: boolean
    f_review?: boolean
    f_cancel?: boolean
    f_rr?: boolean
    status?: boolean
    notes?: boolean
    clientsId?: boolean
    clients?: boolean | integration$clientsArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type integrationSelectScalar = {
    id?: boolean
    name?: boolean
    baseUrl?: boolean
    f_chat?: boolean
    f_review?: boolean
    f_cancel?: boolean
    f_rr?: boolean
    status?: boolean
    notes?: boolean
    clientsId?: boolean
  }

  export type integrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "baseUrl" | "f_chat" | "f_review" | "f_cancel" | "f_rr" | "status" | "notes" | "clientsId", ExtArgs["result"]["integration"]>
  export type integrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credent?: boolean | integration$credentArgs<ExtArgs>
    clients?: boolean | integration$clientsArgs<ExtArgs>
    _count?: boolean | IntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type integrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | integration$clientsArgs<ExtArgs>
  }
  export type integrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | integration$clientsArgs<ExtArgs>
  }

  export type $integrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "integration"
    objects: {
      credent: Prisma.$credentPayload<ExtArgs>[]
      clients: Prisma.$clientsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      baseUrl: string | null
      f_chat: boolean | null
      f_review: boolean | null
      f_cancel: boolean | null
      f_rr: boolean | null
      status: string | null
      notes: string | null
      clientsId: number | null
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type integrationGetPayload<S extends boolean | null | undefined | integrationDefaultArgs> = $Result.GetResult<Prisma.$integrationPayload, S>

  type integrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<integrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface integrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['integration'], meta: { name: 'integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {integrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends integrationFindUniqueArgs>(args: SelectSubset<T, integrationFindUniqueArgs<ExtArgs>>): Prisma__integrationClient<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {integrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends integrationFindUniqueOrThrowArgs>(args: SelectSubset<T, integrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__integrationClient<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends integrationFindFirstArgs>(args?: SelectSubset<T, integrationFindFirstArgs<ExtArgs>>): Prisma__integrationClient<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends integrationFindFirstOrThrowArgs>(args?: SelectSubset<T, integrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__integrationClient<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends integrationFindManyArgs>(args?: SelectSubset<T, integrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Integration.
     * @param {integrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends integrationCreateArgs>(args: SelectSubset<T, integrationCreateArgs<ExtArgs>>): Prisma__integrationClient<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Integrations.
     * @param {integrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends integrationCreateManyArgs>(args?: SelectSubset<T, integrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {integrationCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends integrationCreateManyAndReturnArgs>(args?: SelectSubset<T, integrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Integration.
     * @param {integrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends integrationDeleteArgs>(args: SelectSubset<T, integrationDeleteArgs<ExtArgs>>): Prisma__integrationClient<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Integration.
     * @param {integrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends integrationUpdateArgs>(args: SelectSubset<T, integrationUpdateArgs<ExtArgs>>): Prisma__integrationClient<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Integrations.
     * @param {integrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends integrationDeleteManyArgs>(args?: SelectSubset<T, integrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends integrationUpdateManyArgs>(args: SelectSubset<T, integrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations and returns the data updated in the database.
     * @param {integrationUpdateManyAndReturnArgs} args - Arguments to update many Integrations.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends integrationUpdateManyAndReturnArgs>(args: SelectSubset<T, integrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Integration.
     * @param {integrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends integrationUpsertArgs>(args: SelectSubset<T, integrationUpsertArgs<ExtArgs>>): Prisma__integrationClient<$Result.GetResult<Prisma.$integrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends integrationCountArgs>(
      args?: Subset<T, integrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends integrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: integrationGroupByArgs['orderBy'] }
        : { orderBy?: integrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, integrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the integration model
   */
  readonly fields: integrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__integrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credent<T extends integration$credentArgs<ExtArgs> = {}>(args?: Subset<T, integration$credentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clients<T extends integration$clientsArgs<ExtArgs> = {}>(args?: Subset<T, integration$clientsArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the integration model
   */
  interface integrationFieldRefs {
    readonly id: FieldRef<"integration", 'Int'>
    readonly name: FieldRef<"integration", 'String'>
    readonly baseUrl: FieldRef<"integration", 'String'>
    readonly f_chat: FieldRef<"integration", 'Boolean'>
    readonly f_review: FieldRef<"integration", 'Boolean'>
    readonly f_cancel: FieldRef<"integration", 'Boolean'>
    readonly f_rr: FieldRef<"integration", 'Boolean'>
    readonly status: FieldRef<"integration", 'String'>
    readonly notes: FieldRef<"integration", 'String'>
    readonly clientsId: FieldRef<"integration", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * integration findUnique
   */
  export type integrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
    /**
     * Filter, which integration to fetch.
     */
    where: integrationWhereUniqueInput
  }

  /**
   * integration findUniqueOrThrow
   */
  export type integrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
    /**
     * Filter, which integration to fetch.
     */
    where: integrationWhereUniqueInput
  }

  /**
   * integration findFirst
   */
  export type integrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
    /**
     * Filter, which integration to fetch.
     */
    where?: integrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of integrations to fetch.
     */
    orderBy?: integrationOrderByWithRelationInput | integrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for integrations.
     */
    cursor?: integrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * integration findFirstOrThrow
   */
  export type integrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
    /**
     * Filter, which integration to fetch.
     */
    where?: integrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of integrations to fetch.
     */
    orderBy?: integrationOrderByWithRelationInput | integrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for integrations.
     */
    cursor?: integrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * integration findMany
   */
  export type integrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
    /**
     * Filter, which integrations to fetch.
     */
    where?: integrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of integrations to fetch.
     */
    orderBy?: integrationOrderByWithRelationInput | integrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing integrations.
     */
    cursor?: integrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * integration create
   */
  export type integrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
    /**
     * The data needed to create a integration.
     */
    data?: XOR<integrationCreateInput, integrationUncheckedCreateInput>
  }

  /**
   * integration createMany
   */
  export type integrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many integrations.
     */
    data: integrationCreateManyInput | integrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * integration createManyAndReturn
   */
  export type integrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * The data used to create many integrations.
     */
    data: integrationCreateManyInput | integrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * integration update
   */
  export type integrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
    /**
     * The data needed to update a integration.
     */
    data: XOR<integrationUpdateInput, integrationUncheckedUpdateInput>
    /**
     * Choose, which integration to update.
     */
    where: integrationWhereUniqueInput
  }

  /**
   * integration updateMany
   */
  export type integrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update integrations.
     */
    data: XOR<integrationUpdateManyMutationInput, integrationUncheckedUpdateManyInput>
    /**
     * Filter which integrations to update
     */
    where?: integrationWhereInput
    /**
     * Limit how many integrations to update.
     */
    limit?: number
  }

  /**
   * integration updateManyAndReturn
   */
  export type integrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * The data used to update integrations.
     */
    data: XOR<integrationUpdateManyMutationInput, integrationUncheckedUpdateManyInput>
    /**
     * Filter which integrations to update
     */
    where?: integrationWhereInput
    /**
     * Limit how many integrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * integration upsert
   */
  export type integrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
    /**
     * The filter to search for the integration to update in case it exists.
     */
    where: integrationWhereUniqueInput
    /**
     * In case the integration found by the `where` argument doesn't exist, create a new integration with this data.
     */
    create: XOR<integrationCreateInput, integrationUncheckedCreateInput>
    /**
     * In case the integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<integrationUpdateInput, integrationUncheckedUpdateInput>
  }

  /**
   * integration delete
   */
  export type integrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
    /**
     * Filter which integration to delete.
     */
    where: integrationWhereUniqueInput
  }

  /**
   * integration deleteMany
   */
  export type integrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which integrations to delete
     */
    where?: integrationWhereInput
    /**
     * Limit how many integrations to delete.
     */
    limit?: number
  }

  /**
   * integration.credent
   */
  export type integration$credentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credent
     */
    select?: credentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credent
     */
    omit?: credentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: credentInclude<ExtArgs> | null
    where?: credentWhereInput
    orderBy?: credentOrderByWithRelationInput | credentOrderByWithRelationInput[]
    cursor?: credentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CredentScalarFieldEnum | CredentScalarFieldEnum[]
  }

  /**
   * integration.clients
   */
  export type integration$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    where?: clientsWhereInput
  }

  /**
   * integration without action
   */
  export type integrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration
     */
    select?: integrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration
     */
    omit?: integrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integrationInclude<ExtArgs> | null
  }


  /**
   * Model return_line_item
   */

  export type AggregateReturn_line_item = {
    _count: Return_line_itemCountAggregateOutputType | null
    _avg: Return_line_itemAvgAggregateOutputType | null
    _sum: Return_line_itemSumAggregateOutputType | null
    _min: Return_line_itemMinAggregateOutputType | null
    _max: Return_line_itemMaxAggregateOutputType | null
  }

  export type Return_line_itemAvgAggregateOutputType = {
    id: number | null
    refund_service_fee: number | null
    refund_subtotal: number | null
    refund_total: number | null
    order_itemsId: number | null
    return_refundId: number | null
  }

  export type Return_line_itemSumAggregateOutputType = {
    id: number | null
    refund_service_fee: number | null
    refund_subtotal: number | null
    refund_total: number | null
    order_itemsId: number | null
    return_refundId: number | null
  }

  export type Return_line_itemMinAggregateOutputType = {
    id: number | null
    origin_id: string | null
    refund_service_fee: number | null
    currency: string | null
    refund_subtotal: number | null
    refund_total: number | null
    order_itemsId: number | null
    return_refundId: number | null
  }

  export type Return_line_itemMaxAggregateOutputType = {
    id: number | null
    origin_id: string | null
    refund_service_fee: number | null
    currency: string | null
    refund_subtotal: number | null
    refund_total: number | null
    order_itemsId: number | null
    return_refundId: number | null
  }

  export type Return_line_itemCountAggregateOutputType = {
    id: number
    origin_id: number
    refund_service_fee: number
    currency: number
    refund_subtotal: number
    refund_total: number
    order_itemsId: number
    return_refundId: number
    _all: number
  }


  export type Return_line_itemAvgAggregateInputType = {
    id?: true
    refund_service_fee?: true
    refund_subtotal?: true
    refund_total?: true
    order_itemsId?: true
    return_refundId?: true
  }

  export type Return_line_itemSumAggregateInputType = {
    id?: true
    refund_service_fee?: true
    refund_subtotal?: true
    refund_total?: true
    order_itemsId?: true
    return_refundId?: true
  }

  export type Return_line_itemMinAggregateInputType = {
    id?: true
    origin_id?: true
    refund_service_fee?: true
    currency?: true
    refund_subtotal?: true
    refund_total?: true
    order_itemsId?: true
    return_refundId?: true
  }

  export type Return_line_itemMaxAggregateInputType = {
    id?: true
    origin_id?: true
    refund_service_fee?: true
    currency?: true
    refund_subtotal?: true
    refund_total?: true
    order_itemsId?: true
    return_refundId?: true
  }

  export type Return_line_itemCountAggregateInputType = {
    id?: true
    origin_id?: true
    refund_service_fee?: true
    currency?: true
    refund_subtotal?: true
    refund_total?: true
    order_itemsId?: true
    return_refundId?: true
    _all?: true
  }

  export type Return_line_itemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which return_line_item to aggregate.
     */
    where?: return_line_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_line_items to fetch.
     */
    orderBy?: return_line_itemOrderByWithRelationInput | return_line_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: return_line_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_line_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_line_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned return_line_items
    **/
    _count?: true | Return_line_itemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Return_line_itemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Return_line_itemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Return_line_itemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Return_line_itemMaxAggregateInputType
  }

  export type GetReturn_line_itemAggregateType<T extends Return_line_itemAggregateArgs> = {
        [P in keyof T & keyof AggregateReturn_line_item]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturn_line_item[P]>
      : GetScalarType<T[P], AggregateReturn_line_item[P]>
  }




  export type return_line_itemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: return_line_itemWhereInput
    orderBy?: return_line_itemOrderByWithAggregationInput | return_line_itemOrderByWithAggregationInput[]
    by: Return_line_itemScalarFieldEnum[] | Return_line_itemScalarFieldEnum
    having?: return_line_itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Return_line_itemCountAggregateInputType | true
    _avg?: Return_line_itemAvgAggregateInputType
    _sum?: Return_line_itemSumAggregateInputType
    _min?: Return_line_itemMinAggregateInputType
    _max?: Return_line_itemMaxAggregateInputType
  }

  export type Return_line_itemGroupByOutputType = {
    id: number
    origin_id: string | null
    refund_service_fee: number
    currency: string | null
    refund_subtotal: number
    refund_total: number
    order_itemsId: number
    return_refundId: number | null
    _count: Return_line_itemCountAggregateOutputType | null
    _avg: Return_line_itemAvgAggregateOutputType | null
    _sum: Return_line_itemSumAggregateOutputType | null
    _min: Return_line_itemMinAggregateOutputType | null
    _max: Return_line_itemMaxAggregateOutputType | null
  }

  type GetReturn_line_itemGroupByPayload<T extends return_line_itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Return_line_itemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Return_line_itemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Return_line_itemGroupByOutputType[P]>
            : GetScalarType<T[P], Return_line_itemGroupByOutputType[P]>
        }
      >
    >


  export type return_line_itemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    refund_service_fee?: boolean
    currency?: boolean
    refund_subtotal?: boolean
    refund_total?: boolean
    order_itemsId?: boolean
    return_refundId?: boolean
    item?: boolean | order_itemsDefaultArgs<ExtArgs>
    return_refund?: boolean | return_line_item$return_refundArgs<ExtArgs>
  }, ExtArgs["result"]["return_line_item"]>

  export type return_line_itemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    refund_service_fee?: boolean
    currency?: boolean
    refund_subtotal?: boolean
    refund_total?: boolean
    order_itemsId?: boolean
    return_refundId?: boolean
    item?: boolean | order_itemsDefaultArgs<ExtArgs>
    return_refund?: boolean | return_line_item$return_refundArgs<ExtArgs>
  }, ExtArgs["result"]["return_line_item"]>

  export type return_line_itemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    refund_service_fee?: boolean
    currency?: boolean
    refund_subtotal?: boolean
    refund_total?: boolean
    order_itemsId?: boolean
    return_refundId?: boolean
    item?: boolean | order_itemsDefaultArgs<ExtArgs>
    return_refund?: boolean | return_line_item$return_refundArgs<ExtArgs>
  }, ExtArgs["result"]["return_line_item"]>

  export type return_line_itemSelectScalar = {
    id?: boolean
    origin_id?: boolean
    refund_service_fee?: boolean
    currency?: boolean
    refund_subtotal?: boolean
    refund_total?: boolean
    order_itemsId?: boolean
    return_refundId?: boolean
  }

  export type return_line_itemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "origin_id" | "refund_service_fee" | "currency" | "refund_subtotal" | "refund_total" | "order_itemsId" | "return_refundId", ExtArgs["result"]["return_line_item"]>
  export type return_line_itemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | order_itemsDefaultArgs<ExtArgs>
    return_refund?: boolean | return_line_item$return_refundArgs<ExtArgs>
  }
  export type return_line_itemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | order_itemsDefaultArgs<ExtArgs>
    return_refund?: boolean | return_line_item$return_refundArgs<ExtArgs>
  }
  export type return_line_itemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | order_itemsDefaultArgs<ExtArgs>
    return_refund?: boolean | return_line_item$return_refundArgs<ExtArgs>
  }

  export type $return_line_itemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "return_line_item"
    objects: {
      item: Prisma.$order_itemsPayload<ExtArgs>
      return_refund: Prisma.$return_refundPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      origin_id: string | null
      refund_service_fee: number
      currency: string | null
      refund_subtotal: number
      refund_total: number
      order_itemsId: number
      return_refundId: number | null
    }, ExtArgs["result"]["return_line_item"]>
    composites: {}
  }

  type return_line_itemGetPayload<S extends boolean | null | undefined | return_line_itemDefaultArgs> = $Result.GetResult<Prisma.$return_line_itemPayload, S>

  type return_line_itemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<return_line_itemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Return_line_itemCountAggregateInputType | true
    }

  export interface return_line_itemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['return_line_item'], meta: { name: 'return_line_item' } }
    /**
     * Find zero or one Return_line_item that matches the filter.
     * @param {return_line_itemFindUniqueArgs} args - Arguments to find a Return_line_item
     * @example
     * // Get one Return_line_item
     * const return_line_item = await prisma.return_line_item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends return_line_itemFindUniqueArgs>(args: SelectSubset<T, return_line_itemFindUniqueArgs<ExtArgs>>): Prisma__return_line_itemClient<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Return_line_item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {return_line_itemFindUniqueOrThrowArgs} args - Arguments to find a Return_line_item
     * @example
     * // Get one Return_line_item
     * const return_line_item = await prisma.return_line_item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends return_line_itemFindUniqueOrThrowArgs>(args: SelectSubset<T, return_line_itemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__return_line_itemClient<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Return_line_item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_line_itemFindFirstArgs} args - Arguments to find a Return_line_item
     * @example
     * // Get one Return_line_item
     * const return_line_item = await prisma.return_line_item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends return_line_itemFindFirstArgs>(args?: SelectSubset<T, return_line_itemFindFirstArgs<ExtArgs>>): Prisma__return_line_itemClient<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Return_line_item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_line_itemFindFirstOrThrowArgs} args - Arguments to find a Return_line_item
     * @example
     * // Get one Return_line_item
     * const return_line_item = await prisma.return_line_item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends return_line_itemFindFirstOrThrowArgs>(args?: SelectSubset<T, return_line_itemFindFirstOrThrowArgs<ExtArgs>>): Prisma__return_line_itemClient<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Return_line_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_line_itemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Return_line_items
     * const return_line_items = await prisma.return_line_item.findMany()
     * 
     * // Get first 10 Return_line_items
     * const return_line_items = await prisma.return_line_item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const return_line_itemWithIdOnly = await prisma.return_line_item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends return_line_itemFindManyArgs>(args?: SelectSubset<T, return_line_itemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Return_line_item.
     * @param {return_line_itemCreateArgs} args - Arguments to create a Return_line_item.
     * @example
     * // Create one Return_line_item
     * const Return_line_item = await prisma.return_line_item.create({
     *   data: {
     *     // ... data to create a Return_line_item
     *   }
     * })
     * 
     */
    create<T extends return_line_itemCreateArgs>(args: SelectSubset<T, return_line_itemCreateArgs<ExtArgs>>): Prisma__return_line_itemClient<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Return_line_items.
     * @param {return_line_itemCreateManyArgs} args - Arguments to create many Return_line_items.
     * @example
     * // Create many Return_line_items
     * const return_line_item = await prisma.return_line_item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends return_line_itemCreateManyArgs>(args?: SelectSubset<T, return_line_itemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Return_line_items and returns the data saved in the database.
     * @param {return_line_itemCreateManyAndReturnArgs} args - Arguments to create many Return_line_items.
     * @example
     * // Create many Return_line_items
     * const return_line_item = await prisma.return_line_item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Return_line_items and only return the `id`
     * const return_line_itemWithIdOnly = await prisma.return_line_item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends return_line_itemCreateManyAndReturnArgs>(args?: SelectSubset<T, return_line_itemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Return_line_item.
     * @param {return_line_itemDeleteArgs} args - Arguments to delete one Return_line_item.
     * @example
     * // Delete one Return_line_item
     * const Return_line_item = await prisma.return_line_item.delete({
     *   where: {
     *     // ... filter to delete one Return_line_item
     *   }
     * })
     * 
     */
    delete<T extends return_line_itemDeleteArgs>(args: SelectSubset<T, return_line_itemDeleteArgs<ExtArgs>>): Prisma__return_line_itemClient<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Return_line_item.
     * @param {return_line_itemUpdateArgs} args - Arguments to update one Return_line_item.
     * @example
     * // Update one Return_line_item
     * const return_line_item = await prisma.return_line_item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends return_line_itemUpdateArgs>(args: SelectSubset<T, return_line_itemUpdateArgs<ExtArgs>>): Prisma__return_line_itemClient<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Return_line_items.
     * @param {return_line_itemDeleteManyArgs} args - Arguments to filter Return_line_items to delete.
     * @example
     * // Delete a few Return_line_items
     * const { count } = await prisma.return_line_item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends return_line_itemDeleteManyArgs>(args?: SelectSubset<T, return_line_itemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Return_line_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_line_itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Return_line_items
     * const return_line_item = await prisma.return_line_item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends return_line_itemUpdateManyArgs>(args: SelectSubset<T, return_line_itemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Return_line_items and returns the data updated in the database.
     * @param {return_line_itemUpdateManyAndReturnArgs} args - Arguments to update many Return_line_items.
     * @example
     * // Update many Return_line_items
     * const return_line_item = await prisma.return_line_item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Return_line_items and only return the `id`
     * const return_line_itemWithIdOnly = await prisma.return_line_item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends return_line_itemUpdateManyAndReturnArgs>(args: SelectSubset<T, return_line_itemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Return_line_item.
     * @param {return_line_itemUpsertArgs} args - Arguments to update or create a Return_line_item.
     * @example
     * // Update or create a Return_line_item
     * const return_line_item = await prisma.return_line_item.upsert({
     *   create: {
     *     // ... data to create a Return_line_item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Return_line_item we want to update
     *   }
     * })
     */
    upsert<T extends return_line_itemUpsertArgs>(args: SelectSubset<T, return_line_itemUpsertArgs<ExtArgs>>): Prisma__return_line_itemClient<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Return_line_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_line_itemCountArgs} args - Arguments to filter Return_line_items to count.
     * @example
     * // Count the number of Return_line_items
     * const count = await prisma.return_line_item.count({
     *   where: {
     *     // ... the filter for the Return_line_items we want to count
     *   }
     * })
    **/
    count<T extends return_line_itemCountArgs>(
      args?: Subset<T, return_line_itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Return_line_itemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Return_line_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Return_line_itemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Return_line_itemAggregateArgs>(args: Subset<T, Return_line_itemAggregateArgs>): Prisma.PrismaPromise<GetReturn_line_itemAggregateType<T>>

    /**
     * Group by Return_line_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_line_itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends return_line_itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: return_line_itemGroupByArgs['orderBy'] }
        : { orderBy?: return_line_itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, return_line_itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturn_line_itemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the return_line_item model
   */
  readonly fields: return_line_itemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for return_line_item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__return_line_itemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends order_itemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, order_itemsDefaultArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    return_refund<T extends return_line_item$return_refundArgs<ExtArgs> = {}>(args?: Subset<T, return_line_item$return_refundArgs<ExtArgs>>): Prisma__return_refundClient<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the return_line_item model
   */
  interface return_line_itemFieldRefs {
    readonly id: FieldRef<"return_line_item", 'Int'>
    readonly origin_id: FieldRef<"return_line_item", 'String'>
    readonly refund_service_fee: FieldRef<"return_line_item", 'Int'>
    readonly currency: FieldRef<"return_line_item", 'String'>
    readonly refund_subtotal: FieldRef<"return_line_item", 'Int'>
    readonly refund_total: FieldRef<"return_line_item", 'Int'>
    readonly order_itemsId: FieldRef<"return_line_item", 'Int'>
    readonly return_refundId: FieldRef<"return_line_item", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * return_line_item findUnique
   */
  export type return_line_itemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
    /**
     * Filter, which return_line_item to fetch.
     */
    where: return_line_itemWhereUniqueInput
  }

  /**
   * return_line_item findUniqueOrThrow
   */
  export type return_line_itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
    /**
     * Filter, which return_line_item to fetch.
     */
    where: return_line_itemWhereUniqueInput
  }

  /**
   * return_line_item findFirst
   */
  export type return_line_itemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
    /**
     * Filter, which return_line_item to fetch.
     */
    where?: return_line_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_line_items to fetch.
     */
    orderBy?: return_line_itemOrderByWithRelationInput | return_line_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for return_line_items.
     */
    cursor?: return_line_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_line_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_line_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of return_line_items.
     */
    distinct?: Return_line_itemScalarFieldEnum | Return_line_itemScalarFieldEnum[]
  }

  /**
   * return_line_item findFirstOrThrow
   */
  export type return_line_itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
    /**
     * Filter, which return_line_item to fetch.
     */
    where?: return_line_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_line_items to fetch.
     */
    orderBy?: return_line_itemOrderByWithRelationInput | return_line_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for return_line_items.
     */
    cursor?: return_line_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_line_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_line_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of return_line_items.
     */
    distinct?: Return_line_itemScalarFieldEnum | Return_line_itemScalarFieldEnum[]
  }

  /**
   * return_line_item findMany
   */
  export type return_line_itemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
    /**
     * Filter, which return_line_items to fetch.
     */
    where?: return_line_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_line_items to fetch.
     */
    orderBy?: return_line_itemOrderByWithRelationInput | return_line_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing return_line_items.
     */
    cursor?: return_line_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_line_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_line_items.
     */
    skip?: number
    distinct?: Return_line_itemScalarFieldEnum | Return_line_itemScalarFieldEnum[]
  }

  /**
   * return_line_item create
   */
  export type return_line_itemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
    /**
     * The data needed to create a return_line_item.
     */
    data: XOR<return_line_itemCreateInput, return_line_itemUncheckedCreateInput>
  }

  /**
   * return_line_item createMany
   */
  export type return_line_itemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many return_line_items.
     */
    data: return_line_itemCreateManyInput | return_line_itemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * return_line_item createManyAndReturn
   */
  export type return_line_itemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * The data used to create many return_line_items.
     */
    data: return_line_itemCreateManyInput | return_line_itemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * return_line_item update
   */
  export type return_line_itemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
    /**
     * The data needed to update a return_line_item.
     */
    data: XOR<return_line_itemUpdateInput, return_line_itemUncheckedUpdateInput>
    /**
     * Choose, which return_line_item to update.
     */
    where: return_line_itemWhereUniqueInput
  }

  /**
   * return_line_item updateMany
   */
  export type return_line_itemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update return_line_items.
     */
    data: XOR<return_line_itemUpdateManyMutationInput, return_line_itemUncheckedUpdateManyInput>
    /**
     * Filter which return_line_items to update
     */
    where?: return_line_itemWhereInput
    /**
     * Limit how many return_line_items to update.
     */
    limit?: number
  }

  /**
   * return_line_item updateManyAndReturn
   */
  export type return_line_itemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * The data used to update return_line_items.
     */
    data: XOR<return_line_itemUpdateManyMutationInput, return_line_itemUncheckedUpdateManyInput>
    /**
     * Filter which return_line_items to update
     */
    where?: return_line_itemWhereInput
    /**
     * Limit how many return_line_items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * return_line_item upsert
   */
  export type return_line_itemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
    /**
     * The filter to search for the return_line_item to update in case it exists.
     */
    where: return_line_itemWhereUniqueInput
    /**
     * In case the return_line_item found by the `where` argument doesn't exist, create a new return_line_item with this data.
     */
    create: XOR<return_line_itemCreateInput, return_line_itemUncheckedCreateInput>
    /**
     * In case the return_line_item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<return_line_itemUpdateInput, return_line_itemUncheckedUpdateInput>
  }

  /**
   * return_line_item delete
   */
  export type return_line_itemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
    /**
     * Filter which return_line_item to delete.
     */
    where: return_line_itemWhereUniqueInput
  }

  /**
   * return_line_item deleteMany
   */
  export type return_line_itemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which return_line_items to delete
     */
    where?: return_line_itemWhereInput
    /**
     * Limit how many return_line_items to delete.
     */
    limit?: number
  }

  /**
   * return_line_item.return_refund
   */
  export type return_line_item$return_refundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
    where?: return_refundWhereInput
  }

  /**
   * return_line_item without action
   */
  export type return_line_itemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
  }


  /**
   * Model return_refund
   */

  export type AggregateReturn_refund = {
    _count: Return_refundCountAggregateOutputType | null
    _avg: Return_refundAvgAggregateOutputType | null
    _sum: Return_refundSumAggregateOutputType | null
    _min: Return_refundMinAggregateOutputType | null
    _max: Return_refundMaxAggregateOutputType | null
  }

  export type Return_refundAvgAggregateOutputType = {
    id: number | null
    total_amount: number | null
    ordersId: number | null
  }

  export type Return_refundSumAggregateOutputType = {
    id: number | null
    total_amount: number | null
    ordersId: number | null
  }

  export type Return_refundMinAggregateOutputType = {
    id: number | null
    origin_id: string | null
    status: string | null
    total_amount: number | null
    return_type: string | null
    return_reason: string | null
    ordersId: number | null
  }

  export type Return_refundMaxAggregateOutputType = {
    id: number | null
    origin_id: string | null
    status: string | null
    total_amount: number | null
    return_type: string | null
    return_reason: string | null
    ordersId: number | null
  }

  export type Return_refundCountAggregateOutputType = {
    id: number
    origin_id: number
    status: number
    total_amount: number
    return_type: number
    return_reason: number
    ordersId: number
    _all: number
  }


  export type Return_refundAvgAggregateInputType = {
    id?: true
    total_amount?: true
    ordersId?: true
  }

  export type Return_refundSumAggregateInputType = {
    id?: true
    total_amount?: true
    ordersId?: true
  }

  export type Return_refundMinAggregateInputType = {
    id?: true
    origin_id?: true
    status?: true
    total_amount?: true
    return_type?: true
    return_reason?: true
    ordersId?: true
  }

  export type Return_refundMaxAggregateInputType = {
    id?: true
    origin_id?: true
    status?: true
    total_amount?: true
    return_type?: true
    return_reason?: true
    ordersId?: true
  }

  export type Return_refundCountAggregateInputType = {
    id?: true
    origin_id?: true
    status?: true
    total_amount?: true
    return_type?: true
    return_reason?: true
    ordersId?: true
    _all?: true
  }

  export type Return_refundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which return_refund to aggregate.
     */
    where?: return_refundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_refunds to fetch.
     */
    orderBy?: return_refundOrderByWithRelationInput | return_refundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: return_refundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned return_refunds
    **/
    _count?: true | Return_refundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Return_refundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Return_refundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Return_refundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Return_refundMaxAggregateInputType
  }

  export type GetReturn_refundAggregateType<T extends Return_refundAggregateArgs> = {
        [P in keyof T & keyof AggregateReturn_refund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturn_refund[P]>
      : GetScalarType<T[P], AggregateReturn_refund[P]>
  }




  export type return_refundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: return_refundWhereInput
    orderBy?: return_refundOrderByWithAggregationInput | return_refundOrderByWithAggregationInput[]
    by: Return_refundScalarFieldEnum[] | Return_refundScalarFieldEnum
    having?: return_refundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Return_refundCountAggregateInputType | true
    _avg?: Return_refundAvgAggregateInputType
    _sum?: Return_refundSumAggregateInputType
    _min?: Return_refundMinAggregateInputType
    _max?: Return_refundMaxAggregateInputType
  }

  export type Return_refundGroupByOutputType = {
    id: number
    origin_id: string | null
    status: string | null
    total_amount: number
    return_type: string | null
    return_reason: string | null
    ordersId: number
    _count: Return_refundCountAggregateOutputType | null
    _avg: Return_refundAvgAggregateOutputType | null
    _sum: Return_refundSumAggregateOutputType | null
    _min: Return_refundMinAggregateOutputType | null
    _max: Return_refundMaxAggregateOutputType | null
  }

  type GetReturn_refundGroupByPayload<T extends return_refundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Return_refundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Return_refundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Return_refundGroupByOutputType[P]>
            : GetScalarType<T[P], Return_refundGroupByOutputType[P]>
        }
      >
    >


  export type return_refundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    status?: boolean
    total_amount?: boolean
    return_type?: boolean
    return_reason?: boolean
    ordersId?: boolean
    order?: boolean | ordersDefaultArgs<ExtArgs>
    line_item?: boolean | return_refund$line_itemArgs<ExtArgs>
    _count?: boolean | Return_refundCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["return_refund"]>

  export type return_refundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    status?: boolean
    total_amount?: boolean
    return_type?: boolean
    return_reason?: boolean
    ordersId?: boolean
    order?: boolean | ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["return_refund"]>

  export type return_refundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin_id?: boolean
    status?: boolean
    total_amount?: boolean
    return_type?: boolean
    return_reason?: boolean
    ordersId?: boolean
    order?: boolean | ordersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["return_refund"]>

  export type return_refundSelectScalar = {
    id?: boolean
    origin_id?: boolean
    status?: boolean
    total_amount?: boolean
    return_type?: boolean
    return_reason?: boolean
    ordersId?: boolean
  }

  export type return_refundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "origin_id" | "status" | "total_amount" | "return_type" | "return_reason" | "ordersId", ExtArgs["result"]["return_refund"]>
  export type return_refundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ordersDefaultArgs<ExtArgs>
    line_item?: boolean | return_refund$line_itemArgs<ExtArgs>
    _count?: boolean | Return_refundCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type return_refundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ordersDefaultArgs<ExtArgs>
  }
  export type return_refundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ordersDefaultArgs<ExtArgs>
  }

  export type $return_refundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "return_refund"
    objects: {
      order: Prisma.$ordersPayload<ExtArgs>
      line_item: Prisma.$return_line_itemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      origin_id: string | null
      status: string | null
      total_amount: number
      return_type: string | null
      return_reason: string | null
      ordersId: number
    }, ExtArgs["result"]["return_refund"]>
    composites: {}
  }

  type return_refundGetPayload<S extends boolean | null | undefined | return_refundDefaultArgs> = $Result.GetResult<Prisma.$return_refundPayload, S>

  type return_refundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<return_refundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Return_refundCountAggregateInputType | true
    }

  export interface return_refundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['return_refund'], meta: { name: 'return_refund' } }
    /**
     * Find zero or one Return_refund that matches the filter.
     * @param {return_refundFindUniqueArgs} args - Arguments to find a Return_refund
     * @example
     * // Get one Return_refund
     * const return_refund = await prisma.return_refund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends return_refundFindUniqueArgs>(args: SelectSubset<T, return_refundFindUniqueArgs<ExtArgs>>): Prisma__return_refundClient<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Return_refund that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {return_refundFindUniqueOrThrowArgs} args - Arguments to find a Return_refund
     * @example
     * // Get one Return_refund
     * const return_refund = await prisma.return_refund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends return_refundFindUniqueOrThrowArgs>(args: SelectSubset<T, return_refundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__return_refundClient<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Return_refund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_refundFindFirstArgs} args - Arguments to find a Return_refund
     * @example
     * // Get one Return_refund
     * const return_refund = await prisma.return_refund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends return_refundFindFirstArgs>(args?: SelectSubset<T, return_refundFindFirstArgs<ExtArgs>>): Prisma__return_refundClient<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Return_refund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_refundFindFirstOrThrowArgs} args - Arguments to find a Return_refund
     * @example
     * // Get one Return_refund
     * const return_refund = await prisma.return_refund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends return_refundFindFirstOrThrowArgs>(args?: SelectSubset<T, return_refundFindFirstOrThrowArgs<ExtArgs>>): Prisma__return_refundClient<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Return_refunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_refundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Return_refunds
     * const return_refunds = await prisma.return_refund.findMany()
     * 
     * // Get first 10 Return_refunds
     * const return_refunds = await prisma.return_refund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const return_refundWithIdOnly = await prisma.return_refund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends return_refundFindManyArgs>(args?: SelectSubset<T, return_refundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Return_refund.
     * @param {return_refundCreateArgs} args - Arguments to create a Return_refund.
     * @example
     * // Create one Return_refund
     * const Return_refund = await prisma.return_refund.create({
     *   data: {
     *     // ... data to create a Return_refund
     *   }
     * })
     * 
     */
    create<T extends return_refundCreateArgs>(args: SelectSubset<T, return_refundCreateArgs<ExtArgs>>): Prisma__return_refundClient<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Return_refunds.
     * @param {return_refundCreateManyArgs} args - Arguments to create many Return_refunds.
     * @example
     * // Create many Return_refunds
     * const return_refund = await prisma.return_refund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends return_refundCreateManyArgs>(args?: SelectSubset<T, return_refundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Return_refunds and returns the data saved in the database.
     * @param {return_refundCreateManyAndReturnArgs} args - Arguments to create many Return_refunds.
     * @example
     * // Create many Return_refunds
     * const return_refund = await prisma.return_refund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Return_refunds and only return the `id`
     * const return_refundWithIdOnly = await prisma.return_refund.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends return_refundCreateManyAndReturnArgs>(args?: SelectSubset<T, return_refundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Return_refund.
     * @param {return_refundDeleteArgs} args - Arguments to delete one Return_refund.
     * @example
     * // Delete one Return_refund
     * const Return_refund = await prisma.return_refund.delete({
     *   where: {
     *     // ... filter to delete one Return_refund
     *   }
     * })
     * 
     */
    delete<T extends return_refundDeleteArgs>(args: SelectSubset<T, return_refundDeleteArgs<ExtArgs>>): Prisma__return_refundClient<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Return_refund.
     * @param {return_refundUpdateArgs} args - Arguments to update one Return_refund.
     * @example
     * // Update one Return_refund
     * const return_refund = await prisma.return_refund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends return_refundUpdateArgs>(args: SelectSubset<T, return_refundUpdateArgs<ExtArgs>>): Prisma__return_refundClient<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Return_refunds.
     * @param {return_refundDeleteManyArgs} args - Arguments to filter Return_refunds to delete.
     * @example
     * // Delete a few Return_refunds
     * const { count } = await prisma.return_refund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends return_refundDeleteManyArgs>(args?: SelectSubset<T, return_refundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Return_refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_refundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Return_refunds
     * const return_refund = await prisma.return_refund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends return_refundUpdateManyArgs>(args: SelectSubset<T, return_refundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Return_refunds and returns the data updated in the database.
     * @param {return_refundUpdateManyAndReturnArgs} args - Arguments to update many Return_refunds.
     * @example
     * // Update many Return_refunds
     * const return_refund = await prisma.return_refund.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Return_refunds and only return the `id`
     * const return_refundWithIdOnly = await prisma.return_refund.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends return_refundUpdateManyAndReturnArgs>(args: SelectSubset<T, return_refundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Return_refund.
     * @param {return_refundUpsertArgs} args - Arguments to update or create a Return_refund.
     * @example
     * // Update or create a Return_refund
     * const return_refund = await prisma.return_refund.upsert({
     *   create: {
     *     // ... data to create a Return_refund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Return_refund we want to update
     *   }
     * })
     */
    upsert<T extends return_refundUpsertArgs>(args: SelectSubset<T, return_refundUpsertArgs<ExtArgs>>): Prisma__return_refundClient<$Result.GetResult<Prisma.$return_refundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Return_refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_refundCountArgs} args - Arguments to filter Return_refunds to count.
     * @example
     * // Count the number of Return_refunds
     * const count = await prisma.return_refund.count({
     *   where: {
     *     // ... the filter for the Return_refunds we want to count
     *   }
     * })
    **/
    count<T extends return_refundCountArgs>(
      args?: Subset<T, return_refundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Return_refundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Return_refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Return_refundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Return_refundAggregateArgs>(args: Subset<T, Return_refundAggregateArgs>): Prisma.PrismaPromise<GetReturn_refundAggregateType<T>>

    /**
     * Group by Return_refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_refundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends return_refundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: return_refundGroupByArgs['orderBy'] }
        : { orderBy?: return_refundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, return_refundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturn_refundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the return_refund model
   */
  readonly fields: return_refundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for return_refund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__return_refundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ordersDefaultArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    line_item<T extends return_refund$line_itemArgs<ExtArgs> = {}>(args?: Subset<T, return_refund$line_itemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_line_itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the return_refund model
   */
  interface return_refundFieldRefs {
    readonly id: FieldRef<"return_refund", 'Int'>
    readonly origin_id: FieldRef<"return_refund", 'String'>
    readonly status: FieldRef<"return_refund", 'String'>
    readonly total_amount: FieldRef<"return_refund", 'Int'>
    readonly return_type: FieldRef<"return_refund", 'String'>
    readonly return_reason: FieldRef<"return_refund", 'String'>
    readonly ordersId: FieldRef<"return_refund", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * return_refund findUnique
   */
  export type return_refundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
    /**
     * Filter, which return_refund to fetch.
     */
    where: return_refundWhereUniqueInput
  }

  /**
   * return_refund findUniqueOrThrow
   */
  export type return_refundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
    /**
     * Filter, which return_refund to fetch.
     */
    where: return_refundWhereUniqueInput
  }

  /**
   * return_refund findFirst
   */
  export type return_refundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
    /**
     * Filter, which return_refund to fetch.
     */
    where?: return_refundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_refunds to fetch.
     */
    orderBy?: return_refundOrderByWithRelationInput | return_refundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for return_refunds.
     */
    cursor?: return_refundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of return_refunds.
     */
    distinct?: Return_refundScalarFieldEnum | Return_refundScalarFieldEnum[]
  }

  /**
   * return_refund findFirstOrThrow
   */
  export type return_refundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
    /**
     * Filter, which return_refund to fetch.
     */
    where?: return_refundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_refunds to fetch.
     */
    orderBy?: return_refundOrderByWithRelationInput | return_refundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for return_refunds.
     */
    cursor?: return_refundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of return_refunds.
     */
    distinct?: Return_refundScalarFieldEnum | Return_refundScalarFieldEnum[]
  }

  /**
   * return_refund findMany
   */
  export type return_refundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
    /**
     * Filter, which return_refunds to fetch.
     */
    where?: return_refundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_refunds to fetch.
     */
    orderBy?: return_refundOrderByWithRelationInput | return_refundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing return_refunds.
     */
    cursor?: return_refundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_refunds.
     */
    skip?: number
    distinct?: Return_refundScalarFieldEnum | Return_refundScalarFieldEnum[]
  }

  /**
   * return_refund create
   */
  export type return_refundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
    /**
     * The data needed to create a return_refund.
     */
    data: XOR<return_refundCreateInput, return_refundUncheckedCreateInput>
  }

  /**
   * return_refund createMany
   */
  export type return_refundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many return_refunds.
     */
    data: return_refundCreateManyInput | return_refundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * return_refund createManyAndReturn
   */
  export type return_refundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * The data used to create many return_refunds.
     */
    data: return_refundCreateManyInput | return_refundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * return_refund update
   */
  export type return_refundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
    /**
     * The data needed to update a return_refund.
     */
    data: XOR<return_refundUpdateInput, return_refundUncheckedUpdateInput>
    /**
     * Choose, which return_refund to update.
     */
    where: return_refundWhereUniqueInput
  }

  /**
   * return_refund updateMany
   */
  export type return_refundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update return_refunds.
     */
    data: XOR<return_refundUpdateManyMutationInput, return_refundUncheckedUpdateManyInput>
    /**
     * Filter which return_refunds to update
     */
    where?: return_refundWhereInput
    /**
     * Limit how many return_refunds to update.
     */
    limit?: number
  }

  /**
   * return_refund updateManyAndReturn
   */
  export type return_refundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * The data used to update return_refunds.
     */
    data: XOR<return_refundUpdateManyMutationInput, return_refundUncheckedUpdateManyInput>
    /**
     * Filter which return_refunds to update
     */
    where?: return_refundWhereInput
    /**
     * Limit how many return_refunds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * return_refund upsert
   */
  export type return_refundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
    /**
     * The filter to search for the return_refund to update in case it exists.
     */
    where: return_refundWhereUniqueInput
    /**
     * In case the return_refund found by the `where` argument doesn't exist, create a new return_refund with this data.
     */
    create: XOR<return_refundCreateInput, return_refundUncheckedCreateInput>
    /**
     * In case the return_refund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<return_refundUpdateInput, return_refundUncheckedUpdateInput>
  }

  /**
   * return_refund delete
   */
  export type return_refundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
    /**
     * Filter which return_refund to delete.
     */
    where: return_refundWhereUniqueInput
  }

  /**
   * return_refund deleteMany
   */
  export type return_refundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which return_refunds to delete
     */
    where?: return_refundWhereInput
    /**
     * Limit how many return_refunds to delete.
     */
    limit?: number
  }

  /**
   * return_refund.line_item
   */
  export type return_refund$line_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_line_item
     */
    select?: return_line_itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_line_item
     */
    omit?: return_line_itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_line_itemInclude<ExtArgs> | null
    where?: return_line_itemWhereInput
    orderBy?: return_line_itemOrderByWithRelationInput | return_line_itemOrderByWithRelationInput[]
    cursor?: return_line_itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Return_line_itemScalarFieldEnum | Return_line_itemScalarFieldEnum[]
  }

  /**
   * return_refund without action
   */
  export type return_refundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_refund
     */
    select?: return_refundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_refund
     */
    omit?: return_refundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_refundInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    origin_id: 'origin_id',
    phone: 'phone',
    email: 'email'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const Products_imgScalarFieldEnum: {
    id: 'id',
    origin_id: 'origin_id',
    filename: 'filename',
    status: 'status',
    width: 'width',
    height: 'height',
    originalUrl: 'originalUrl',
    thumbnailUrl: 'thumbnailUrl',
    productsId: 'productsId'
  };

  export type Products_imgScalarFieldEnum = (typeof Products_imgScalarFieldEnum)[keyof typeof Products_imgScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    clientsId: 'clientsId'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    origin_id: 'origin_id',
    channelId: 'channelId',
    refresh_token: 'refresh_token',
    token: 'token',
    secondary_refresh_token: 'secondary_refresh_token',
    secondary_token: 'secondary_token',
    url: 'url',
    status: 'status'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    origin_id: 'origin_id',
    status: 'status',
    name: 'name',
    condition: 'condition',
    desc: 'desc',
    category: 'category',
    price: 'price',
    currency: 'currency',
    createdAt: 'createdAt',
    weight: 'weight',
    stock: 'stock',
    sku: 'sku',
    storeId: 'storeId'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const Order_itemsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    qty: 'qty',
    package_id: 'package_id',
    invoice: 'invoice',
    total_price: 'total_price',
    notes: 'notes',
    ordersId: 'ordersId',
    productsId: 'productsId',
    origin_id: 'origin_id'
  };

  export type Order_itemsScalarFieldEnum = (typeof Order_itemsScalarFieldEnum)[keyof typeof Order_itemsScalarFieldEnum]


  export const LogisticScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type'
  };

  export type LogisticScalarFieldEnum = (typeof LogisticScalarFieldEnum)[keyof typeof LogisticScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    status: 'status',
    shop_id: 'shop_id',
    payment_id: 'payment_id',
    temp_id: 'temp_id',
    origin_id: 'origin_id',
    package_id: 'package_id',
    invoice: 'invoice',
    recp_name: 'recp_name',
    recp_phone: 'recp_phone',
    recp_addr_full: 'recp_addr_full',
    recp_addr_district: 'recp_addr_district',
    recp_addr_city: 'recp_addr_city',
    recp_addr_province: 'recp_addr_province',
    recp_addr_country: 'recp_addr_country',
    recp_addr_postal_code: 'recp_addr_postal_code',
    recp_addr_district_id: 'recp_addr_district_id',
    recp_addr_city_id: 'recp_addr_city_id',
    tracking_number: 'tracking_number',
    ship_document_url: 'ship_document_url',
    recp_addr_province_id: 'recp_addr_province_id',
    recp_addr_geo: 'recp_addr_geo',
    logistic_service: 'logistic_service',
    origin_createdAt: 'origin_createdAt',
    accept_partial: 'accept_partial',
    device: 'device',
    storeId: 'storeId',
    customersId: 'customersId',
    logisticId: 'logisticId',
    total_product_price: 'total_product_price',
    shipping_price: 'shipping_price',
    seller_discount: 'seller_discount',
    platform_discount: 'platform_discount',
    shipping_seller_discount: 'shipping_seller_discount',
    shipping_platform_discount: 'shipping_platform_discount',
    buyer_service_fee: 'buyer_service_fee',
    handling_fee: 'handling_fee',
    shipping_insurance_fee: 'shipping_insurance_fee',
    item_insurance_fee: 'item_insurance_fee',
    total_amount: 'total_amount',
    updatedAt: 'updatedAt'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const Omnichat_userScalarFieldEnum: {
    id: 'id',
    username: 'username',
    thumbnailUrl: 'thumbnailUrl',
    origin_id: 'origin_id',
    createdAt: 'createdAt',
    externalId: 'externalId'
  };

  export type Omnichat_userScalarFieldEnum = (typeof Omnichat_userScalarFieldEnum)[keyof typeof Omnichat_userScalarFieldEnum]


  export const OmnichatScalarFieldEnum: {
    id: 'id',
    origin_id: 'origin_id',
    last_message: 'last_message',
    last_messageId: 'last_messageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    storeId: 'storeId',
    omnichat_userId: 'omnichat_userId',
    externalId: 'externalId'
  };

  export type OmnichatScalarFieldEnum = (typeof OmnichatScalarFieldEnum)[keyof typeof OmnichatScalarFieldEnum]


  export const Omnichat_lineScalarFieldEnum: {
    id: 'id',
    origin_id: 'origin_id',
    createdAt: 'createdAt',
    line_text: 'line_text',
    omnichatId: 'omnichatId',
    author: 'author',
    omnichat_userId: 'omnichat_userId',
    chat_type: 'chat_type'
  };

  export type Omnichat_lineScalarFieldEnum = (typeof Omnichat_lineScalarFieldEnum)[keyof typeof Omnichat_lineScalarFieldEnum]


  export const ZdconnectorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    host: 'host',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    suncoAppId: 'suncoAppId',
    suncoAppKey: 'suncoAppKey',
    suncoAppSecret: 'suncoAppSecret',
    zdAPIToken: 'zdAPIToken',
    resource: 'resource',
    clientsId: 'clientsId'
  };

  export type ZdconnectorScalarFieldEnum = (typeof ZdconnectorScalarFieldEnum)[keyof typeof ZdconnectorScalarFieldEnum]


  export const OmnicrmScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    type: 'type'
  };

  export type OmnicrmScalarFieldEnum = (typeof OmnicrmScalarFieldEnum)[keyof typeof OmnicrmScalarFieldEnum]


  export const ClientsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    origin_id: 'origin_id'
  };

  export type ClientsScalarFieldEnum = (typeof ClientsScalarFieldEnum)[keyof typeof ClientsScalarFieldEnum]


  export const CredentScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    integrationId: 'integrationId'
  };

  export type CredentScalarFieldEnum = (typeof CredentScalarFieldEnum)[keyof typeof CredentScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    baseUrl: 'baseUrl',
    f_chat: 'f_chat',
    f_review: 'f_review',
    f_cancel: 'f_cancel',
    f_rr: 'f_rr',
    status: 'status',
    notes: 'notes',
    clientsId: 'clientsId'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const Return_line_itemScalarFieldEnum: {
    id: 'id',
    origin_id: 'origin_id',
    refund_service_fee: 'refund_service_fee',
    currency: 'currency',
    refund_subtotal: 'refund_subtotal',
    refund_total: 'refund_total',
    order_itemsId: 'order_itemsId',
    return_refundId: 'return_refundId'
  };

  export type Return_line_itemScalarFieldEnum = (typeof Return_line_itemScalarFieldEnum)[keyof typeof Return_line_itemScalarFieldEnum]


  export const Return_refundScalarFieldEnum: {
    id: 'id',
    origin_id: 'origin_id',
    status: 'status',
    total_amount: 'total_amount',
    return_type: 'return_type',
    return_reason: 'return_reason',
    ordersId: 'ordersId'
  };

  export type Return_refundScalarFieldEnum = (typeof Return_refundScalarFieldEnum)[keyof typeof Return_refundScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type customersWhereInput = {
    AND?: customersWhereInput | customersWhereInput[]
    OR?: customersWhereInput[]
    NOT?: customersWhereInput | customersWhereInput[]
    id?: IntFilter<"customers"> | number
    name?: StringNullableFilter<"customers"> | string | null
    origin_id?: StringNullableFilter<"customers"> | string | null
    phone?: StringNullableFilter<"customers"> | string | null
    email?: StringNullableFilter<"customers"> | string | null
    orders?: OrdersListRelationFilter
  }

  export type customersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    orders?: ordersOrderByRelationAggregateInput
  }

  export type customersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    AND?: customersWhereInput | customersWhereInput[]
    OR?: customersWhereInput[]
    NOT?: customersWhereInput | customersWhereInput[]
    name?: StringNullableFilter<"customers"> | string | null
    phone?: StringNullableFilter<"customers"> | string | null
    email?: StringNullableFilter<"customers"> | string | null
    orders?: OrdersListRelationFilter
  }, "id" | "origin_id">

  export type customersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    _count?: customersCountOrderByAggregateInput
    _avg?: customersAvgOrderByAggregateInput
    _max?: customersMaxOrderByAggregateInput
    _min?: customersMinOrderByAggregateInput
    _sum?: customersSumOrderByAggregateInput
  }

  export type customersScalarWhereWithAggregatesInput = {
    AND?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[]
    OR?: customersScalarWhereWithAggregatesInput[]
    NOT?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customers"> | number
    name?: StringNullableWithAggregatesFilter<"customers"> | string | null
    origin_id?: StringNullableWithAggregatesFilter<"customers"> | string | null
    phone?: StringNullableWithAggregatesFilter<"customers"> | string | null
    email?: StringNullableWithAggregatesFilter<"customers"> | string | null
  }

  export type products_imgWhereInput = {
    AND?: products_imgWhereInput | products_imgWhereInput[]
    OR?: products_imgWhereInput[]
    NOT?: products_imgWhereInput | products_imgWhereInput[]
    id?: IntFilter<"products_img"> | number
    origin_id?: StringNullableFilter<"products_img"> | string | null
    filename?: StringNullableFilter<"products_img"> | string | null
    status?: StringNullableFilter<"products_img"> | string | null
    width?: IntNullableFilter<"products_img"> | number | null
    height?: IntNullableFilter<"products_img"> | number | null
    originalUrl?: StringNullableFilter<"products_img"> | string | null
    thumbnailUrl?: StringNullableFilter<"products_img"> | string | null
    productsId?: IntNullableFilter<"products_img"> | number | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
  }

  export type products_imgOrderByWithRelationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    originalUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    productsId?: SortOrderInput | SortOrder
    products?: productsOrderByWithRelationInput
  }

  export type products_imgWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    AND?: products_imgWhereInput | products_imgWhereInput[]
    OR?: products_imgWhereInput[]
    NOT?: products_imgWhereInput | products_imgWhereInput[]
    filename?: StringNullableFilter<"products_img"> | string | null
    status?: StringNullableFilter<"products_img"> | string | null
    width?: IntNullableFilter<"products_img"> | number | null
    height?: IntNullableFilter<"products_img"> | number | null
    originalUrl?: StringNullableFilter<"products_img"> | string | null
    thumbnailUrl?: StringNullableFilter<"products_img"> | string | null
    productsId?: IntNullableFilter<"products_img"> | number | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
  }, "id" | "origin_id">

  export type products_imgOrderByWithAggregationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    originalUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    productsId?: SortOrderInput | SortOrder
    _count?: products_imgCountOrderByAggregateInput
    _avg?: products_imgAvgOrderByAggregateInput
    _max?: products_imgMaxOrderByAggregateInput
    _min?: products_imgMinOrderByAggregateInput
    _sum?: products_imgSumOrderByAggregateInput
  }

  export type products_imgScalarWhereWithAggregatesInput = {
    AND?: products_imgScalarWhereWithAggregatesInput | products_imgScalarWhereWithAggregatesInput[]
    OR?: products_imgScalarWhereWithAggregatesInput[]
    NOT?: products_imgScalarWhereWithAggregatesInput | products_imgScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"products_img"> | number
    origin_id?: StringNullableWithAggregatesFilter<"products_img"> | string | null
    filename?: StringNullableWithAggregatesFilter<"products_img"> | string | null
    status?: StringNullableWithAggregatesFilter<"products_img"> | string | null
    width?: IntNullableWithAggregatesFilter<"products_img"> | number | null
    height?: IntNullableWithAggregatesFilter<"products_img"> | number | null
    originalUrl?: StringNullableWithAggregatesFilter<"products_img"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"products_img"> | string | null
    productsId?: IntNullableWithAggregatesFilter<"products_img"> | number | null
  }

  export type channelWhereInput = {
    AND?: channelWhereInput | channelWhereInput[]
    OR?: channelWhereInput[]
    NOT?: channelWhereInput | channelWhereInput[]
    id?: IntFilter<"channel"> | number
    name?: StringNullableFilter<"channel"> | string | null
    clientsId?: IntNullableFilter<"channel"> | number | null
    client?: XOR<ClientsNullableScalarRelationFilter, clientsWhereInput> | null
    store?: StoreListRelationFilter
  }

  export type channelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    clientsId?: SortOrderInput | SortOrder
    client?: clientsOrderByWithRelationInput
    store?: storeOrderByRelationAggregateInput
  }

  export type channelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: channelWhereInput | channelWhereInput[]
    OR?: channelWhereInput[]
    NOT?: channelWhereInput | channelWhereInput[]
    clientsId?: IntNullableFilter<"channel"> | number | null
    client?: XOR<ClientsNullableScalarRelationFilter, clientsWhereInput> | null
    store?: StoreListRelationFilter
  }, "id" | "name">

  export type channelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    clientsId?: SortOrderInput | SortOrder
    _count?: channelCountOrderByAggregateInput
    _avg?: channelAvgOrderByAggregateInput
    _max?: channelMaxOrderByAggregateInput
    _min?: channelMinOrderByAggregateInput
    _sum?: channelSumOrderByAggregateInput
  }

  export type channelScalarWhereWithAggregatesInput = {
    AND?: channelScalarWhereWithAggregatesInput | channelScalarWhereWithAggregatesInput[]
    OR?: channelScalarWhereWithAggregatesInput[]
    NOT?: channelScalarWhereWithAggregatesInput | channelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"channel"> | number
    name?: StringNullableWithAggregatesFilter<"channel"> | string | null
    clientsId?: IntNullableWithAggregatesFilter<"channel"> | number | null
  }

  export type storeWhereInput = {
    AND?: storeWhereInput | storeWhereInput[]
    OR?: storeWhereInput[]
    NOT?: storeWhereInput | storeWhereInput[]
    id?: IntFilter<"store"> | number
    name?: StringNullableFilter<"store"> | string | null
    origin_id?: StringNullableFilter<"store"> | string | null
    channelId?: IntNullableFilter<"store"> | number | null
    refresh_token?: StringNullableFilter<"store"> | string | null
    token?: StringNullableFilter<"store"> | string | null
    secondary_refresh_token?: StringNullableFilter<"store"> | string | null
    secondary_token?: StringNullableFilter<"store"> | string | null
    url?: StringNullableFilter<"store"> | string | null
    status?: StringNullableFilter<"store"> | string | null
    omnichat?: OmnichatListRelationFilter
    orders?: OrdersListRelationFilter
    products?: ProductsListRelationFilter
    channel?: XOR<ChannelNullableScalarRelationFilter, channelWhereInput> | null
  }

  export type storeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    secondary_refresh_token?: SortOrderInput | SortOrder
    secondary_token?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    omnichat?: omnichatOrderByRelationAggregateInput
    orders?: ordersOrderByRelationAggregateInput
    products?: productsOrderByRelationAggregateInput
    channel?: channelOrderByWithRelationInput
  }

  export type storeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    AND?: storeWhereInput | storeWhereInput[]
    OR?: storeWhereInput[]
    NOT?: storeWhereInput | storeWhereInput[]
    name?: StringNullableFilter<"store"> | string | null
    channelId?: IntNullableFilter<"store"> | number | null
    refresh_token?: StringNullableFilter<"store"> | string | null
    token?: StringNullableFilter<"store"> | string | null
    secondary_refresh_token?: StringNullableFilter<"store"> | string | null
    secondary_token?: StringNullableFilter<"store"> | string | null
    url?: StringNullableFilter<"store"> | string | null
    status?: StringNullableFilter<"store"> | string | null
    omnichat?: OmnichatListRelationFilter
    orders?: OrdersListRelationFilter
    products?: ProductsListRelationFilter
    channel?: XOR<ChannelNullableScalarRelationFilter, channelWhereInput> | null
  }, "id" | "origin_id">

  export type storeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    refresh_token?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    secondary_refresh_token?: SortOrderInput | SortOrder
    secondary_token?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: storeCountOrderByAggregateInput
    _avg?: storeAvgOrderByAggregateInput
    _max?: storeMaxOrderByAggregateInput
    _min?: storeMinOrderByAggregateInput
    _sum?: storeSumOrderByAggregateInput
  }

  export type storeScalarWhereWithAggregatesInput = {
    AND?: storeScalarWhereWithAggregatesInput | storeScalarWhereWithAggregatesInput[]
    OR?: storeScalarWhereWithAggregatesInput[]
    NOT?: storeScalarWhereWithAggregatesInput | storeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"store"> | number
    name?: StringNullableWithAggregatesFilter<"store"> | string | null
    origin_id?: StringNullableWithAggregatesFilter<"store"> | string | null
    channelId?: IntNullableWithAggregatesFilter<"store"> | number | null
    refresh_token?: StringNullableWithAggregatesFilter<"store"> | string | null
    token?: StringNullableWithAggregatesFilter<"store"> | string | null
    secondary_refresh_token?: StringNullableWithAggregatesFilter<"store"> | string | null
    secondary_token?: StringNullableWithAggregatesFilter<"store"> | string | null
    url?: StringNullableWithAggregatesFilter<"store"> | string | null
    status?: StringNullableWithAggregatesFilter<"store"> | string | null
  }

  export type productsWhereInput = {
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    id?: IntFilter<"products"> | number
    origin_id?: StringNullableFilter<"products"> | string | null
    status?: StringNullableFilter<"products"> | string | null
    name?: StringNullableFilter<"products"> | string | null
    condition?: IntNullableFilter<"products"> | number | null
    desc?: StringNullableFilter<"products"> | string | null
    category?: IntNullableFilter<"products"> | number | null
    price?: IntNullableFilter<"products"> | number | null
    currency?: StringNullableFilter<"products"> | string | null
    createdAt?: DateTimeFilter<"products"> | Date | string
    weight?: IntNullableFilter<"products"> | number | null
    stock?: IntNullableFilter<"products"> | number | null
    sku?: StringNullableFilter<"products"> | string | null
    storeId?: IntNullableFilter<"products"> | number | null
    order_items?: Order_itemsListRelationFilter
    store?: XOR<StoreNullableScalarRelationFilter, storeWhereInput> | null
    product_img?: Products_imgListRelationFilter
  }

  export type productsOrderByWithRelationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    desc?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    weight?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    order_items?: order_itemsOrderByRelationAggregateInput
    store?: storeOrderByWithRelationInput
    product_img?: products_imgOrderByRelationAggregateInput
  }

  export type productsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    status?: StringNullableFilter<"products"> | string | null
    name?: StringNullableFilter<"products"> | string | null
    condition?: IntNullableFilter<"products"> | number | null
    desc?: StringNullableFilter<"products"> | string | null
    category?: IntNullableFilter<"products"> | number | null
    price?: IntNullableFilter<"products"> | number | null
    currency?: StringNullableFilter<"products"> | string | null
    createdAt?: DateTimeFilter<"products"> | Date | string
    weight?: IntNullableFilter<"products"> | number | null
    stock?: IntNullableFilter<"products"> | number | null
    sku?: StringNullableFilter<"products"> | string | null
    storeId?: IntNullableFilter<"products"> | number | null
    order_items?: Order_itemsListRelationFilter
    store?: XOR<StoreNullableScalarRelationFilter, storeWhereInput> | null
    product_img?: Products_imgListRelationFilter
  }, "id" | "origin_id">

  export type productsOrderByWithAggregationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    desc?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    weight?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    _count?: productsCountOrderByAggregateInput
    _avg?: productsAvgOrderByAggregateInput
    _max?: productsMaxOrderByAggregateInput
    _min?: productsMinOrderByAggregateInput
    _sum?: productsSumOrderByAggregateInput
  }

  export type productsScalarWhereWithAggregatesInput = {
    AND?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    OR?: productsScalarWhereWithAggregatesInput[]
    NOT?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"products"> | number
    origin_id?: StringNullableWithAggregatesFilter<"products"> | string | null
    status?: StringNullableWithAggregatesFilter<"products"> | string | null
    name?: StringNullableWithAggregatesFilter<"products"> | string | null
    condition?: IntNullableWithAggregatesFilter<"products"> | number | null
    desc?: StringNullableWithAggregatesFilter<"products"> | string | null
    category?: IntNullableWithAggregatesFilter<"products"> | number | null
    price?: IntNullableWithAggregatesFilter<"products"> | number | null
    currency?: StringNullableWithAggregatesFilter<"products"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"products"> | Date | string
    weight?: IntNullableWithAggregatesFilter<"products"> | number | null
    stock?: IntNullableWithAggregatesFilter<"products"> | number | null
    sku?: StringNullableWithAggregatesFilter<"products"> | string | null
    storeId?: IntNullableWithAggregatesFilter<"products"> | number | null
  }

  export type order_itemsWhereInput = {
    AND?: order_itemsWhereInput | order_itemsWhereInput[]
    OR?: order_itemsWhereInput[]
    NOT?: order_itemsWhereInput | order_itemsWhereInput[]
    id?: IntFilter<"order_items"> | number
    createdAt?: DateTimeFilter<"order_items"> | Date | string
    qty?: IntFilter<"order_items"> | number
    package_id?: StringNullableFilter<"order_items"> | string | null
    invoice?: StringNullableFilter<"order_items"> | string | null
    total_price?: IntFilter<"order_items"> | number
    notes?: StringNullableFilter<"order_items"> | string | null
    ordersId?: IntNullableFilter<"order_items"> | number | null
    productsId?: IntNullableFilter<"order_items"> | number | null
    origin_id?: StringNullableFilter<"order_items"> | string | null
    orders?: XOR<OrdersNullableScalarRelationFilter, ordersWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
    return_line_item?: Return_line_itemListRelationFilter
  }

  export type order_itemsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    qty?: SortOrder
    package_id?: SortOrderInput | SortOrder
    invoice?: SortOrderInput | SortOrder
    total_price?: SortOrder
    notes?: SortOrderInput | SortOrder
    ordersId?: SortOrderInput | SortOrder
    productsId?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    orders?: ordersOrderByWithRelationInput
    products?: productsOrderByWithRelationInput
    return_line_item?: return_line_itemOrderByRelationAggregateInput
  }

  export type order_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    AND?: order_itemsWhereInput | order_itemsWhereInput[]
    OR?: order_itemsWhereInput[]
    NOT?: order_itemsWhereInput | order_itemsWhereInput[]
    createdAt?: DateTimeFilter<"order_items"> | Date | string
    qty?: IntFilter<"order_items"> | number
    package_id?: StringNullableFilter<"order_items"> | string | null
    invoice?: StringNullableFilter<"order_items"> | string | null
    total_price?: IntFilter<"order_items"> | number
    notes?: StringNullableFilter<"order_items"> | string | null
    ordersId?: IntNullableFilter<"order_items"> | number | null
    productsId?: IntNullableFilter<"order_items"> | number | null
    orders?: XOR<OrdersNullableScalarRelationFilter, ordersWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
    return_line_item?: Return_line_itemListRelationFilter
  }, "id" | "origin_id">

  export type order_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    qty?: SortOrder
    package_id?: SortOrderInput | SortOrder
    invoice?: SortOrderInput | SortOrder
    total_price?: SortOrder
    notes?: SortOrderInput | SortOrder
    ordersId?: SortOrderInput | SortOrder
    productsId?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    _count?: order_itemsCountOrderByAggregateInput
    _avg?: order_itemsAvgOrderByAggregateInput
    _max?: order_itemsMaxOrderByAggregateInput
    _min?: order_itemsMinOrderByAggregateInput
    _sum?: order_itemsSumOrderByAggregateInput
  }

  export type order_itemsScalarWhereWithAggregatesInput = {
    AND?: order_itemsScalarWhereWithAggregatesInput | order_itemsScalarWhereWithAggregatesInput[]
    OR?: order_itemsScalarWhereWithAggregatesInput[]
    NOT?: order_itemsScalarWhereWithAggregatesInput | order_itemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"order_items"> | number
    createdAt?: DateTimeWithAggregatesFilter<"order_items"> | Date | string
    qty?: IntWithAggregatesFilter<"order_items"> | number
    package_id?: StringNullableWithAggregatesFilter<"order_items"> | string | null
    invoice?: StringNullableWithAggregatesFilter<"order_items"> | string | null
    total_price?: IntWithAggregatesFilter<"order_items"> | number
    notes?: StringNullableWithAggregatesFilter<"order_items"> | string | null
    ordersId?: IntNullableWithAggregatesFilter<"order_items"> | number | null
    productsId?: IntNullableWithAggregatesFilter<"order_items"> | number | null
    origin_id?: StringNullableWithAggregatesFilter<"order_items"> | string | null
  }

  export type logisticWhereInput = {
    AND?: logisticWhereInput | logisticWhereInput[]
    OR?: logisticWhereInput[]
    NOT?: logisticWhereInput | logisticWhereInput[]
    id?: IntFilter<"logistic"> | number
    name?: StringNullableFilter<"logistic"> | string | null
    type?: StringNullableFilter<"logistic"> | string | null
    orders?: OrdersListRelationFilter
  }

  export type logisticOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    orders?: ordersOrderByRelationAggregateInput
  }

  export type logisticWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: logisticWhereInput | logisticWhereInput[]
    OR?: logisticWhereInput[]
    NOT?: logisticWhereInput | logisticWhereInput[]
    type?: StringNullableFilter<"logistic"> | string | null
    orders?: OrdersListRelationFilter
  }, "id" | "name">

  export type logisticOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: logisticCountOrderByAggregateInput
    _avg?: logisticAvgOrderByAggregateInput
    _max?: logisticMaxOrderByAggregateInput
    _min?: logisticMinOrderByAggregateInput
    _sum?: logisticSumOrderByAggregateInput
  }

  export type logisticScalarWhereWithAggregatesInput = {
    AND?: logisticScalarWhereWithAggregatesInput | logisticScalarWhereWithAggregatesInput[]
    OR?: logisticScalarWhereWithAggregatesInput[]
    NOT?: logisticScalarWhereWithAggregatesInput | logisticScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"logistic"> | number
    name?: StringNullableWithAggregatesFilter<"logistic"> | string | null
    type?: StringNullableWithAggregatesFilter<"logistic"> | string | null
  }

  export type ordersWhereInput = {
    AND?: ordersWhereInput | ordersWhereInput[]
    OR?: ordersWhereInput[]
    NOT?: ordersWhereInput | ordersWhereInput[]
    id?: IntFilter<"orders"> | number
    createdAt?: DateTimeFilter<"orders"> | Date | string
    status?: StringNullableFilter<"orders"> | string | null
    shop_id?: StringNullableFilter<"orders"> | string | null
    payment_id?: StringNullableFilter<"orders"> | string | null
    temp_id?: StringNullableFilter<"orders"> | string | null
    origin_id?: StringNullableFilter<"orders"> | string | null
    package_id?: StringNullableFilter<"orders"> | string | null
    invoice?: StringNullableFilter<"orders"> | string | null
    recp_name?: StringNullableFilter<"orders"> | string | null
    recp_phone?: StringNullableFilter<"orders"> | string | null
    recp_addr_full?: StringNullableFilter<"orders"> | string | null
    recp_addr_district?: StringNullableFilter<"orders"> | string | null
    recp_addr_city?: StringNullableFilter<"orders"> | string | null
    recp_addr_province?: StringNullableFilter<"orders"> | string | null
    recp_addr_country?: StringNullableFilter<"orders"> | string | null
    recp_addr_postal_code?: StringNullableFilter<"orders"> | string | null
    recp_addr_district_id?: StringNullableFilter<"orders"> | string | null
    recp_addr_city_id?: StringNullableFilter<"orders"> | string | null
    tracking_number?: StringNullableFilter<"orders"> | string | null
    ship_document_url?: StringNullableFilter<"orders"> | string | null
    recp_addr_province_id?: StringNullableFilter<"orders"> | string | null
    recp_addr_geo?: StringNullableFilter<"orders"> | string | null
    logistic_service?: StringNullableFilter<"orders"> | string | null
    origin_createdAt?: DateTimeFilter<"orders"> | Date | string
    accept_partial?: BoolNullableFilter<"orders"> | boolean | null
    device?: StringNullableFilter<"orders"> | string | null
    storeId?: IntNullableFilter<"orders"> | number | null
    customersId?: IntNullableFilter<"orders"> | number | null
    logisticId?: IntNullableFilter<"orders"> | number | null
    total_product_price?: IntNullableFilter<"orders"> | number | null
    shipping_price?: IntNullableFilter<"orders"> | number | null
    seller_discount?: IntNullableFilter<"orders"> | number | null
    platform_discount?: IntNullableFilter<"orders"> | number | null
    shipping_seller_discount?: IntNullableFilter<"orders"> | number | null
    shipping_platform_discount?: IntNullableFilter<"orders"> | number | null
    buyer_service_fee?: IntNullableFilter<"orders"> | number | null
    handling_fee?: IntNullableFilter<"orders"> | number | null
    shipping_insurance_fee?: IntNullableFilter<"orders"> | number | null
    item_insurance_fee?: IntNullableFilter<"orders"> | number | null
    total_amount?: IntNullableFilter<"orders"> | number | null
    updatedAt?: DateTimeFilter<"orders"> | Date | string
    order_items?: Order_itemsListRelationFilter
    customers?: XOR<CustomersNullableScalarRelationFilter, customersWhereInput> | null
    logistic?: XOR<LogisticNullableScalarRelationFilter, logisticWhereInput> | null
    store?: XOR<StoreNullableScalarRelationFilter, storeWhereInput> | null
    return_refund?: XOR<Return_refundNullableScalarRelationFilter, return_refundWhereInput> | null
  }

  export type ordersOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrderInput | SortOrder
    shop_id?: SortOrderInput | SortOrder
    payment_id?: SortOrderInput | SortOrder
    temp_id?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    package_id?: SortOrderInput | SortOrder
    invoice?: SortOrderInput | SortOrder
    recp_name?: SortOrderInput | SortOrder
    recp_phone?: SortOrderInput | SortOrder
    recp_addr_full?: SortOrderInput | SortOrder
    recp_addr_district?: SortOrderInput | SortOrder
    recp_addr_city?: SortOrderInput | SortOrder
    recp_addr_province?: SortOrderInput | SortOrder
    recp_addr_country?: SortOrderInput | SortOrder
    recp_addr_postal_code?: SortOrderInput | SortOrder
    recp_addr_district_id?: SortOrderInput | SortOrder
    recp_addr_city_id?: SortOrderInput | SortOrder
    tracking_number?: SortOrderInput | SortOrder
    ship_document_url?: SortOrderInput | SortOrder
    recp_addr_province_id?: SortOrderInput | SortOrder
    recp_addr_geo?: SortOrderInput | SortOrder
    logistic_service?: SortOrderInput | SortOrder
    origin_createdAt?: SortOrder
    accept_partial?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    customersId?: SortOrderInput | SortOrder
    logisticId?: SortOrderInput | SortOrder
    total_product_price?: SortOrderInput | SortOrder
    shipping_price?: SortOrderInput | SortOrder
    seller_discount?: SortOrderInput | SortOrder
    platform_discount?: SortOrderInput | SortOrder
    shipping_seller_discount?: SortOrderInput | SortOrder
    shipping_platform_discount?: SortOrderInput | SortOrder
    buyer_service_fee?: SortOrderInput | SortOrder
    handling_fee?: SortOrderInput | SortOrder
    shipping_insurance_fee?: SortOrderInput | SortOrder
    item_insurance_fee?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    order_items?: order_itemsOrderByRelationAggregateInput
    customers?: customersOrderByWithRelationInput
    logistic?: logisticOrderByWithRelationInput
    store?: storeOrderByWithRelationInput
    return_refund?: return_refundOrderByWithRelationInput
  }

  export type ordersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    AND?: ordersWhereInput | ordersWhereInput[]
    OR?: ordersWhereInput[]
    NOT?: ordersWhereInput | ordersWhereInput[]
    createdAt?: DateTimeFilter<"orders"> | Date | string
    status?: StringNullableFilter<"orders"> | string | null
    shop_id?: StringNullableFilter<"orders"> | string | null
    payment_id?: StringNullableFilter<"orders"> | string | null
    temp_id?: StringNullableFilter<"orders"> | string | null
    package_id?: StringNullableFilter<"orders"> | string | null
    invoice?: StringNullableFilter<"orders"> | string | null
    recp_name?: StringNullableFilter<"orders"> | string | null
    recp_phone?: StringNullableFilter<"orders"> | string | null
    recp_addr_full?: StringNullableFilter<"orders"> | string | null
    recp_addr_district?: StringNullableFilter<"orders"> | string | null
    recp_addr_city?: StringNullableFilter<"orders"> | string | null
    recp_addr_province?: StringNullableFilter<"orders"> | string | null
    recp_addr_country?: StringNullableFilter<"orders"> | string | null
    recp_addr_postal_code?: StringNullableFilter<"orders"> | string | null
    recp_addr_district_id?: StringNullableFilter<"orders"> | string | null
    recp_addr_city_id?: StringNullableFilter<"orders"> | string | null
    tracking_number?: StringNullableFilter<"orders"> | string | null
    ship_document_url?: StringNullableFilter<"orders"> | string | null
    recp_addr_province_id?: StringNullableFilter<"orders"> | string | null
    recp_addr_geo?: StringNullableFilter<"orders"> | string | null
    logistic_service?: StringNullableFilter<"orders"> | string | null
    origin_createdAt?: DateTimeFilter<"orders"> | Date | string
    accept_partial?: BoolNullableFilter<"orders"> | boolean | null
    device?: StringNullableFilter<"orders"> | string | null
    storeId?: IntNullableFilter<"orders"> | number | null
    customersId?: IntNullableFilter<"orders"> | number | null
    logisticId?: IntNullableFilter<"orders"> | number | null
    total_product_price?: IntNullableFilter<"orders"> | number | null
    shipping_price?: IntNullableFilter<"orders"> | number | null
    seller_discount?: IntNullableFilter<"orders"> | number | null
    platform_discount?: IntNullableFilter<"orders"> | number | null
    shipping_seller_discount?: IntNullableFilter<"orders"> | number | null
    shipping_platform_discount?: IntNullableFilter<"orders"> | number | null
    buyer_service_fee?: IntNullableFilter<"orders"> | number | null
    handling_fee?: IntNullableFilter<"orders"> | number | null
    shipping_insurance_fee?: IntNullableFilter<"orders"> | number | null
    item_insurance_fee?: IntNullableFilter<"orders"> | number | null
    total_amount?: IntNullableFilter<"orders"> | number | null
    updatedAt?: DateTimeFilter<"orders"> | Date | string
    order_items?: Order_itemsListRelationFilter
    customers?: XOR<CustomersNullableScalarRelationFilter, customersWhereInput> | null
    logistic?: XOR<LogisticNullableScalarRelationFilter, logisticWhereInput> | null
    store?: XOR<StoreNullableScalarRelationFilter, storeWhereInput> | null
    return_refund?: XOR<Return_refundNullableScalarRelationFilter, return_refundWhereInput> | null
  }, "id" | "origin_id">

  export type ordersOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrderInput | SortOrder
    shop_id?: SortOrderInput | SortOrder
    payment_id?: SortOrderInput | SortOrder
    temp_id?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    package_id?: SortOrderInput | SortOrder
    invoice?: SortOrderInput | SortOrder
    recp_name?: SortOrderInput | SortOrder
    recp_phone?: SortOrderInput | SortOrder
    recp_addr_full?: SortOrderInput | SortOrder
    recp_addr_district?: SortOrderInput | SortOrder
    recp_addr_city?: SortOrderInput | SortOrder
    recp_addr_province?: SortOrderInput | SortOrder
    recp_addr_country?: SortOrderInput | SortOrder
    recp_addr_postal_code?: SortOrderInput | SortOrder
    recp_addr_district_id?: SortOrderInput | SortOrder
    recp_addr_city_id?: SortOrderInput | SortOrder
    tracking_number?: SortOrderInput | SortOrder
    ship_document_url?: SortOrderInput | SortOrder
    recp_addr_province_id?: SortOrderInput | SortOrder
    recp_addr_geo?: SortOrderInput | SortOrder
    logistic_service?: SortOrderInput | SortOrder
    origin_createdAt?: SortOrder
    accept_partial?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    storeId?: SortOrderInput | SortOrder
    customersId?: SortOrderInput | SortOrder
    logisticId?: SortOrderInput | SortOrder
    total_product_price?: SortOrderInput | SortOrder
    shipping_price?: SortOrderInput | SortOrder
    seller_discount?: SortOrderInput | SortOrder
    platform_discount?: SortOrderInput | SortOrder
    shipping_seller_discount?: SortOrderInput | SortOrder
    shipping_platform_discount?: SortOrderInput | SortOrder
    buyer_service_fee?: SortOrderInput | SortOrder
    handling_fee?: SortOrderInput | SortOrder
    shipping_insurance_fee?: SortOrderInput | SortOrder
    item_insurance_fee?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: ordersCountOrderByAggregateInput
    _avg?: ordersAvgOrderByAggregateInput
    _max?: ordersMaxOrderByAggregateInput
    _min?: ordersMinOrderByAggregateInput
    _sum?: ordersSumOrderByAggregateInput
  }

  export type ordersScalarWhereWithAggregatesInput = {
    AND?: ordersScalarWhereWithAggregatesInput | ordersScalarWhereWithAggregatesInput[]
    OR?: ordersScalarWhereWithAggregatesInput[]
    NOT?: ordersScalarWhereWithAggregatesInput | ordersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"orders"> | number
    createdAt?: DateTimeWithAggregatesFilter<"orders"> | Date | string
    status?: StringNullableWithAggregatesFilter<"orders"> | string | null
    shop_id?: StringNullableWithAggregatesFilter<"orders"> | string | null
    payment_id?: StringNullableWithAggregatesFilter<"orders"> | string | null
    temp_id?: StringNullableWithAggregatesFilter<"orders"> | string | null
    origin_id?: StringNullableWithAggregatesFilter<"orders"> | string | null
    package_id?: StringNullableWithAggregatesFilter<"orders"> | string | null
    invoice?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_name?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_phone?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_addr_full?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_addr_district?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_addr_city?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_addr_province?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_addr_country?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_addr_postal_code?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_addr_district_id?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_addr_city_id?: StringNullableWithAggregatesFilter<"orders"> | string | null
    tracking_number?: StringNullableWithAggregatesFilter<"orders"> | string | null
    ship_document_url?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_addr_province_id?: StringNullableWithAggregatesFilter<"orders"> | string | null
    recp_addr_geo?: StringNullableWithAggregatesFilter<"orders"> | string | null
    logistic_service?: StringNullableWithAggregatesFilter<"orders"> | string | null
    origin_createdAt?: DateTimeWithAggregatesFilter<"orders"> | Date | string
    accept_partial?: BoolNullableWithAggregatesFilter<"orders"> | boolean | null
    device?: StringNullableWithAggregatesFilter<"orders"> | string | null
    storeId?: IntNullableWithAggregatesFilter<"orders"> | number | null
    customersId?: IntNullableWithAggregatesFilter<"orders"> | number | null
    logisticId?: IntNullableWithAggregatesFilter<"orders"> | number | null
    total_product_price?: IntNullableWithAggregatesFilter<"orders"> | number | null
    shipping_price?: IntNullableWithAggregatesFilter<"orders"> | number | null
    seller_discount?: IntNullableWithAggregatesFilter<"orders"> | number | null
    platform_discount?: IntNullableWithAggregatesFilter<"orders"> | number | null
    shipping_seller_discount?: IntNullableWithAggregatesFilter<"orders"> | number | null
    shipping_platform_discount?: IntNullableWithAggregatesFilter<"orders"> | number | null
    buyer_service_fee?: IntNullableWithAggregatesFilter<"orders"> | number | null
    handling_fee?: IntNullableWithAggregatesFilter<"orders"> | number | null
    shipping_insurance_fee?: IntNullableWithAggregatesFilter<"orders"> | number | null
    item_insurance_fee?: IntNullableWithAggregatesFilter<"orders"> | number | null
    total_amount?: IntNullableWithAggregatesFilter<"orders"> | number | null
    updatedAt?: DateTimeWithAggregatesFilter<"orders"> | Date | string
  }

  export type omnichat_userWhereInput = {
    AND?: omnichat_userWhereInput | omnichat_userWhereInput[]
    OR?: omnichat_userWhereInput[]
    NOT?: omnichat_userWhereInput | omnichat_userWhereInput[]
    id?: IntFilter<"omnichat_user"> | number
    username?: StringNullableFilter<"omnichat_user"> | string | null
    thumbnailUrl?: StringNullableFilter<"omnichat_user"> | string | null
    origin_id?: StringNullableFilter<"omnichat_user"> | string | null
    createdAt?: DateTimeFilter<"omnichat_user"> | Date | string
    externalId?: StringNullableFilter<"omnichat_user"> | string | null
    omnichat?: OmnichatListRelationFilter
    omnichat_line?: Omnichat_lineListRelationFilter
  }

  export type omnichat_userOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    externalId?: SortOrderInput | SortOrder
    omnichat?: omnichatOrderByRelationAggregateInput
    omnichat_line?: omnichat_lineOrderByRelationAggregateInput
  }

  export type omnichat_userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    AND?: omnichat_userWhereInput | omnichat_userWhereInput[]
    OR?: omnichat_userWhereInput[]
    NOT?: omnichat_userWhereInput | omnichat_userWhereInput[]
    username?: StringNullableFilter<"omnichat_user"> | string | null
    thumbnailUrl?: StringNullableFilter<"omnichat_user"> | string | null
    createdAt?: DateTimeFilter<"omnichat_user"> | Date | string
    externalId?: StringNullableFilter<"omnichat_user"> | string | null
    omnichat?: OmnichatListRelationFilter
    omnichat_line?: Omnichat_lineListRelationFilter
  }, "id" | "origin_id">

  export type omnichat_userOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    origin_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    externalId?: SortOrderInput | SortOrder
    _count?: omnichat_userCountOrderByAggregateInput
    _avg?: omnichat_userAvgOrderByAggregateInput
    _max?: omnichat_userMaxOrderByAggregateInput
    _min?: omnichat_userMinOrderByAggregateInput
    _sum?: omnichat_userSumOrderByAggregateInput
  }

  export type omnichat_userScalarWhereWithAggregatesInput = {
    AND?: omnichat_userScalarWhereWithAggregatesInput | omnichat_userScalarWhereWithAggregatesInput[]
    OR?: omnichat_userScalarWhereWithAggregatesInput[]
    NOT?: omnichat_userScalarWhereWithAggregatesInput | omnichat_userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"omnichat_user"> | number
    username?: StringNullableWithAggregatesFilter<"omnichat_user"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"omnichat_user"> | string | null
    origin_id?: StringNullableWithAggregatesFilter<"omnichat_user"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"omnichat_user"> | Date | string
    externalId?: StringNullableWithAggregatesFilter<"omnichat_user"> | string | null
  }

  export type omnichatWhereInput = {
    AND?: omnichatWhereInput | omnichatWhereInput[]
    OR?: omnichatWhereInput[]
    NOT?: omnichatWhereInput | omnichatWhereInput[]
    id?: IntFilter<"omnichat"> | number
    origin_id?: StringNullableFilter<"omnichat"> | string | null
    last_message?: StringFilter<"omnichat"> | string
    last_messageId?: StringNullableFilter<"omnichat"> | string | null
    createdAt?: DateTimeFilter<"omnichat"> | Date | string
    updatedAt?: DateTimeFilter<"omnichat"> | Date | string
    storeId?: IntNullableFilter<"omnichat"> | number | null
    omnichat_userId?: IntNullableFilter<"omnichat"> | number | null
    externalId?: StringNullableFilter<"omnichat"> | string | null
    omnichat_user?: XOR<Omnichat_userNullableScalarRelationFilter, omnichat_userWhereInput> | null
    store?: XOR<StoreNullableScalarRelationFilter, storeWhereInput> | null
    messages?: Omnichat_lineListRelationFilter
  }

  export type omnichatOrderByWithRelationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    last_message?: SortOrder
    last_messageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrderInput | SortOrder
    omnichat_userId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    omnichat_user?: omnichat_userOrderByWithRelationInput
    store?: storeOrderByWithRelationInput
    messages?: omnichat_lineOrderByRelationAggregateInput
  }

  export type omnichatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    AND?: omnichatWhereInput | omnichatWhereInput[]
    OR?: omnichatWhereInput[]
    NOT?: omnichatWhereInput | omnichatWhereInput[]
    last_message?: StringFilter<"omnichat"> | string
    last_messageId?: StringNullableFilter<"omnichat"> | string | null
    createdAt?: DateTimeFilter<"omnichat"> | Date | string
    updatedAt?: DateTimeFilter<"omnichat"> | Date | string
    storeId?: IntNullableFilter<"omnichat"> | number | null
    omnichat_userId?: IntNullableFilter<"omnichat"> | number | null
    externalId?: StringNullableFilter<"omnichat"> | string | null
    omnichat_user?: XOR<Omnichat_userNullableScalarRelationFilter, omnichat_userWhereInput> | null
    store?: XOR<StoreNullableScalarRelationFilter, storeWhereInput> | null
    messages?: Omnichat_lineListRelationFilter
  }, "id" | "origin_id">

  export type omnichatOrderByWithAggregationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    last_message?: SortOrder
    last_messageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrderInput | SortOrder
    omnichat_userId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    _count?: omnichatCountOrderByAggregateInput
    _avg?: omnichatAvgOrderByAggregateInput
    _max?: omnichatMaxOrderByAggregateInput
    _min?: omnichatMinOrderByAggregateInput
    _sum?: omnichatSumOrderByAggregateInput
  }

  export type omnichatScalarWhereWithAggregatesInput = {
    AND?: omnichatScalarWhereWithAggregatesInput | omnichatScalarWhereWithAggregatesInput[]
    OR?: omnichatScalarWhereWithAggregatesInput[]
    NOT?: omnichatScalarWhereWithAggregatesInput | omnichatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"omnichat"> | number
    origin_id?: StringNullableWithAggregatesFilter<"omnichat"> | string | null
    last_message?: StringWithAggregatesFilter<"omnichat"> | string
    last_messageId?: StringNullableWithAggregatesFilter<"omnichat"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"omnichat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"omnichat"> | Date | string
    storeId?: IntNullableWithAggregatesFilter<"omnichat"> | number | null
    omnichat_userId?: IntNullableWithAggregatesFilter<"omnichat"> | number | null
    externalId?: StringNullableWithAggregatesFilter<"omnichat"> | string | null
  }

  export type omnichat_lineWhereInput = {
    AND?: omnichat_lineWhereInput | omnichat_lineWhereInput[]
    OR?: omnichat_lineWhereInput[]
    NOT?: omnichat_lineWhereInput | omnichat_lineWhereInput[]
    id?: IntFilter<"omnichat_line"> | number
    origin_id?: StringNullableFilter<"omnichat_line"> | string | null
    createdAt?: DateTimeFilter<"omnichat_line"> | Date | string
    line_text?: StringFilter<"omnichat_line"> | string
    omnichatId?: IntNullableFilter<"omnichat_line"> | number | null
    author?: StringNullableFilter<"omnichat_line"> | string | null
    omnichat_userId?: IntNullableFilter<"omnichat_line"> | number | null
    chat_type?: StringNullableFilter<"omnichat_line"> | string | null
    omnichat?: XOR<OmnichatNullableScalarRelationFilter, omnichatWhereInput> | null
    omnichat_user?: XOR<Omnichat_userNullableScalarRelationFilter, omnichat_userWhereInput> | null
  }

  export type omnichat_lineOrderByWithRelationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    line_text?: SortOrder
    omnichatId?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    omnichat_userId?: SortOrderInput | SortOrder
    chat_type?: SortOrderInput | SortOrder
    omnichat?: omnichatOrderByWithRelationInput
    omnichat_user?: omnichat_userOrderByWithRelationInput
  }

  export type omnichat_lineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    AND?: omnichat_lineWhereInput | omnichat_lineWhereInput[]
    OR?: omnichat_lineWhereInput[]
    NOT?: omnichat_lineWhereInput | omnichat_lineWhereInput[]
    createdAt?: DateTimeFilter<"omnichat_line"> | Date | string
    line_text?: StringFilter<"omnichat_line"> | string
    omnichatId?: IntNullableFilter<"omnichat_line"> | number | null
    author?: StringNullableFilter<"omnichat_line"> | string | null
    omnichat_userId?: IntNullableFilter<"omnichat_line"> | number | null
    chat_type?: StringNullableFilter<"omnichat_line"> | string | null
    omnichat?: XOR<OmnichatNullableScalarRelationFilter, omnichatWhereInput> | null
    omnichat_user?: XOR<Omnichat_userNullableScalarRelationFilter, omnichat_userWhereInput> | null
  }, "id" | "origin_id">

  export type omnichat_lineOrderByWithAggregationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    line_text?: SortOrder
    omnichatId?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    omnichat_userId?: SortOrderInput | SortOrder
    chat_type?: SortOrderInput | SortOrder
    _count?: omnichat_lineCountOrderByAggregateInput
    _avg?: omnichat_lineAvgOrderByAggregateInput
    _max?: omnichat_lineMaxOrderByAggregateInput
    _min?: omnichat_lineMinOrderByAggregateInput
    _sum?: omnichat_lineSumOrderByAggregateInput
  }

  export type omnichat_lineScalarWhereWithAggregatesInput = {
    AND?: omnichat_lineScalarWhereWithAggregatesInput | omnichat_lineScalarWhereWithAggregatesInput[]
    OR?: omnichat_lineScalarWhereWithAggregatesInput[]
    NOT?: omnichat_lineScalarWhereWithAggregatesInput | omnichat_lineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"omnichat_line"> | number
    origin_id?: StringNullableWithAggregatesFilter<"omnichat_line"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"omnichat_line"> | Date | string
    line_text?: StringWithAggregatesFilter<"omnichat_line"> | string
    omnichatId?: IntNullableWithAggregatesFilter<"omnichat_line"> | number | null
    author?: StringNullableWithAggregatesFilter<"omnichat_line"> | string | null
    omnichat_userId?: IntNullableWithAggregatesFilter<"omnichat_line"> | number | null
    chat_type?: StringNullableWithAggregatesFilter<"omnichat_line"> | string | null
  }

  export type zdconnectorWhereInput = {
    AND?: zdconnectorWhereInput | zdconnectorWhereInput[]
    OR?: zdconnectorWhereInput[]
    NOT?: zdconnectorWhereInput | zdconnectorWhereInput[]
    id?: IntFilter<"zdconnector"> | number
    name?: StringFilter<"zdconnector"> | string
    host?: StringFilter<"zdconnector"> | string
    createdAt?: DateTimeFilter<"zdconnector"> | Date | string
    updatedAt?: DateTimeFilter<"zdconnector"> | Date | string
    suncoAppId?: StringFilter<"zdconnector"> | string
    suncoAppKey?: StringFilter<"zdconnector"> | string
    suncoAppSecret?: StringFilter<"zdconnector"> | string
    zdAPIToken?: StringFilter<"zdconnector"> | string
    resource?: StringNullableFilter<"zdconnector"> | string | null
    clientsId?: IntNullableFilter<"zdconnector"> | number | null
  }

  export type zdconnectorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    host?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suncoAppId?: SortOrder
    suncoAppKey?: SortOrder
    suncoAppSecret?: SortOrder
    zdAPIToken?: SortOrder
    resource?: SortOrderInput | SortOrder
    clientsId?: SortOrderInput | SortOrder
  }

  export type zdconnectorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    host?: string
    AND?: zdconnectorWhereInput | zdconnectorWhereInput[]
    OR?: zdconnectorWhereInput[]
    NOT?: zdconnectorWhereInput | zdconnectorWhereInput[]
    name?: StringFilter<"zdconnector"> | string
    createdAt?: DateTimeFilter<"zdconnector"> | Date | string
    updatedAt?: DateTimeFilter<"zdconnector"> | Date | string
    suncoAppId?: StringFilter<"zdconnector"> | string
    suncoAppKey?: StringFilter<"zdconnector"> | string
    suncoAppSecret?: StringFilter<"zdconnector"> | string
    zdAPIToken?: StringFilter<"zdconnector"> | string
    resource?: StringNullableFilter<"zdconnector"> | string | null
    clientsId?: IntNullableFilter<"zdconnector"> | number | null
  }, "id" | "host">

  export type zdconnectorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    host?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suncoAppId?: SortOrder
    suncoAppKey?: SortOrder
    suncoAppSecret?: SortOrder
    zdAPIToken?: SortOrder
    resource?: SortOrderInput | SortOrder
    clientsId?: SortOrderInput | SortOrder
    _count?: zdconnectorCountOrderByAggregateInput
    _avg?: zdconnectorAvgOrderByAggregateInput
    _max?: zdconnectorMaxOrderByAggregateInput
    _min?: zdconnectorMinOrderByAggregateInput
    _sum?: zdconnectorSumOrderByAggregateInput
  }

  export type zdconnectorScalarWhereWithAggregatesInput = {
    AND?: zdconnectorScalarWhereWithAggregatesInput | zdconnectorScalarWhereWithAggregatesInput[]
    OR?: zdconnectorScalarWhereWithAggregatesInput[]
    NOT?: zdconnectorScalarWhereWithAggregatesInput | zdconnectorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"zdconnector"> | number
    name?: StringWithAggregatesFilter<"zdconnector"> | string
    host?: StringWithAggregatesFilter<"zdconnector"> | string
    createdAt?: DateTimeWithAggregatesFilter<"zdconnector"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"zdconnector"> | Date | string
    suncoAppId?: StringWithAggregatesFilter<"zdconnector"> | string
    suncoAppKey?: StringWithAggregatesFilter<"zdconnector"> | string
    suncoAppSecret?: StringWithAggregatesFilter<"zdconnector"> | string
    zdAPIToken?: StringWithAggregatesFilter<"zdconnector"> | string
    resource?: StringNullableWithAggregatesFilter<"zdconnector"> | string | null
    clientsId?: IntNullableWithAggregatesFilter<"zdconnector"> | number | null
  }

  export type omnicrmWhereInput = {
    AND?: omnicrmWhereInput | omnicrmWhereInput[]
    OR?: omnicrmWhereInput[]
    NOT?: omnicrmWhereInput | omnicrmWhereInput[]
    id?: IntFilter<"omnicrm"> | number
    createdAt?: DateTimeFilter<"omnicrm"> | Date | string
    updatedAt?: DateTimeFilter<"omnicrm"> | Date | string
    name?: StringNullableFilter<"omnicrm"> | string | null
    type?: StringNullableFilter<"omnicrm"> | string | null
  }

  export type omnicrmOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
  }

  export type omnicrmWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: omnicrmWhereInput | omnicrmWhereInput[]
    OR?: omnicrmWhereInput[]
    NOT?: omnicrmWhereInput | omnicrmWhereInput[]
    createdAt?: DateTimeFilter<"omnicrm"> | Date | string
    updatedAt?: DateTimeFilter<"omnicrm"> | Date | string
    name?: StringNullableFilter<"omnicrm"> | string | null
    type?: StringNullableFilter<"omnicrm"> | string | null
  }, "id">

  export type omnicrmOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: omnicrmCountOrderByAggregateInput
    _avg?: omnicrmAvgOrderByAggregateInput
    _max?: omnicrmMaxOrderByAggregateInput
    _min?: omnicrmMinOrderByAggregateInput
    _sum?: omnicrmSumOrderByAggregateInput
  }

  export type omnicrmScalarWhereWithAggregatesInput = {
    AND?: omnicrmScalarWhereWithAggregatesInput | omnicrmScalarWhereWithAggregatesInput[]
    OR?: omnicrmScalarWhereWithAggregatesInput[]
    NOT?: omnicrmScalarWhereWithAggregatesInput | omnicrmScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"omnicrm"> | number
    createdAt?: DateTimeWithAggregatesFilter<"omnicrm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"omnicrm"> | Date | string
    name?: StringNullableWithAggregatesFilter<"omnicrm"> | string | null
    type?: StringNullableWithAggregatesFilter<"omnicrm"> | string | null
  }

  export type clientsWhereInput = {
    AND?: clientsWhereInput | clientsWhereInput[]
    OR?: clientsWhereInput[]
    NOT?: clientsWhereInput | clientsWhereInput[]
    id?: IntFilter<"clients"> | number
    name?: StringFilter<"clients"> | string
    origin_id?: StringNullableFilter<"clients"> | string | null
    channel?: ChannelListRelationFilter
    integration?: IntegrationListRelationFilter
  }

  export type clientsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    channel?: channelOrderByRelationAggregateInput
    integration?: integrationOrderByRelationAggregateInput
  }

  export type clientsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    AND?: clientsWhereInput | clientsWhereInput[]
    OR?: clientsWhereInput[]
    NOT?: clientsWhereInput | clientsWhereInput[]
    name?: StringFilter<"clients"> | string
    channel?: ChannelListRelationFilter
    integration?: IntegrationListRelationFilter
  }, "id" | "origin_id">

  export type clientsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    _count?: clientsCountOrderByAggregateInput
    _avg?: clientsAvgOrderByAggregateInput
    _max?: clientsMaxOrderByAggregateInput
    _min?: clientsMinOrderByAggregateInput
    _sum?: clientsSumOrderByAggregateInput
  }

  export type clientsScalarWhereWithAggregatesInput = {
    AND?: clientsScalarWhereWithAggregatesInput | clientsScalarWhereWithAggregatesInput[]
    OR?: clientsScalarWhereWithAggregatesInput[]
    NOT?: clientsScalarWhereWithAggregatesInput | clientsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"clients"> | number
    name?: StringWithAggregatesFilter<"clients"> | string
    origin_id?: StringNullableWithAggregatesFilter<"clients"> | string | null
  }

  export type credentWhereInput = {
    AND?: credentWhereInput | credentWhereInput[]
    OR?: credentWhereInput[]
    NOT?: credentWhereInput | credentWhereInput[]
    id?: IntFilter<"credent"> | number
    key?: StringNullableFilter<"credent"> | string | null
    value?: StringNullableFilter<"credent"> | string | null
    integrationId?: IntNullableFilter<"credent"> | number | null
    integration?: XOR<IntegrationNullableScalarRelationFilter, integrationWhereInput> | null
  }

  export type credentOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    integrationId?: SortOrderInput | SortOrder
    integration?: integrationOrderByWithRelationInput
  }

  export type credentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: credentWhereInput | credentWhereInput[]
    OR?: credentWhereInput[]
    NOT?: credentWhereInput | credentWhereInput[]
    key?: StringNullableFilter<"credent"> | string | null
    value?: StringNullableFilter<"credent"> | string | null
    integrationId?: IntNullableFilter<"credent"> | number | null
    integration?: XOR<IntegrationNullableScalarRelationFilter, integrationWhereInput> | null
  }, "id">

  export type credentOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    integrationId?: SortOrderInput | SortOrder
    _count?: credentCountOrderByAggregateInput
    _avg?: credentAvgOrderByAggregateInput
    _max?: credentMaxOrderByAggregateInput
    _min?: credentMinOrderByAggregateInput
    _sum?: credentSumOrderByAggregateInput
  }

  export type credentScalarWhereWithAggregatesInput = {
    AND?: credentScalarWhereWithAggregatesInput | credentScalarWhereWithAggregatesInput[]
    OR?: credentScalarWhereWithAggregatesInput[]
    NOT?: credentScalarWhereWithAggregatesInput | credentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"credent"> | number
    key?: StringNullableWithAggregatesFilter<"credent"> | string | null
    value?: StringNullableWithAggregatesFilter<"credent"> | string | null
    integrationId?: IntNullableWithAggregatesFilter<"credent"> | number | null
  }

  export type integrationWhereInput = {
    AND?: integrationWhereInput | integrationWhereInput[]
    OR?: integrationWhereInput[]
    NOT?: integrationWhereInput | integrationWhereInput[]
    id?: IntFilter<"integration"> | number
    name?: StringNullableFilter<"integration"> | string | null
    baseUrl?: StringNullableFilter<"integration"> | string | null
    f_chat?: BoolNullableFilter<"integration"> | boolean | null
    f_review?: BoolNullableFilter<"integration"> | boolean | null
    f_cancel?: BoolNullableFilter<"integration"> | boolean | null
    f_rr?: BoolNullableFilter<"integration"> | boolean | null
    status?: StringNullableFilter<"integration"> | string | null
    notes?: StringNullableFilter<"integration"> | string | null
    clientsId?: IntNullableFilter<"integration"> | number | null
    credent?: CredentListRelationFilter
    clients?: XOR<ClientsNullableScalarRelationFilter, clientsWhereInput> | null
  }

  export type integrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    f_chat?: SortOrderInput | SortOrder
    f_review?: SortOrderInput | SortOrder
    f_cancel?: SortOrderInput | SortOrder
    f_rr?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    clientsId?: SortOrderInput | SortOrder
    credent?: credentOrderByRelationAggregateInput
    clients?: clientsOrderByWithRelationInput
  }

  export type integrationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    baseUrl?: string
    AND?: integrationWhereInput | integrationWhereInput[]
    OR?: integrationWhereInput[]
    NOT?: integrationWhereInput | integrationWhereInput[]
    name?: StringNullableFilter<"integration"> | string | null
    f_chat?: BoolNullableFilter<"integration"> | boolean | null
    f_review?: BoolNullableFilter<"integration"> | boolean | null
    f_cancel?: BoolNullableFilter<"integration"> | boolean | null
    f_rr?: BoolNullableFilter<"integration"> | boolean | null
    status?: StringNullableFilter<"integration"> | string | null
    notes?: StringNullableFilter<"integration"> | string | null
    clientsId?: IntNullableFilter<"integration"> | number | null
    credent?: CredentListRelationFilter
    clients?: XOR<ClientsNullableScalarRelationFilter, clientsWhereInput> | null
  }, "id" | "baseUrl">

  export type integrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    f_chat?: SortOrderInput | SortOrder
    f_review?: SortOrderInput | SortOrder
    f_cancel?: SortOrderInput | SortOrder
    f_rr?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    clientsId?: SortOrderInput | SortOrder
    _count?: integrationCountOrderByAggregateInput
    _avg?: integrationAvgOrderByAggregateInput
    _max?: integrationMaxOrderByAggregateInput
    _min?: integrationMinOrderByAggregateInput
    _sum?: integrationSumOrderByAggregateInput
  }

  export type integrationScalarWhereWithAggregatesInput = {
    AND?: integrationScalarWhereWithAggregatesInput | integrationScalarWhereWithAggregatesInput[]
    OR?: integrationScalarWhereWithAggregatesInput[]
    NOT?: integrationScalarWhereWithAggregatesInput | integrationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"integration"> | number
    name?: StringNullableWithAggregatesFilter<"integration"> | string | null
    baseUrl?: StringNullableWithAggregatesFilter<"integration"> | string | null
    f_chat?: BoolNullableWithAggregatesFilter<"integration"> | boolean | null
    f_review?: BoolNullableWithAggregatesFilter<"integration"> | boolean | null
    f_cancel?: BoolNullableWithAggregatesFilter<"integration"> | boolean | null
    f_rr?: BoolNullableWithAggregatesFilter<"integration"> | boolean | null
    status?: StringNullableWithAggregatesFilter<"integration"> | string | null
    notes?: StringNullableWithAggregatesFilter<"integration"> | string | null
    clientsId?: IntNullableWithAggregatesFilter<"integration"> | number | null
  }

  export type return_line_itemWhereInput = {
    AND?: return_line_itemWhereInput | return_line_itemWhereInput[]
    OR?: return_line_itemWhereInput[]
    NOT?: return_line_itemWhereInput | return_line_itemWhereInput[]
    id?: IntFilter<"return_line_item"> | number
    origin_id?: StringNullableFilter<"return_line_item"> | string | null
    refund_service_fee?: IntFilter<"return_line_item"> | number
    currency?: StringNullableFilter<"return_line_item"> | string | null
    refund_subtotal?: IntFilter<"return_line_item"> | number
    refund_total?: IntFilter<"return_line_item"> | number
    order_itemsId?: IntFilter<"return_line_item"> | number
    return_refundId?: IntNullableFilter<"return_line_item"> | number | null
    item?: XOR<Order_itemsScalarRelationFilter, order_itemsWhereInput>
    return_refund?: XOR<Return_refundNullableScalarRelationFilter, return_refundWhereInput> | null
  }

  export type return_line_itemOrderByWithRelationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    refund_service_fee?: SortOrder
    currency?: SortOrderInput | SortOrder
    refund_subtotal?: SortOrder
    refund_total?: SortOrder
    order_itemsId?: SortOrder
    return_refundId?: SortOrderInput | SortOrder
    item?: order_itemsOrderByWithRelationInput
    return_refund?: return_refundOrderByWithRelationInput
  }

  export type return_line_itemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    AND?: return_line_itemWhereInput | return_line_itemWhereInput[]
    OR?: return_line_itemWhereInput[]
    NOT?: return_line_itemWhereInput | return_line_itemWhereInput[]
    refund_service_fee?: IntFilter<"return_line_item"> | number
    currency?: StringNullableFilter<"return_line_item"> | string | null
    refund_subtotal?: IntFilter<"return_line_item"> | number
    refund_total?: IntFilter<"return_line_item"> | number
    order_itemsId?: IntFilter<"return_line_item"> | number
    return_refundId?: IntNullableFilter<"return_line_item"> | number | null
    item?: XOR<Order_itemsScalarRelationFilter, order_itemsWhereInput>
    return_refund?: XOR<Return_refundNullableScalarRelationFilter, return_refundWhereInput> | null
  }, "id" | "origin_id">

  export type return_line_itemOrderByWithAggregationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    refund_service_fee?: SortOrder
    currency?: SortOrderInput | SortOrder
    refund_subtotal?: SortOrder
    refund_total?: SortOrder
    order_itemsId?: SortOrder
    return_refundId?: SortOrderInput | SortOrder
    _count?: return_line_itemCountOrderByAggregateInput
    _avg?: return_line_itemAvgOrderByAggregateInput
    _max?: return_line_itemMaxOrderByAggregateInput
    _min?: return_line_itemMinOrderByAggregateInput
    _sum?: return_line_itemSumOrderByAggregateInput
  }

  export type return_line_itemScalarWhereWithAggregatesInput = {
    AND?: return_line_itemScalarWhereWithAggregatesInput | return_line_itemScalarWhereWithAggregatesInput[]
    OR?: return_line_itemScalarWhereWithAggregatesInput[]
    NOT?: return_line_itemScalarWhereWithAggregatesInput | return_line_itemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"return_line_item"> | number
    origin_id?: StringNullableWithAggregatesFilter<"return_line_item"> | string | null
    refund_service_fee?: IntWithAggregatesFilter<"return_line_item"> | number
    currency?: StringNullableWithAggregatesFilter<"return_line_item"> | string | null
    refund_subtotal?: IntWithAggregatesFilter<"return_line_item"> | number
    refund_total?: IntWithAggregatesFilter<"return_line_item"> | number
    order_itemsId?: IntWithAggregatesFilter<"return_line_item"> | number
    return_refundId?: IntNullableWithAggregatesFilter<"return_line_item"> | number | null
  }

  export type return_refundWhereInput = {
    AND?: return_refundWhereInput | return_refundWhereInput[]
    OR?: return_refundWhereInput[]
    NOT?: return_refundWhereInput | return_refundWhereInput[]
    id?: IntFilter<"return_refund"> | number
    origin_id?: StringNullableFilter<"return_refund"> | string | null
    status?: StringNullableFilter<"return_refund"> | string | null
    total_amount?: IntFilter<"return_refund"> | number
    return_type?: StringNullableFilter<"return_refund"> | string | null
    return_reason?: StringNullableFilter<"return_refund"> | string | null
    ordersId?: IntFilter<"return_refund"> | number
    order?: XOR<OrdersScalarRelationFilter, ordersWhereInput>
    line_item?: Return_line_itemListRelationFilter
  }

  export type return_refundOrderByWithRelationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    return_type?: SortOrderInput | SortOrder
    return_reason?: SortOrderInput | SortOrder
    ordersId?: SortOrder
    order?: ordersOrderByWithRelationInput
    line_item?: return_line_itemOrderByRelationAggregateInput
  }

  export type return_refundWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    origin_id?: string
    ordersId?: number
    AND?: return_refundWhereInput | return_refundWhereInput[]
    OR?: return_refundWhereInput[]
    NOT?: return_refundWhereInput | return_refundWhereInput[]
    status?: StringNullableFilter<"return_refund"> | string | null
    total_amount?: IntFilter<"return_refund"> | number
    return_type?: StringNullableFilter<"return_refund"> | string | null
    return_reason?: StringNullableFilter<"return_refund"> | string | null
    order?: XOR<OrdersScalarRelationFilter, ordersWhereInput>
    line_item?: Return_line_itemListRelationFilter
  }, "id" | "origin_id" | "ordersId">

  export type return_refundOrderByWithAggregationInput = {
    id?: SortOrder
    origin_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    return_type?: SortOrderInput | SortOrder
    return_reason?: SortOrderInput | SortOrder
    ordersId?: SortOrder
    _count?: return_refundCountOrderByAggregateInput
    _avg?: return_refundAvgOrderByAggregateInput
    _max?: return_refundMaxOrderByAggregateInput
    _min?: return_refundMinOrderByAggregateInput
    _sum?: return_refundSumOrderByAggregateInput
  }

  export type return_refundScalarWhereWithAggregatesInput = {
    AND?: return_refundScalarWhereWithAggregatesInput | return_refundScalarWhereWithAggregatesInput[]
    OR?: return_refundScalarWhereWithAggregatesInput[]
    NOT?: return_refundScalarWhereWithAggregatesInput | return_refundScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"return_refund"> | number
    origin_id?: StringNullableWithAggregatesFilter<"return_refund"> | string | null
    status?: StringNullableWithAggregatesFilter<"return_refund"> | string | null
    total_amount?: IntWithAggregatesFilter<"return_refund"> | number
    return_type?: StringNullableWithAggregatesFilter<"return_refund"> | string | null
    return_reason?: StringNullableWithAggregatesFilter<"return_refund"> | string | null
    ordersId?: IntWithAggregatesFilter<"return_refund"> | number
  }

  export type customersCreateInput = {
    name?: string | null
    origin_id?: string | null
    phone?: string | null
    email?: string | null
    orders?: ordersCreateNestedManyWithoutCustomersInput
  }

  export type customersUncheckedCreateInput = {
    id?: number
    name?: string | null
    origin_id?: string | null
    phone?: string | null
    email?: string | null
    orders?: ordersUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type customersUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUpdateManyWithoutCustomersNestedInput
  }

  export type customersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type customersCreateManyInput = {
    id?: number
    name?: string | null
    origin_id?: string | null
    phone?: string | null
    email?: string | null
  }

  export type customersUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type products_imgCreateInput = {
    origin_id?: string | null
    filename?: string | null
    status?: string | null
    width?: number | null
    height?: number | null
    originalUrl?: string | null
    thumbnailUrl?: string | null
    products?: productsCreateNestedOneWithoutProduct_imgInput
  }

  export type products_imgUncheckedCreateInput = {
    id?: number
    origin_id?: string | null
    filename?: string | null
    status?: string | null
    width?: number | null
    height?: number | null
    originalUrl?: string | null
    thumbnailUrl?: string | null
    productsId?: number | null
  }

  export type products_imgUpdateInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    originalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    products?: productsUpdateOneWithoutProduct_imgNestedInput
  }

  export type products_imgUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    originalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type products_imgCreateManyInput = {
    id?: number
    origin_id?: string | null
    filename?: string | null
    status?: string | null
    width?: number | null
    height?: number | null
    originalUrl?: string | null
    thumbnailUrl?: string | null
    productsId?: number | null
  }

  export type products_imgUpdateManyMutationInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    originalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type products_imgUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    originalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type channelCreateInput = {
    name?: string | null
    client?: clientsCreateNestedOneWithoutChannelInput
    store?: storeCreateNestedManyWithoutChannelInput
  }

  export type channelUncheckedCreateInput = {
    id?: number
    name?: string | null
    clientsId?: number | null
    store?: storeUncheckedCreateNestedManyWithoutChannelInput
  }

  export type channelUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    client?: clientsUpdateOneWithoutChannelNestedInput
    store?: storeUpdateManyWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    clientsId?: NullableIntFieldUpdateOperationsInput | number | null
    store?: storeUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type channelCreateManyInput = {
    id?: number
    name?: string | null
    clientsId?: number | null
  }

  export type channelUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type channelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    clientsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type storeCreateInput = {
    name?: string | null
    origin_id?: string | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
    omnichat?: omnichatCreateNestedManyWithoutStoreInput
    orders?: ordersCreateNestedManyWithoutStoreInput
    products?: productsCreateNestedManyWithoutStoreInput
    channel?: channelCreateNestedOneWithoutStoreInput
  }

  export type storeUncheckedCreateInput = {
    id?: number
    name?: string | null
    origin_id?: string | null
    channelId?: number | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
    omnichat?: omnichatUncheckedCreateNestedManyWithoutStoreInput
    orders?: ordersUncheckedCreateNestedManyWithoutStoreInput
    products?: productsUncheckedCreateNestedManyWithoutStoreInput
  }

  export type storeUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUpdateManyWithoutStoreNestedInput
    orders?: ordersUpdateManyWithoutStoreNestedInput
    products?: productsUpdateManyWithoutStoreNestedInput
    channel?: channelUpdateOneWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableIntFieldUpdateOperationsInput | number | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUncheckedUpdateManyWithoutStoreNestedInput
    orders?: ordersUncheckedUpdateManyWithoutStoreNestedInput
    products?: productsUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type storeCreateManyInput = {
    id?: number
    name?: string | null
    origin_id?: string | null
    channelId?: number | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
  }

  export type storeUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type storeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableIntFieldUpdateOperationsInput | number | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productsCreateInput = {
    origin_id?: string | null
    status?: string | null
    name?: string | null
    condition?: number | null
    desc?: string | null
    category?: number | null
    price?: number | null
    currency?: string | null
    createdAt?: Date | string
    weight?: number | null
    stock?: number | null
    sku?: string | null
    order_items?: order_itemsCreateNestedManyWithoutProductsInput
    store?: storeCreateNestedOneWithoutProductsInput
    product_img?: products_imgCreateNestedManyWithoutProductsInput
  }

  export type productsUncheckedCreateInput = {
    id?: number
    origin_id?: string | null
    status?: string | null
    name?: string | null
    condition?: number | null
    desc?: string | null
    category?: number | null
    price?: number | null
    currency?: string | null
    createdAt?: Date | string
    weight?: number | null
    stock?: number | null
    sku?: string | null
    storeId?: number | null
    order_items?: order_itemsUncheckedCreateNestedManyWithoutProductsInput
    product_img?: products_imgUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsUpdateInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    order_items?: order_itemsUpdateManyWithoutProductsNestedInput
    store?: storeUpdateOneWithoutProductsNestedInput
    product_img?: products_imgUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    order_items?: order_itemsUncheckedUpdateManyWithoutProductsNestedInput
    product_img?: products_imgUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type productsCreateManyInput = {
    id?: number
    origin_id?: string | null
    status?: string | null
    name?: string | null
    condition?: number | null
    desc?: string | null
    category?: number | null
    price?: number | null
    currency?: string | null
    createdAt?: Date | string
    weight?: number | null
    stock?: number | null
    sku?: string | null
    storeId?: number | null
  }

  export type productsUpdateManyMutationInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type order_itemsCreateInput = {
    createdAt?: Date | string
    qty: number
    package_id?: string | null
    invoice?: string | null
    total_price: number
    notes?: string | null
    origin_id?: string | null
    orders?: ordersCreateNestedOneWithoutOrder_itemsInput
    products?: productsCreateNestedOneWithoutOrder_itemsInput
    return_line_item?: return_line_itemCreateNestedManyWithoutItemInput
  }

  export type order_itemsUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    qty: number
    package_id?: string | null
    invoice?: string | null
    total_price: number
    notes?: string | null
    ordersId?: number | null
    productsId?: number | null
    origin_id?: string | null
    return_line_item?: return_line_itemUncheckedCreateNestedManyWithoutItemInput
  }

  export type order_itemsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUpdateOneWithoutOrder_itemsNestedInput
    products?: productsUpdateOneWithoutOrder_itemsNestedInput
    return_line_item?: return_line_itemUpdateManyWithoutItemNestedInput
  }

  export type order_itemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ordersId?: NullableIntFieldUpdateOperationsInput | number | null
    productsId?: NullableIntFieldUpdateOperationsInput | number | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    return_line_item?: return_line_itemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type order_itemsCreateManyInput = {
    id?: number
    createdAt?: Date | string
    qty: number
    package_id?: string | null
    invoice?: string | null
    total_price: number
    notes?: string | null
    ordersId?: number | null
    productsId?: number | null
    origin_id?: string | null
  }

  export type order_itemsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type order_itemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ordersId?: NullableIntFieldUpdateOperationsInput | number | null
    productsId?: NullableIntFieldUpdateOperationsInput | number | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logisticCreateInput = {
    name?: string | null
    type?: string | null
    orders?: ordersCreateNestedManyWithoutLogisticInput
  }

  export type logisticUncheckedCreateInput = {
    id?: number
    name?: string | null
    type?: string | null
    orders?: ordersUncheckedCreateNestedManyWithoutLogisticInput
  }

  export type logisticUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUpdateManyWithoutLogisticNestedInput
  }

  export type logisticUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUncheckedUpdateManyWithoutLogisticNestedInput
  }

  export type logisticCreateManyInput = {
    id?: number
    name?: string | null
    type?: string | null
  }

  export type logisticUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logisticUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ordersCreateInput = {
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    order_items?: order_itemsCreateNestedManyWithoutOrdersInput
    customers?: customersCreateNestedOneWithoutOrdersInput
    logistic?: logisticCreateNestedOneWithoutOrdersInput
    store?: storeCreateNestedOneWithoutOrdersInput
    return_refund?: return_refundCreateNestedOneWithoutOrderInput
  }

  export type ordersUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    storeId?: number | null
    customersId?: number | null
    logisticId?: number | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    order_items?: order_itemsUncheckedCreateNestedManyWithoutOrdersInput
    return_refund?: return_refundUncheckedCreateNestedOneWithoutOrderInput
  }

  export type ordersUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUpdateManyWithoutOrdersNestedInput
    customers?: customersUpdateOneWithoutOrdersNestedInput
    logistic?: logisticUpdateOneWithoutOrdersNestedInput
    store?: storeUpdateOneWithoutOrdersNestedInput
    return_refund?: return_refundUpdateOneWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    logisticId?: NullableIntFieldUpdateOperationsInput | number | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUncheckedUpdateManyWithoutOrdersNestedInput
    return_refund?: return_refundUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ordersCreateManyInput = {
    id?: number
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    storeId?: number | null
    customersId?: number | null
    logisticId?: number | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
  }

  export type ordersUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    logisticId?: NullableIntFieldUpdateOperationsInput | number | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type omnichat_userCreateInput = {
    username?: string | null
    thumbnailUrl?: string | null
    origin_id?: string | null
    createdAt?: Date | string
    externalId?: string | null
    omnichat?: omnichatCreateNestedManyWithoutOmnichat_userInput
    omnichat_line?: omnichat_lineCreateNestedManyWithoutOmnichat_userInput
  }

  export type omnichat_userUncheckedCreateInput = {
    id?: number
    username?: string | null
    thumbnailUrl?: string | null
    origin_id?: string | null
    createdAt?: Date | string
    externalId?: string | null
    omnichat?: omnichatUncheckedCreateNestedManyWithoutOmnichat_userInput
    omnichat_line?: omnichat_lineUncheckedCreateNestedManyWithoutOmnichat_userInput
  }

  export type omnichat_userUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUpdateManyWithoutOmnichat_userNestedInput
    omnichat_line?: omnichat_lineUpdateManyWithoutOmnichat_userNestedInput
  }

  export type omnichat_userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUncheckedUpdateManyWithoutOmnichat_userNestedInput
    omnichat_line?: omnichat_lineUncheckedUpdateManyWithoutOmnichat_userNestedInput
  }

  export type omnichat_userCreateManyInput = {
    id?: number
    username?: string | null
    thumbnailUrl?: string | null
    origin_id?: string | null
    createdAt?: Date | string
    externalId?: string | null
  }

  export type omnichat_userUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichat_userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichatCreateInput = {
    origin_id?: string | null
    last_message: string
    last_messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    externalId?: string | null
    omnichat_user?: omnichat_userCreateNestedOneWithoutOmnichatInput
    store?: storeCreateNestedOneWithoutOmnichatInput
    messages?: omnichat_lineCreateNestedManyWithoutOmnichatInput
  }

  export type omnichatUncheckedCreateInput = {
    id?: number
    origin_id?: string | null
    last_message: string
    last_messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId?: number | null
    omnichat_userId?: number | null
    externalId?: string | null
    messages?: omnichat_lineUncheckedCreateNestedManyWithoutOmnichatInput
  }

  export type omnichatUpdateInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat_user?: omnichat_userUpdateOneWithoutOmnichatNestedInput
    store?: storeUpdateOneWithoutOmnichatNestedInput
    messages?: omnichat_lineUpdateManyWithoutOmnichatNestedInput
  }

  export type omnichatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    omnichat_userId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: omnichat_lineUncheckedUpdateManyWithoutOmnichatNestedInput
  }

  export type omnichatCreateManyInput = {
    id?: number
    origin_id?: string | null
    last_message: string
    last_messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId?: number | null
    omnichat_userId?: number | null
    externalId?: string | null
  }

  export type omnichatUpdateManyMutationInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    omnichat_userId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichat_lineCreateInput = {
    origin_id?: string | null
    createdAt?: Date | string
    line_text: string
    author?: string | null
    chat_type?: string | null
    omnichat?: omnichatCreateNestedOneWithoutMessagesInput
    omnichat_user?: omnichat_userCreateNestedOneWithoutOmnichat_lineInput
  }

  export type omnichat_lineUncheckedCreateInput = {
    id?: number
    origin_id?: string | null
    createdAt?: Date | string
    line_text: string
    omnichatId?: number | null
    author?: string | null
    omnichat_userId?: number | null
    chat_type?: string | null
  }

  export type omnichat_lineUpdateInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    line_text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    chat_type?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUpdateOneWithoutMessagesNestedInput
    omnichat_user?: omnichat_userUpdateOneWithoutOmnichat_lineNestedInput
  }

  export type omnichat_lineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    line_text?: StringFieldUpdateOperationsInput | string
    omnichatId?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat_userId?: NullableIntFieldUpdateOperationsInput | number | null
    chat_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichat_lineCreateManyInput = {
    id?: number
    origin_id?: string | null
    createdAt?: Date | string
    line_text: string
    omnichatId?: number | null
    author?: string | null
    omnichat_userId?: number | null
    chat_type?: string | null
  }

  export type omnichat_lineUpdateManyMutationInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    line_text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    chat_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichat_lineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    line_text?: StringFieldUpdateOperationsInput | string
    omnichatId?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat_userId?: NullableIntFieldUpdateOperationsInput | number | null
    chat_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type zdconnectorCreateInput = {
    name: string
    host: string
    createdAt?: Date | string
    updatedAt?: Date | string
    suncoAppId: string
    suncoAppKey: string
    suncoAppSecret: string
    zdAPIToken: string
    resource?: string | null
    clientsId?: number | null
  }

  export type zdconnectorUncheckedCreateInput = {
    id?: number
    name: string
    host: string
    createdAt?: Date | string
    updatedAt?: Date | string
    suncoAppId: string
    suncoAppKey: string
    suncoAppSecret: string
    zdAPIToken: string
    resource?: string | null
    clientsId?: number | null
  }

  export type zdconnectorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suncoAppId?: StringFieldUpdateOperationsInput | string
    suncoAppKey?: StringFieldUpdateOperationsInput | string
    suncoAppSecret?: StringFieldUpdateOperationsInput | string
    zdAPIToken?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    clientsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type zdconnectorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suncoAppId?: StringFieldUpdateOperationsInput | string
    suncoAppKey?: StringFieldUpdateOperationsInput | string
    suncoAppSecret?: StringFieldUpdateOperationsInput | string
    zdAPIToken?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    clientsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type zdconnectorCreateManyInput = {
    id?: number
    name: string
    host: string
    createdAt?: Date | string
    updatedAt?: Date | string
    suncoAppId: string
    suncoAppKey: string
    suncoAppSecret: string
    zdAPIToken: string
    resource?: string | null
    clientsId?: number | null
  }

  export type zdconnectorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suncoAppId?: StringFieldUpdateOperationsInput | string
    suncoAppKey?: StringFieldUpdateOperationsInput | string
    suncoAppSecret?: StringFieldUpdateOperationsInput | string
    zdAPIToken?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    clientsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type zdconnectorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suncoAppId?: StringFieldUpdateOperationsInput | string
    suncoAppKey?: StringFieldUpdateOperationsInput | string
    suncoAppSecret?: StringFieldUpdateOperationsInput | string
    zdAPIToken?: StringFieldUpdateOperationsInput | string
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    clientsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type omnicrmCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    type?: string | null
  }

  export type omnicrmUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    type?: string | null
  }

  export type omnicrmUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnicrmUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnicrmCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string | null
    type?: string | null
  }

  export type omnicrmUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnicrmUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientsCreateInput = {
    name: string
    origin_id?: string | null
    channel?: channelCreateNestedManyWithoutClientInput
    integration?: integrationCreateNestedManyWithoutClientsInput
  }

  export type clientsUncheckedCreateInput = {
    id?: number
    name: string
    origin_id?: string | null
    channel?: channelUncheckedCreateNestedManyWithoutClientInput
    integration?: integrationUncheckedCreateNestedManyWithoutClientsInput
  }

  export type clientsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: channelUpdateManyWithoutClientNestedInput
    integration?: integrationUpdateManyWithoutClientsNestedInput
  }

  export type clientsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: channelUncheckedUpdateManyWithoutClientNestedInput
    integration?: integrationUncheckedUpdateManyWithoutClientsNestedInput
  }

  export type clientsCreateManyInput = {
    id?: number
    name: string
    origin_id?: string | null
  }

  export type clientsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credentCreateInput = {
    key?: string | null
    value?: string | null
    integration?: integrationCreateNestedOneWithoutCredentInput
  }

  export type credentUncheckedCreateInput = {
    id?: number
    key?: string | null
    value?: string | null
    integrationId?: number | null
  }

  export type credentUpdateInput = {
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: integrationUpdateOneWithoutCredentNestedInput
  }

  export type credentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type credentCreateManyInput = {
    id?: number
    key?: string | null
    value?: string | null
    integrationId?: number | null
  }

  export type credentUpdateManyMutationInput = {
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    integrationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type integrationCreateInput = {
    name?: string | null
    baseUrl?: string | null
    f_chat?: boolean | null
    f_review?: boolean | null
    f_cancel?: boolean | null
    f_rr?: boolean | null
    status?: string | null
    notes?: string | null
    credent?: credentCreateNestedManyWithoutIntegrationInput
    clients?: clientsCreateNestedOneWithoutIntegrationInput
  }

  export type integrationUncheckedCreateInput = {
    id?: number
    name?: string | null
    baseUrl?: string | null
    f_chat?: boolean | null
    f_review?: boolean | null
    f_cancel?: boolean | null
    f_rr?: boolean | null
    status?: string | null
    notes?: string | null
    clientsId?: number | null
    credent?: credentUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type integrationUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    f_chat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_cancel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_rr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    credent?: credentUpdateManyWithoutIntegrationNestedInput
    clients?: clientsUpdateOneWithoutIntegrationNestedInput
  }

  export type integrationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    f_chat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_cancel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_rr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    clientsId?: NullableIntFieldUpdateOperationsInput | number | null
    credent?: credentUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type integrationCreateManyInput = {
    id?: number
    name?: string | null
    baseUrl?: string | null
    f_chat?: boolean | null
    f_review?: boolean | null
    f_cancel?: boolean | null
    f_rr?: boolean | null
    status?: string | null
    notes?: string | null
    clientsId?: number | null
  }

  export type integrationUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    f_chat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_cancel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_rr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type integrationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    f_chat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_cancel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_rr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    clientsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type return_line_itemCreateInput = {
    origin_id?: string | null
    refund_service_fee: number
    currency?: string | null
    refund_subtotal: number
    refund_total: number
    item: order_itemsCreateNestedOneWithoutReturn_line_itemInput
    return_refund?: return_refundCreateNestedOneWithoutLine_itemInput
  }

  export type return_line_itemUncheckedCreateInput = {
    id?: number
    origin_id?: string | null
    refund_service_fee: number
    currency?: string | null
    refund_subtotal: number
    refund_total: number
    order_itemsId: number
    return_refundId?: number | null
  }

  export type return_line_itemUpdateInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refund_service_fee?: IntFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    refund_subtotal?: IntFieldUpdateOperationsInput | number
    refund_total?: IntFieldUpdateOperationsInput | number
    item?: order_itemsUpdateOneRequiredWithoutReturn_line_itemNestedInput
    return_refund?: return_refundUpdateOneWithoutLine_itemNestedInput
  }

  export type return_line_itemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refund_service_fee?: IntFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    refund_subtotal?: IntFieldUpdateOperationsInput | number
    refund_total?: IntFieldUpdateOperationsInput | number
    order_itemsId?: IntFieldUpdateOperationsInput | number
    return_refundId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type return_line_itemCreateManyInput = {
    id?: number
    origin_id?: string | null
    refund_service_fee: number
    currency?: string | null
    refund_subtotal: number
    refund_total: number
    order_itemsId: number
    return_refundId?: number | null
  }

  export type return_line_itemUpdateManyMutationInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refund_service_fee?: IntFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    refund_subtotal?: IntFieldUpdateOperationsInput | number
    refund_total?: IntFieldUpdateOperationsInput | number
  }

  export type return_line_itemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refund_service_fee?: IntFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    refund_subtotal?: IntFieldUpdateOperationsInput | number
    refund_total?: IntFieldUpdateOperationsInput | number
    order_itemsId?: IntFieldUpdateOperationsInput | number
    return_refundId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type return_refundCreateInput = {
    origin_id?: string | null
    status?: string | null
    total_amount: number
    return_type?: string | null
    return_reason?: string | null
    order: ordersCreateNestedOneWithoutReturn_refundInput
    line_item?: return_line_itemCreateNestedManyWithoutReturn_refundInput
  }

  export type return_refundUncheckedCreateInput = {
    id?: number
    origin_id?: string | null
    status?: string | null
    total_amount: number
    return_type?: string | null
    return_reason?: string | null
    ordersId: number
    line_item?: return_line_itemUncheckedCreateNestedManyWithoutReturn_refundInput
  }

  export type return_refundUpdateInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: IntFieldUpdateOperationsInput | number
    return_type?: NullableStringFieldUpdateOperationsInput | string | null
    return_reason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: ordersUpdateOneRequiredWithoutReturn_refundNestedInput
    line_item?: return_line_itemUpdateManyWithoutReturn_refundNestedInput
  }

  export type return_refundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: IntFieldUpdateOperationsInput | number
    return_type?: NullableStringFieldUpdateOperationsInput | string | null
    return_reason?: NullableStringFieldUpdateOperationsInput | string | null
    ordersId?: IntFieldUpdateOperationsInput | number
    line_item?: return_line_itemUncheckedUpdateManyWithoutReturn_refundNestedInput
  }

  export type return_refundCreateManyInput = {
    id?: number
    origin_id?: string | null
    status?: string | null
    total_amount: number
    return_type?: string | null
    return_reason?: string | null
    ordersId: number
  }

  export type return_refundUpdateManyMutationInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: IntFieldUpdateOperationsInput | number
    return_type?: NullableStringFieldUpdateOperationsInput | string | null
    return_reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type return_refundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: IntFieldUpdateOperationsInput | number
    return_type?: NullableStringFieldUpdateOperationsInput | string | null
    return_reason?: NullableStringFieldUpdateOperationsInput | string | null
    ordersId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type OrdersListRelationFilter = {
    every?: ordersWhereInput
    some?: ordersWhereInput
    none?: ordersWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ordersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    origin_id?: SortOrder
    phone?: SortOrder
    email?: SortOrder
  }

  export type customersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type customersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    origin_id?: SortOrder
    phone?: SortOrder
    email?: SortOrder
  }

  export type customersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    origin_id?: SortOrder
    phone?: SortOrder
    email?: SortOrder
  }

  export type customersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProductsNullableScalarRelationFilter = {
    is?: productsWhereInput | null
    isNot?: productsWhereInput | null
  }

  export type products_imgCountOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    filename?: SortOrder
    status?: SortOrder
    width?: SortOrder
    height?: SortOrder
    originalUrl?: SortOrder
    thumbnailUrl?: SortOrder
    productsId?: SortOrder
  }

  export type products_imgAvgOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    productsId?: SortOrder
  }

  export type products_imgMaxOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    filename?: SortOrder
    status?: SortOrder
    width?: SortOrder
    height?: SortOrder
    originalUrl?: SortOrder
    thumbnailUrl?: SortOrder
    productsId?: SortOrder
  }

  export type products_imgMinOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    filename?: SortOrder
    status?: SortOrder
    width?: SortOrder
    height?: SortOrder
    originalUrl?: SortOrder
    thumbnailUrl?: SortOrder
    productsId?: SortOrder
  }

  export type products_imgSumOrderByAggregateInput = {
    id?: SortOrder
    width?: SortOrder
    height?: SortOrder
    productsId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ClientsNullableScalarRelationFilter = {
    is?: clientsWhereInput | null
    isNot?: clientsWhereInput | null
  }

  export type StoreListRelationFilter = {
    every?: storeWhereInput
    some?: storeWhereInput
    none?: storeWhereInput
  }

  export type storeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type channelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clientsId?: SortOrder
  }

  export type channelAvgOrderByAggregateInput = {
    id?: SortOrder
    clientsId?: SortOrder
  }

  export type channelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clientsId?: SortOrder
  }

  export type channelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clientsId?: SortOrder
  }

  export type channelSumOrderByAggregateInput = {
    id?: SortOrder
    clientsId?: SortOrder
  }

  export type OmnichatListRelationFilter = {
    every?: omnichatWhereInput
    some?: omnichatWhereInput
    none?: omnichatWhereInput
  }

  export type ProductsListRelationFilter = {
    every?: productsWhereInput
    some?: productsWhereInput
    none?: productsWhereInput
  }

  export type ChannelNullableScalarRelationFilter = {
    is?: channelWhereInput | null
    isNot?: channelWhereInput | null
  }

  export type omnichatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type storeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    origin_id?: SortOrder
    channelId?: SortOrder
    refresh_token?: SortOrder
    token?: SortOrder
    secondary_refresh_token?: SortOrder
    secondary_token?: SortOrder
    url?: SortOrder
    status?: SortOrder
  }

  export type storeAvgOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
  }

  export type storeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    origin_id?: SortOrder
    channelId?: SortOrder
    refresh_token?: SortOrder
    token?: SortOrder
    secondary_refresh_token?: SortOrder
    secondary_token?: SortOrder
    url?: SortOrder
    status?: SortOrder
  }

  export type storeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    origin_id?: SortOrder
    channelId?: SortOrder
    refresh_token?: SortOrder
    token?: SortOrder
    secondary_refresh_token?: SortOrder
    secondary_token?: SortOrder
    url?: SortOrder
    status?: SortOrder
  }

  export type storeSumOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Order_itemsListRelationFilter = {
    every?: order_itemsWhereInput
    some?: order_itemsWhereInput
    none?: order_itemsWhereInput
  }

  export type StoreNullableScalarRelationFilter = {
    is?: storeWhereInput | null
    isNot?: storeWhereInput | null
  }

  export type Products_imgListRelationFilter = {
    every?: products_imgWhereInput
    some?: products_imgWhereInput
    none?: products_imgWhereInput
  }

  export type order_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type products_imgOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productsCountOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    status?: SortOrder
    name?: SortOrder
    condition?: SortOrder
    desc?: SortOrder
    category?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    weight?: SortOrder
    stock?: SortOrder
    sku?: SortOrder
    storeId?: SortOrder
  }

  export type productsAvgOrderByAggregateInput = {
    id?: SortOrder
    condition?: SortOrder
    category?: SortOrder
    price?: SortOrder
    weight?: SortOrder
    stock?: SortOrder
    storeId?: SortOrder
  }

  export type productsMaxOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    status?: SortOrder
    name?: SortOrder
    condition?: SortOrder
    desc?: SortOrder
    category?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    weight?: SortOrder
    stock?: SortOrder
    sku?: SortOrder
    storeId?: SortOrder
  }

  export type productsMinOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    status?: SortOrder
    name?: SortOrder
    condition?: SortOrder
    desc?: SortOrder
    category?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    weight?: SortOrder
    stock?: SortOrder
    sku?: SortOrder
    storeId?: SortOrder
  }

  export type productsSumOrderByAggregateInput = {
    id?: SortOrder
    condition?: SortOrder
    category?: SortOrder
    price?: SortOrder
    weight?: SortOrder
    stock?: SortOrder
    storeId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type OrdersNullableScalarRelationFilter = {
    is?: ordersWhereInput | null
    isNot?: ordersWhereInput | null
  }

  export type Return_line_itemListRelationFilter = {
    every?: return_line_itemWhereInput
    some?: return_line_itemWhereInput
    none?: return_line_itemWhereInput
  }

  export type return_line_itemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type order_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    qty?: SortOrder
    package_id?: SortOrder
    invoice?: SortOrder
    total_price?: SortOrder
    notes?: SortOrder
    ordersId?: SortOrder
    productsId?: SortOrder
    origin_id?: SortOrder
  }

  export type order_itemsAvgOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    total_price?: SortOrder
    ordersId?: SortOrder
    productsId?: SortOrder
  }

  export type order_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    qty?: SortOrder
    package_id?: SortOrder
    invoice?: SortOrder
    total_price?: SortOrder
    notes?: SortOrder
    ordersId?: SortOrder
    productsId?: SortOrder
    origin_id?: SortOrder
  }

  export type order_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    qty?: SortOrder
    package_id?: SortOrder
    invoice?: SortOrder
    total_price?: SortOrder
    notes?: SortOrder
    ordersId?: SortOrder
    productsId?: SortOrder
    origin_id?: SortOrder
  }

  export type order_itemsSumOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    total_price?: SortOrder
    ordersId?: SortOrder
    productsId?: SortOrder
  }

  export type logisticCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type logisticAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type logisticMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type logisticMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type logisticSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type CustomersNullableScalarRelationFilter = {
    is?: customersWhereInput | null
    isNot?: customersWhereInput | null
  }

  export type LogisticNullableScalarRelationFilter = {
    is?: logisticWhereInput | null
    isNot?: logisticWhereInput | null
  }

  export type Return_refundNullableScalarRelationFilter = {
    is?: return_refundWhereInput | null
    isNot?: return_refundWhereInput | null
  }

  export type ordersCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    shop_id?: SortOrder
    payment_id?: SortOrder
    temp_id?: SortOrder
    origin_id?: SortOrder
    package_id?: SortOrder
    invoice?: SortOrder
    recp_name?: SortOrder
    recp_phone?: SortOrder
    recp_addr_full?: SortOrder
    recp_addr_district?: SortOrder
    recp_addr_city?: SortOrder
    recp_addr_province?: SortOrder
    recp_addr_country?: SortOrder
    recp_addr_postal_code?: SortOrder
    recp_addr_district_id?: SortOrder
    recp_addr_city_id?: SortOrder
    tracking_number?: SortOrder
    ship_document_url?: SortOrder
    recp_addr_province_id?: SortOrder
    recp_addr_geo?: SortOrder
    logistic_service?: SortOrder
    origin_createdAt?: SortOrder
    accept_partial?: SortOrder
    device?: SortOrder
    storeId?: SortOrder
    customersId?: SortOrder
    logisticId?: SortOrder
    total_product_price?: SortOrder
    shipping_price?: SortOrder
    seller_discount?: SortOrder
    platform_discount?: SortOrder
    shipping_seller_discount?: SortOrder
    shipping_platform_discount?: SortOrder
    buyer_service_fee?: SortOrder
    handling_fee?: SortOrder
    shipping_insurance_fee?: SortOrder
    item_insurance_fee?: SortOrder
    total_amount?: SortOrder
    updatedAt?: SortOrder
  }

  export type ordersAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    customersId?: SortOrder
    logisticId?: SortOrder
    total_product_price?: SortOrder
    shipping_price?: SortOrder
    seller_discount?: SortOrder
    platform_discount?: SortOrder
    shipping_seller_discount?: SortOrder
    shipping_platform_discount?: SortOrder
    buyer_service_fee?: SortOrder
    handling_fee?: SortOrder
    shipping_insurance_fee?: SortOrder
    item_insurance_fee?: SortOrder
    total_amount?: SortOrder
  }

  export type ordersMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    shop_id?: SortOrder
    payment_id?: SortOrder
    temp_id?: SortOrder
    origin_id?: SortOrder
    package_id?: SortOrder
    invoice?: SortOrder
    recp_name?: SortOrder
    recp_phone?: SortOrder
    recp_addr_full?: SortOrder
    recp_addr_district?: SortOrder
    recp_addr_city?: SortOrder
    recp_addr_province?: SortOrder
    recp_addr_country?: SortOrder
    recp_addr_postal_code?: SortOrder
    recp_addr_district_id?: SortOrder
    recp_addr_city_id?: SortOrder
    tracking_number?: SortOrder
    ship_document_url?: SortOrder
    recp_addr_province_id?: SortOrder
    recp_addr_geo?: SortOrder
    logistic_service?: SortOrder
    origin_createdAt?: SortOrder
    accept_partial?: SortOrder
    device?: SortOrder
    storeId?: SortOrder
    customersId?: SortOrder
    logisticId?: SortOrder
    total_product_price?: SortOrder
    shipping_price?: SortOrder
    seller_discount?: SortOrder
    platform_discount?: SortOrder
    shipping_seller_discount?: SortOrder
    shipping_platform_discount?: SortOrder
    buyer_service_fee?: SortOrder
    handling_fee?: SortOrder
    shipping_insurance_fee?: SortOrder
    item_insurance_fee?: SortOrder
    total_amount?: SortOrder
    updatedAt?: SortOrder
  }

  export type ordersMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    shop_id?: SortOrder
    payment_id?: SortOrder
    temp_id?: SortOrder
    origin_id?: SortOrder
    package_id?: SortOrder
    invoice?: SortOrder
    recp_name?: SortOrder
    recp_phone?: SortOrder
    recp_addr_full?: SortOrder
    recp_addr_district?: SortOrder
    recp_addr_city?: SortOrder
    recp_addr_province?: SortOrder
    recp_addr_country?: SortOrder
    recp_addr_postal_code?: SortOrder
    recp_addr_district_id?: SortOrder
    recp_addr_city_id?: SortOrder
    tracking_number?: SortOrder
    ship_document_url?: SortOrder
    recp_addr_province_id?: SortOrder
    recp_addr_geo?: SortOrder
    logistic_service?: SortOrder
    origin_createdAt?: SortOrder
    accept_partial?: SortOrder
    device?: SortOrder
    storeId?: SortOrder
    customersId?: SortOrder
    logisticId?: SortOrder
    total_product_price?: SortOrder
    shipping_price?: SortOrder
    seller_discount?: SortOrder
    platform_discount?: SortOrder
    shipping_seller_discount?: SortOrder
    shipping_platform_discount?: SortOrder
    buyer_service_fee?: SortOrder
    handling_fee?: SortOrder
    shipping_insurance_fee?: SortOrder
    item_insurance_fee?: SortOrder
    total_amount?: SortOrder
    updatedAt?: SortOrder
  }

  export type ordersSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    customersId?: SortOrder
    logisticId?: SortOrder
    total_product_price?: SortOrder
    shipping_price?: SortOrder
    seller_discount?: SortOrder
    platform_discount?: SortOrder
    shipping_seller_discount?: SortOrder
    shipping_platform_discount?: SortOrder
    buyer_service_fee?: SortOrder
    handling_fee?: SortOrder
    shipping_insurance_fee?: SortOrder
    item_insurance_fee?: SortOrder
    total_amount?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Omnichat_lineListRelationFilter = {
    every?: omnichat_lineWhereInput
    some?: omnichat_lineWhereInput
    none?: omnichat_lineWhereInput
  }

  export type omnichat_lineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type omnichat_userCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    thumbnailUrl?: SortOrder
    origin_id?: SortOrder
    createdAt?: SortOrder
    externalId?: SortOrder
  }

  export type omnichat_userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type omnichat_userMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    thumbnailUrl?: SortOrder
    origin_id?: SortOrder
    createdAt?: SortOrder
    externalId?: SortOrder
  }

  export type omnichat_userMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    thumbnailUrl?: SortOrder
    origin_id?: SortOrder
    createdAt?: SortOrder
    externalId?: SortOrder
  }

  export type omnichat_userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Omnichat_userNullableScalarRelationFilter = {
    is?: omnichat_userWhereInput | null
    isNot?: omnichat_userWhereInput | null
  }

  export type omnichatCountOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    last_message?: SortOrder
    last_messageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    omnichat_userId?: SortOrder
    externalId?: SortOrder
  }

  export type omnichatAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    omnichat_userId?: SortOrder
  }

  export type omnichatMaxOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    last_message?: SortOrder
    last_messageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    omnichat_userId?: SortOrder
    externalId?: SortOrder
  }

  export type omnichatMinOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    last_message?: SortOrder
    last_messageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storeId?: SortOrder
    omnichat_userId?: SortOrder
    externalId?: SortOrder
  }

  export type omnichatSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    omnichat_userId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type OmnichatNullableScalarRelationFilter = {
    is?: omnichatWhereInput | null
    isNot?: omnichatWhereInput | null
  }

  export type omnichat_lineCountOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    createdAt?: SortOrder
    line_text?: SortOrder
    omnichatId?: SortOrder
    author?: SortOrder
    omnichat_userId?: SortOrder
    chat_type?: SortOrder
  }

  export type omnichat_lineAvgOrderByAggregateInput = {
    id?: SortOrder
    omnichatId?: SortOrder
    omnichat_userId?: SortOrder
  }

  export type omnichat_lineMaxOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    createdAt?: SortOrder
    line_text?: SortOrder
    omnichatId?: SortOrder
    author?: SortOrder
    omnichat_userId?: SortOrder
    chat_type?: SortOrder
  }

  export type omnichat_lineMinOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    createdAt?: SortOrder
    line_text?: SortOrder
    omnichatId?: SortOrder
    author?: SortOrder
    omnichat_userId?: SortOrder
    chat_type?: SortOrder
  }

  export type omnichat_lineSumOrderByAggregateInput = {
    id?: SortOrder
    omnichatId?: SortOrder
    omnichat_userId?: SortOrder
  }

  export type zdconnectorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    host?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suncoAppId?: SortOrder
    suncoAppKey?: SortOrder
    suncoAppSecret?: SortOrder
    zdAPIToken?: SortOrder
    resource?: SortOrder
    clientsId?: SortOrder
  }

  export type zdconnectorAvgOrderByAggregateInput = {
    id?: SortOrder
    clientsId?: SortOrder
  }

  export type zdconnectorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    host?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suncoAppId?: SortOrder
    suncoAppKey?: SortOrder
    suncoAppSecret?: SortOrder
    zdAPIToken?: SortOrder
    resource?: SortOrder
    clientsId?: SortOrder
  }

  export type zdconnectorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    host?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    suncoAppId?: SortOrder
    suncoAppKey?: SortOrder
    suncoAppSecret?: SortOrder
    zdAPIToken?: SortOrder
    resource?: SortOrder
    clientsId?: SortOrder
  }

  export type zdconnectorSumOrderByAggregateInput = {
    id?: SortOrder
    clientsId?: SortOrder
  }

  export type omnicrmCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type omnicrmAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type omnicrmMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type omnicrmMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type omnicrmSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChannelListRelationFilter = {
    every?: channelWhereInput
    some?: channelWhereInput
    none?: channelWhereInput
  }

  export type IntegrationListRelationFilter = {
    every?: integrationWhereInput
    some?: integrationWhereInput
    none?: integrationWhereInput
  }

  export type channelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type integrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    origin_id?: SortOrder
  }

  export type clientsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type clientsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    origin_id?: SortOrder
  }

  export type clientsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    origin_id?: SortOrder
  }

  export type clientsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntegrationNullableScalarRelationFilter = {
    is?: integrationWhereInput | null
    isNot?: integrationWhereInput | null
  }

  export type credentCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    integrationId?: SortOrder
  }

  export type credentAvgOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
  }

  export type credentMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    integrationId?: SortOrder
  }

  export type credentMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    integrationId?: SortOrder
  }

  export type credentSumOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
  }

  export type CredentListRelationFilter = {
    every?: credentWhereInput
    some?: credentWhereInput
    none?: credentWhereInput
  }

  export type credentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type integrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    f_chat?: SortOrder
    f_review?: SortOrder
    f_cancel?: SortOrder
    f_rr?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    clientsId?: SortOrder
  }

  export type integrationAvgOrderByAggregateInput = {
    id?: SortOrder
    clientsId?: SortOrder
  }

  export type integrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    f_chat?: SortOrder
    f_review?: SortOrder
    f_cancel?: SortOrder
    f_rr?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    clientsId?: SortOrder
  }

  export type integrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseUrl?: SortOrder
    f_chat?: SortOrder
    f_review?: SortOrder
    f_cancel?: SortOrder
    f_rr?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    clientsId?: SortOrder
  }

  export type integrationSumOrderByAggregateInput = {
    id?: SortOrder
    clientsId?: SortOrder
  }

  export type Order_itemsScalarRelationFilter = {
    is?: order_itemsWhereInput
    isNot?: order_itemsWhereInput
  }

  export type return_line_itemCountOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    refund_service_fee?: SortOrder
    currency?: SortOrder
    refund_subtotal?: SortOrder
    refund_total?: SortOrder
    order_itemsId?: SortOrder
    return_refundId?: SortOrder
  }

  export type return_line_itemAvgOrderByAggregateInput = {
    id?: SortOrder
    refund_service_fee?: SortOrder
    refund_subtotal?: SortOrder
    refund_total?: SortOrder
    order_itemsId?: SortOrder
    return_refundId?: SortOrder
  }

  export type return_line_itemMaxOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    refund_service_fee?: SortOrder
    currency?: SortOrder
    refund_subtotal?: SortOrder
    refund_total?: SortOrder
    order_itemsId?: SortOrder
    return_refundId?: SortOrder
  }

  export type return_line_itemMinOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    refund_service_fee?: SortOrder
    currency?: SortOrder
    refund_subtotal?: SortOrder
    refund_total?: SortOrder
    order_itemsId?: SortOrder
    return_refundId?: SortOrder
  }

  export type return_line_itemSumOrderByAggregateInput = {
    id?: SortOrder
    refund_service_fee?: SortOrder
    refund_subtotal?: SortOrder
    refund_total?: SortOrder
    order_itemsId?: SortOrder
    return_refundId?: SortOrder
  }

  export type OrdersScalarRelationFilter = {
    is?: ordersWhereInput
    isNot?: ordersWhereInput
  }

  export type return_refundCountOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    return_type?: SortOrder
    return_reason?: SortOrder
    ordersId?: SortOrder
  }

  export type return_refundAvgOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
    ordersId?: SortOrder
  }

  export type return_refundMaxOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    return_type?: SortOrder
    return_reason?: SortOrder
    ordersId?: SortOrder
  }

  export type return_refundMinOrderByAggregateInput = {
    id?: SortOrder
    origin_id?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    return_type?: SortOrder
    return_reason?: SortOrder
    ordersId?: SortOrder
  }

  export type return_refundSumOrderByAggregateInput = {
    id?: SortOrder
    total_amount?: SortOrder
    ordersId?: SortOrder
  }

  export type ordersCreateNestedManyWithoutCustomersInput = {
    create?: XOR<ordersCreateWithoutCustomersInput, ordersUncheckedCreateWithoutCustomersInput> | ordersCreateWithoutCustomersInput[] | ordersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomersInput | ordersCreateOrConnectWithoutCustomersInput[]
    createMany?: ordersCreateManyCustomersInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type ordersUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<ordersCreateWithoutCustomersInput, ordersUncheckedCreateWithoutCustomersInput> | ordersCreateWithoutCustomersInput[] | ordersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomersInput | ordersCreateOrConnectWithoutCustomersInput[]
    createMany?: ordersCreateManyCustomersInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ordersUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<ordersCreateWithoutCustomersInput, ordersUncheckedCreateWithoutCustomersInput> | ordersCreateWithoutCustomersInput[] | ordersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomersInput | ordersCreateOrConnectWithoutCustomersInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutCustomersInput | ordersUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: ordersCreateManyCustomersInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutCustomersInput | ordersUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutCustomersInput | ordersUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ordersUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<ordersCreateWithoutCustomersInput, ordersUncheckedCreateWithoutCustomersInput> | ordersCreateWithoutCustomersInput[] | ordersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomersInput | ordersCreateOrConnectWithoutCustomersInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutCustomersInput | ordersUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: ordersCreateManyCustomersInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutCustomersInput | ordersUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutCustomersInput | ordersUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type productsCreateNestedOneWithoutProduct_imgInput = {
    create?: XOR<productsCreateWithoutProduct_imgInput, productsUncheckedCreateWithoutProduct_imgInput>
    connectOrCreate?: productsCreateOrConnectWithoutProduct_imgInput
    connect?: productsWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type productsUpdateOneWithoutProduct_imgNestedInput = {
    create?: XOR<productsCreateWithoutProduct_imgInput, productsUncheckedCreateWithoutProduct_imgInput>
    connectOrCreate?: productsCreateOrConnectWithoutProduct_imgInput
    upsert?: productsUpsertWithoutProduct_imgInput
    disconnect?: productsWhereInput | boolean
    delete?: productsWhereInput | boolean
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutProduct_imgInput, productsUpdateWithoutProduct_imgInput>, productsUncheckedUpdateWithoutProduct_imgInput>
  }

  export type clientsCreateNestedOneWithoutChannelInput = {
    create?: XOR<clientsCreateWithoutChannelInput, clientsUncheckedCreateWithoutChannelInput>
    connectOrCreate?: clientsCreateOrConnectWithoutChannelInput
    connect?: clientsWhereUniqueInput
  }

  export type storeCreateNestedManyWithoutChannelInput = {
    create?: XOR<storeCreateWithoutChannelInput, storeUncheckedCreateWithoutChannelInput> | storeCreateWithoutChannelInput[] | storeUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: storeCreateOrConnectWithoutChannelInput | storeCreateOrConnectWithoutChannelInput[]
    createMany?: storeCreateManyChannelInputEnvelope
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
  }

  export type storeUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<storeCreateWithoutChannelInput, storeUncheckedCreateWithoutChannelInput> | storeCreateWithoutChannelInput[] | storeUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: storeCreateOrConnectWithoutChannelInput | storeCreateOrConnectWithoutChannelInput[]
    createMany?: storeCreateManyChannelInputEnvelope
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
  }

  export type clientsUpdateOneWithoutChannelNestedInput = {
    create?: XOR<clientsCreateWithoutChannelInput, clientsUncheckedCreateWithoutChannelInput>
    connectOrCreate?: clientsCreateOrConnectWithoutChannelInput
    upsert?: clientsUpsertWithoutChannelInput
    disconnect?: clientsWhereInput | boolean
    delete?: clientsWhereInput | boolean
    connect?: clientsWhereUniqueInput
    update?: XOR<XOR<clientsUpdateToOneWithWhereWithoutChannelInput, clientsUpdateWithoutChannelInput>, clientsUncheckedUpdateWithoutChannelInput>
  }

  export type storeUpdateManyWithoutChannelNestedInput = {
    create?: XOR<storeCreateWithoutChannelInput, storeUncheckedCreateWithoutChannelInput> | storeCreateWithoutChannelInput[] | storeUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: storeCreateOrConnectWithoutChannelInput | storeCreateOrConnectWithoutChannelInput[]
    upsert?: storeUpsertWithWhereUniqueWithoutChannelInput | storeUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: storeCreateManyChannelInputEnvelope
    set?: storeWhereUniqueInput | storeWhereUniqueInput[]
    disconnect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    delete?: storeWhereUniqueInput | storeWhereUniqueInput[]
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    update?: storeUpdateWithWhereUniqueWithoutChannelInput | storeUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: storeUpdateManyWithWhereWithoutChannelInput | storeUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: storeScalarWhereInput | storeScalarWhereInput[]
  }

  export type storeUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<storeCreateWithoutChannelInput, storeUncheckedCreateWithoutChannelInput> | storeCreateWithoutChannelInput[] | storeUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: storeCreateOrConnectWithoutChannelInput | storeCreateOrConnectWithoutChannelInput[]
    upsert?: storeUpsertWithWhereUniqueWithoutChannelInput | storeUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: storeCreateManyChannelInputEnvelope
    set?: storeWhereUniqueInput | storeWhereUniqueInput[]
    disconnect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    delete?: storeWhereUniqueInput | storeWhereUniqueInput[]
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    update?: storeUpdateWithWhereUniqueWithoutChannelInput | storeUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: storeUpdateManyWithWhereWithoutChannelInput | storeUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: storeScalarWhereInput | storeScalarWhereInput[]
  }

  export type omnichatCreateNestedManyWithoutStoreInput = {
    create?: XOR<omnichatCreateWithoutStoreInput, omnichatUncheckedCreateWithoutStoreInput> | omnichatCreateWithoutStoreInput[] | omnichatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: omnichatCreateOrConnectWithoutStoreInput | omnichatCreateOrConnectWithoutStoreInput[]
    createMany?: omnichatCreateManyStoreInputEnvelope
    connect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
  }

  export type ordersCreateNestedManyWithoutStoreInput = {
    create?: XOR<ordersCreateWithoutStoreInput, ordersUncheckedCreateWithoutStoreInput> | ordersCreateWithoutStoreInput[] | ordersUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutStoreInput | ordersCreateOrConnectWithoutStoreInput[]
    createMany?: ordersCreateManyStoreInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type productsCreateNestedManyWithoutStoreInput = {
    create?: XOR<productsCreateWithoutStoreInput, productsUncheckedCreateWithoutStoreInput> | productsCreateWithoutStoreInput[] | productsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: productsCreateOrConnectWithoutStoreInput | productsCreateOrConnectWithoutStoreInput[]
    createMany?: productsCreateManyStoreInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type channelCreateNestedOneWithoutStoreInput = {
    create?: XOR<channelCreateWithoutStoreInput, channelUncheckedCreateWithoutStoreInput>
    connectOrCreate?: channelCreateOrConnectWithoutStoreInput
    connect?: channelWhereUniqueInput
  }

  export type omnichatUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<omnichatCreateWithoutStoreInput, omnichatUncheckedCreateWithoutStoreInput> | omnichatCreateWithoutStoreInput[] | omnichatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: omnichatCreateOrConnectWithoutStoreInput | omnichatCreateOrConnectWithoutStoreInput[]
    createMany?: omnichatCreateManyStoreInputEnvelope
    connect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
  }

  export type ordersUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ordersCreateWithoutStoreInput, ordersUncheckedCreateWithoutStoreInput> | ordersCreateWithoutStoreInput[] | ordersUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutStoreInput | ordersCreateOrConnectWithoutStoreInput[]
    createMany?: ordersCreateManyStoreInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type productsUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<productsCreateWithoutStoreInput, productsUncheckedCreateWithoutStoreInput> | productsCreateWithoutStoreInput[] | productsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: productsCreateOrConnectWithoutStoreInput | productsCreateOrConnectWithoutStoreInput[]
    createMany?: productsCreateManyStoreInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type omnichatUpdateManyWithoutStoreNestedInput = {
    create?: XOR<omnichatCreateWithoutStoreInput, omnichatUncheckedCreateWithoutStoreInput> | omnichatCreateWithoutStoreInput[] | omnichatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: omnichatCreateOrConnectWithoutStoreInput | omnichatCreateOrConnectWithoutStoreInput[]
    upsert?: omnichatUpsertWithWhereUniqueWithoutStoreInput | omnichatUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: omnichatCreateManyStoreInputEnvelope
    set?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    disconnect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    delete?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    connect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    update?: omnichatUpdateWithWhereUniqueWithoutStoreInput | omnichatUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: omnichatUpdateManyWithWhereWithoutStoreInput | omnichatUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: omnichatScalarWhereInput | omnichatScalarWhereInput[]
  }

  export type ordersUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ordersCreateWithoutStoreInput, ordersUncheckedCreateWithoutStoreInput> | ordersCreateWithoutStoreInput[] | ordersUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutStoreInput | ordersCreateOrConnectWithoutStoreInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutStoreInput | ordersUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ordersCreateManyStoreInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutStoreInput | ordersUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutStoreInput | ordersUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type productsUpdateManyWithoutStoreNestedInput = {
    create?: XOR<productsCreateWithoutStoreInput, productsUncheckedCreateWithoutStoreInput> | productsCreateWithoutStoreInput[] | productsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: productsCreateOrConnectWithoutStoreInput | productsCreateOrConnectWithoutStoreInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutStoreInput | productsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: productsCreateManyStoreInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutStoreInput | productsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: productsUpdateManyWithWhereWithoutStoreInput | productsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type channelUpdateOneWithoutStoreNestedInput = {
    create?: XOR<channelCreateWithoutStoreInput, channelUncheckedCreateWithoutStoreInput>
    connectOrCreate?: channelCreateOrConnectWithoutStoreInput
    upsert?: channelUpsertWithoutStoreInput
    disconnect?: channelWhereInput | boolean
    delete?: channelWhereInput | boolean
    connect?: channelWhereUniqueInput
    update?: XOR<XOR<channelUpdateToOneWithWhereWithoutStoreInput, channelUpdateWithoutStoreInput>, channelUncheckedUpdateWithoutStoreInput>
  }

  export type omnichatUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<omnichatCreateWithoutStoreInput, omnichatUncheckedCreateWithoutStoreInput> | omnichatCreateWithoutStoreInput[] | omnichatUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: omnichatCreateOrConnectWithoutStoreInput | omnichatCreateOrConnectWithoutStoreInput[]
    upsert?: omnichatUpsertWithWhereUniqueWithoutStoreInput | omnichatUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: omnichatCreateManyStoreInputEnvelope
    set?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    disconnect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    delete?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    connect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    update?: omnichatUpdateWithWhereUniqueWithoutStoreInput | omnichatUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: omnichatUpdateManyWithWhereWithoutStoreInput | omnichatUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: omnichatScalarWhereInput | omnichatScalarWhereInput[]
  }

  export type ordersUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ordersCreateWithoutStoreInput, ordersUncheckedCreateWithoutStoreInput> | ordersCreateWithoutStoreInput[] | ordersUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutStoreInput | ordersCreateOrConnectWithoutStoreInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutStoreInput | ordersUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ordersCreateManyStoreInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutStoreInput | ordersUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutStoreInput | ordersUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type productsUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<productsCreateWithoutStoreInput, productsUncheckedCreateWithoutStoreInput> | productsCreateWithoutStoreInput[] | productsUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: productsCreateOrConnectWithoutStoreInput | productsCreateOrConnectWithoutStoreInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutStoreInput | productsUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: productsCreateManyStoreInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutStoreInput | productsUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: productsUpdateManyWithWhereWithoutStoreInput | productsUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type order_itemsCreateNestedManyWithoutProductsInput = {
    create?: XOR<order_itemsCreateWithoutProductsInput, order_itemsUncheckedCreateWithoutProductsInput> | order_itemsCreateWithoutProductsInput[] | order_itemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutProductsInput | order_itemsCreateOrConnectWithoutProductsInput[]
    createMany?: order_itemsCreateManyProductsInputEnvelope
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
  }

  export type storeCreateNestedOneWithoutProductsInput = {
    create?: XOR<storeCreateWithoutProductsInput, storeUncheckedCreateWithoutProductsInput>
    connectOrCreate?: storeCreateOrConnectWithoutProductsInput
    connect?: storeWhereUniqueInput
  }

  export type products_imgCreateNestedManyWithoutProductsInput = {
    create?: XOR<products_imgCreateWithoutProductsInput, products_imgUncheckedCreateWithoutProductsInput> | products_imgCreateWithoutProductsInput[] | products_imgUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: products_imgCreateOrConnectWithoutProductsInput | products_imgCreateOrConnectWithoutProductsInput[]
    createMany?: products_imgCreateManyProductsInputEnvelope
    connect?: products_imgWhereUniqueInput | products_imgWhereUniqueInput[]
  }

  export type order_itemsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<order_itemsCreateWithoutProductsInput, order_itemsUncheckedCreateWithoutProductsInput> | order_itemsCreateWithoutProductsInput[] | order_itemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutProductsInput | order_itemsCreateOrConnectWithoutProductsInput[]
    createMany?: order_itemsCreateManyProductsInputEnvelope
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
  }

  export type products_imgUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<products_imgCreateWithoutProductsInput, products_imgUncheckedCreateWithoutProductsInput> | products_imgCreateWithoutProductsInput[] | products_imgUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: products_imgCreateOrConnectWithoutProductsInput | products_imgCreateOrConnectWithoutProductsInput[]
    createMany?: products_imgCreateManyProductsInputEnvelope
    connect?: products_imgWhereUniqueInput | products_imgWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type order_itemsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<order_itemsCreateWithoutProductsInput, order_itemsUncheckedCreateWithoutProductsInput> | order_itemsCreateWithoutProductsInput[] | order_itemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutProductsInput | order_itemsCreateOrConnectWithoutProductsInput[]
    upsert?: order_itemsUpsertWithWhereUniqueWithoutProductsInput | order_itemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: order_itemsCreateManyProductsInputEnvelope
    set?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    disconnect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    delete?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    update?: order_itemsUpdateWithWhereUniqueWithoutProductsInput | order_itemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: order_itemsUpdateManyWithWhereWithoutProductsInput | order_itemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
  }

  export type storeUpdateOneWithoutProductsNestedInput = {
    create?: XOR<storeCreateWithoutProductsInput, storeUncheckedCreateWithoutProductsInput>
    connectOrCreate?: storeCreateOrConnectWithoutProductsInput
    upsert?: storeUpsertWithoutProductsInput
    disconnect?: storeWhereInput | boolean
    delete?: storeWhereInput | boolean
    connect?: storeWhereUniqueInput
    update?: XOR<XOR<storeUpdateToOneWithWhereWithoutProductsInput, storeUpdateWithoutProductsInput>, storeUncheckedUpdateWithoutProductsInput>
  }

  export type products_imgUpdateManyWithoutProductsNestedInput = {
    create?: XOR<products_imgCreateWithoutProductsInput, products_imgUncheckedCreateWithoutProductsInput> | products_imgCreateWithoutProductsInput[] | products_imgUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: products_imgCreateOrConnectWithoutProductsInput | products_imgCreateOrConnectWithoutProductsInput[]
    upsert?: products_imgUpsertWithWhereUniqueWithoutProductsInput | products_imgUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: products_imgCreateManyProductsInputEnvelope
    set?: products_imgWhereUniqueInput | products_imgWhereUniqueInput[]
    disconnect?: products_imgWhereUniqueInput | products_imgWhereUniqueInput[]
    delete?: products_imgWhereUniqueInput | products_imgWhereUniqueInput[]
    connect?: products_imgWhereUniqueInput | products_imgWhereUniqueInput[]
    update?: products_imgUpdateWithWhereUniqueWithoutProductsInput | products_imgUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: products_imgUpdateManyWithWhereWithoutProductsInput | products_imgUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: products_imgScalarWhereInput | products_imgScalarWhereInput[]
  }

  export type order_itemsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<order_itemsCreateWithoutProductsInput, order_itemsUncheckedCreateWithoutProductsInput> | order_itemsCreateWithoutProductsInput[] | order_itemsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutProductsInput | order_itemsCreateOrConnectWithoutProductsInput[]
    upsert?: order_itemsUpsertWithWhereUniqueWithoutProductsInput | order_itemsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: order_itemsCreateManyProductsInputEnvelope
    set?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    disconnect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    delete?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    update?: order_itemsUpdateWithWhereUniqueWithoutProductsInput | order_itemsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: order_itemsUpdateManyWithWhereWithoutProductsInput | order_itemsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
  }

  export type products_imgUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<products_imgCreateWithoutProductsInput, products_imgUncheckedCreateWithoutProductsInput> | products_imgCreateWithoutProductsInput[] | products_imgUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: products_imgCreateOrConnectWithoutProductsInput | products_imgCreateOrConnectWithoutProductsInput[]
    upsert?: products_imgUpsertWithWhereUniqueWithoutProductsInput | products_imgUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: products_imgCreateManyProductsInputEnvelope
    set?: products_imgWhereUniqueInput | products_imgWhereUniqueInput[]
    disconnect?: products_imgWhereUniqueInput | products_imgWhereUniqueInput[]
    delete?: products_imgWhereUniqueInput | products_imgWhereUniqueInput[]
    connect?: products_imgWhereUniqueInput | products_imgWhereUniqueInput[]
    update?: products_imgUpdateWithWhereUniqueWithoutProductsInput | products_imgUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: products_imgUpdateManyWithWhereWithoutProductsInput | products_imgUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: products_imgScalarWhereInput | products_imgScalarWhereInput[]
  }

  export type ordersCreateNestedOneWithoutOrder_itemsInput = {
    create?: XOR<ordersCreateWithoutOrder_itemsInput, ordersUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutOrder_itemsInput
    connect?: ordersWhereUniqueInput
  }

  export type productsCreateNestedOneWithoutOrder_itemsInput = {
    create?: XOR<productsCreateWithoutOrder_itemsInput, productsUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: productsCreateOrConnectWithoutOrder_itemsInput
    connect?: productsWhereUniqueInput
  }

  export type return_line_itemCreateNestedManyWithoutItemInput = {
    create?: XOR<return_line_itemCreateWithoutItemInput, return_line_itemUncheckedCreateWithoutItemInput> | return_line_itemCreateWithoutItemInput[] | return_line_itemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: return_line_itemCreateOrConnectWithoutItemInput | return_line_itemCreateOrConnectWithoutItemInput[]
    createMany?: return_line_itemCreateManyItemInputEnvelope
    connect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
  }

  export type return_line_itemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<return_line_itemCreateWithoutItemInput, return_line_itemUncheckedCreateWithoutItemInput> | return_line_itemCreateWithoutItemInput[] | return_line_itemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: return_line_itemCreateOrConnectWithoutItemInput | return_line_itemCreateOrConnectWithoutItemInput[]
    createMany?: return_line_itemCreateManyItemInputEnvelope
    connect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
  }

  export type ordersUpdateOneWithoutOrder_itemsNestedInput = {
    create?: XOR<ordersCreateWithoutOrder_itemsInput, ordersUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutOrder_itemsInput
    upsert?: ordersUpsertWithoutOrder_itemsInput
    disconnect?: ordersWhereInput | boolean
    delete?: ordersWhereInput | boolean
    connect?: ordersWhereUniqueInput
    update?: XOR<XOR<ordersUpdateToOneWithWhereWithoutOrder_itemsInput, ordersUpdateWithoutOrder_itemsInput>, ordersUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type productsUpdateOneWithoutOrder_itemsNestedInput = {
    create?: XOR<productsCreateWithoutOrder_itemsInput, productsUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: productsCreateOrConnectWithoutOrder_itemsInput
    upsert?: productsUpsertWithoutOrder_itemsInput
    disconnect?: productsWhereInput | boolean
    delete?: productsWhereInput | boolean
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutOrder_itemsInput, productsUpdateWithoutOrder_itemsInput>, productsUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type return_line_itemUpdateManyWithoutItemNestedInput = {
    create?: XOR<return_line_itemCreateWithoutItemInput, return_line_itemUncheckedCreateWithoutItemInput> | return_line_itemCreateWithoutItemInput[] | return_line_itemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: return_line_itemCreateOrConnectWithoutItemInput | return_line_itemCreateOrConnectWithoutItemInput[]
    upsert?: return_line_itemUpsertWithWhereUniqueWithoutItemInput | return_line_itemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: return_line_itemCreateManyItemInputEnvelope
    set?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    disconnect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    delete?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    connect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    update?: return_line_itemUpdateWithWhereUniqueWithoutItemInput | return_line_itemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: return_line_itemUpdateManyWithWhereWithoutItemInput | return_line_itemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: return_line_itemScalarWhereInput | return_line_itemScalarWhereInput[]
  }

  export type return_line_itemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<return_line_itemCreateWithoutItemInput, return_line_itemUncheckedCreateWithoutItemInput> | return_line_itemCreateWithoutItemInput[] | return_line_itemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: return_line_itemCreateOrConnectWithoutItemInput | return_line_itemCreateOrConnectWithoutItemInput[]
    upsert?: return_line_itemUpsertWithWhereUniqueWithoutItemInput | return_line_itemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: return_line_itemCreateManyItemInputEnvelope
    set?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    disconnect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    delete?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    connect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    update?: return_line_itemUpdateWithWhereUniqueWithoutItemInput | return_line_itemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: return_line_itemUpdateManyWithWhereWithoutItemInput | return_line_itemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: return_line_itemScalarWhereInput | return_line_itemScalarWhereInput[]
  }

  export type ordersCreateNestedManyWithoutLogisticInput = {
    create?: XOR<ordersCreateWithoutLogisticInput, ordersUncheckedCreateWithoutLogisticInput> | ordersCreateWithoutLogisticInput[] | ordersUncheckedCreateWithoutLogisticInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutLogisticInput | ordersCreateOrConnectWithoutLogisticInput[]
    createMany?: ordersCreateManyLogisticInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type ordersUncheckedCreateNestedManyWithoutLogisticInput = {
    create?: XOR<ordersCreateWithoutLogisticInput, ordersUncheckedCreateWithoutLogisticInput> | ordersCreateWithoutLogisticInput[] | ordersUncheckedCreateWithoutLogisticInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutLogisticInput | ordersCreateOrConnectWithoutLogisticInput[]
    createMany?: ordersCreateManyLogisticInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type ordersUpdateManyWithoutLogisticNestedInput = {
    create?: XOR<ordersCreateWithoutLogisticInput, ordersUncheckedCreateWithoutLogisticInput> | ordersCreateWithoutLogisticInput[] | ordersUncheckedCreateWithoutLogisticInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutLogisticInput | ordersCreateOrConnectWithoutLogisticInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutLogisticInput | ordersUpsertWithWhereUniqueWithoutLogisticInput[]
    createMany?: ordersCreateManyLogisticInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutLogisticInput | ordersUpdateWithWhereUniqueWithoutLogisticInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutLogisticInput | ordersUpdateManyWithWhereWithoutLogisticInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type ordersUncheckedUpdateManyWithoutLogisticNestedInput = {
    create?: XOR<ordersCreateWithoutLogisticInput, ordersUncheckedCreateWithoutLogisticInput> | ordersCreateWithoutLogisticInput[] | ordersUncheckedCreateWithoutLogisticInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutLogisticInput | ordersCreateOrConnectWithoutLogisticInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutLogisticInput | ordersUpsertWithWhereUniqueWithoutLogisticInput[]
    createMany?: ordersCreateManyLogisticInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutLogisticInput | ordersUpdateWithWhereUniqueWithoutLogisticInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutLogisticInput | ordersUpdateManyWithWhereWithoutLogisticInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type order_itemsCreateNestedManyWithoutOrdersInput = {
    create?: XOR<order_itemsCreateWithoutOrdersInput, order_itemsUncheckedCreateWithoutOrdersInput> | order_itemsCreateWithoutOrdersInput[] | order_itemsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutOrdersInput | order_itemsCreateOrConnectWithoutOrdersInput[]
    createMany?: order_itemsCreateManyOrdersInputEnvelope
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
  }

  export type customersCreateNestedOneWithoutOrdersInput = {
    create?: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: customersCreateOrConnectWithoutOrdersInput
    connect?: customersWhereUniqueInput
  }

  export type logisticCreateNestedOneWithoutOrdersInput = {
    create?: XOR<logisticCreateWithoutOrdersInput, logisticUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: logisticCreateOrConnectWithoutOrdersInput
    connect?: logisticWhereUniqueInput
  }

  export type storeCreateNestedOneWithoutOrdersInput = {
    create?: XOR<storeCreateWithoutOrdersInput, storeUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: storeCreateOrConnectWithoutOrdersInput
    connect?: storeWhereUniqueInput
  }

  export type return_refundCreateNestedOneWithoutOrderInput = {
    create?: XOR<return_refundCreateWithoutOrderInput, return_refundUncheckedCreateWithoutOrderInput>
    connectOrCreate?: return_refundCreateOrConnectWithoutOrderInput
    connect?: return_refundWhereUniqueInput
  }

  export type order_itemsUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<order_itemsCreateWithoutOrdersInput, order_itemsUncheckedCreateWithoutOrdersInput> | order_itemsCreateWithoutOrdersInput[] | order_itemsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutOrdersInput | order_itemsCreateOrConnectWithoutOrdersInput[]
    createMany?: order_itemsCreateManyOrdersInputEnvelope
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
  }

  export type return_refundUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<return_refundCreateWithoutOrderInput, return_refundUncheckedCreateWithoutOrderInput>
    connectOrCreate?: return_refundCreateOrConnectWithoutOrderInput
    connect?: return_refundWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type order_itemsUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<order_itemsCreateWithoutOrdersInput, order_itemsUncheckedCreateWithoutOrdersInput> | order_itemsCreateWithoutOrdersInput[] | order_itemsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutOrdersInput | order_itemsCreateOrConnectWithoutOrdersInput[]
    upsert?: order_itemsUpsertWithWhereUniqueWithoutOrdersInput | order_itemsUpsertWithWhereUniqueWithoutOrdersInput[]
    createMany?: order_itemsCreateManyOrdersInputEnvelope
    set?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    disconnect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    delete?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    update?: order_itemsUpdateWithWhereUniqueWithoutOrdersInput | order_itemsUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: order_itemsUpdateManyWithWhereWithoutOrdersInput | order_itemsUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
  }

  export type customersUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: customersCreateOrConnectWithoutOrdersInput
    upsert?: customersUpsertWithoutOrdersInput
    disconnect?: customersWhereInput | boolean
    delete?: customersWhereInput | boolean
    connect?: customersWhereUniqueInput
    update?: XOR<XOR<customersUpdateToOneWithWhereWithoutOrdersInput, customersUpdateWithoutOrdersInput>, customersUncheckedUpdateWithoutOrdersInput>
  }

  export type logisticUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<logisticCreateWithoutOrdersInput, logisticUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: logisticCreateOrConnectWithoutOrdersInput
    upsert?: logisticUpsertWithoutOrdersInput
    disconnect?: logisticWhereInput | boolean
    delete?: logisticWhereInput | boolean
    connect?: logisticWhereUniqueInput
    update?: XOR<XOR<logisticUpdateToOneWithWhereWithoutOrdersInput, logisticUpdateWithoutOrdersInput>, logisticUncheckedUpdateWithoutOrdersInput>
  }

  export type storeUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<storeCreateWithoutOrdersInput, storeUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: storeCreateOrConnectWithoutOrdersInput
    upsert?: storeUpsertWithoutOrdersInput
    disconnect?: storeWhereInput | boolean
    delete?: storeWhereInput | boolean
    connect?: storeWhereUniqueInput
    update?: XOR<XOR<storeUpdateToOneWithWhereWithoutOrdersInput, storeUpdateWithoutOrdersInput>, storeUncheckedUpdateWithoutOrdersInput>
  }

  export type return_refundUpdateOneWithoutOrderNestedInput = {
    create?: XOR<return_refundCreateWithoutOrderInput, return_refundUncheckedCreateWithoutOrderInput>
    connectOrCreate?: return_refundCreateOrConnectWithoutOrderInput
    upsert?: return_refundUpsertWithoutOrderInput
    disconnect?: return_refundWhereInput | boolean
    delete?: return_refundWhereInput | boolean
    connect?: return_refundWhereUniqueInput
    update?: XOR<XOR<return_refundUpdateToOneWithWhereWithoutOrderInput, return_refundUpdateWithoutOrderInput>, return_refundUncheckedUpdateWithoutOrderInput>
  }

  export type order_itemsUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<order_itemsCreateWithoutOrdersInput, order_itemsUncheckedCreateWithoutOrdersInput> | order_itemsCreateWithoutOrdersInput[] | order_itemsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutOrdersInput | order_itemsCreateOrConnectWithoutOrdersInput[]
    upsert?: order_itemsUpsertWithWhereUniqueWithoutOrdersInput | order_itemsUpsertWithWhereUniqueWithoutOrdersInput[]
    createMany?: order_itemsCreateManyOrdersInputEnvelope
    set?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    disconnect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    delete?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    update?: order_itemsUpdateWithWhereUniqueWithoutOrdersInput | order_itemsUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: order_itemsUpdateManyWithWhereWithoutOrdersInput | order_itemsUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
  }

  export type return_refundUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<return_refundCreateWithoutOrderInput, return_refundUncheckedCreateWithoutOrderInput>
    connectOrCreate?: return_refundCreateOrConnectWithoutOrderInput
    upsert?: return_refundUpsertWithoutOrderInput
    disconnect?: return_refundWhereInput | boolean
    delete?: return_refundWhereInput | boolean
    connect?: return_refundWhereUniqueInput
    update?: XOR<XOR<return_refundUpdateToOneWithWhereWithoutOrderInput, return_refundUpdateWithoutOrderInput>, return_refundUncheckedUpdateWithoutOrderInput>
  }

  export type omnichatCreateNestedManyWithoutOmnichat_userInput = {
    create?: XOR<omnichatCreateWithoutOmnichat_userInput, omnichatUncheckedCreateWithoutOmnichat_userInput> | omnichatCreateWithoutOmnichat_userInput[] | omnichatUncheckedCreateWithoutOmnichat_userInput[]
    connectOrCreate?: omnichatCreateOrConnectWithoutOmnichat_userInput | omnichatCreateOrConnectWithoutOmnichat_userInput[]
    createMany?: omnichatCreateManyOmnichat_userInputEnvelope
    connect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
  }

  export type omnichat_lineCreateNestedManyWithoutOmnichat_userInput = {
    create?: XOR<omnichat_lineCreateWithoutOmnichat_userInput, omnichat_lineUncheckedCreateWithoutOmnichat_userInput> | omnichat_lineCreateWithoutOmnichat_userInput[] | omnichat_lineUncheckedCreateWithoutOmnichat_userInput[]
    connectOrCreate?: omnichat_lineCreateOrConnectWithoutOmnichat_userInput | omnichat_lineCreateOrConnectWithoutOmnichat_userInput[]
    createMany?: omnichat_lineCreateManyOmnichat_userInputEnvelope
    connect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
  }

  export type omnichatUncheckedCreateNestedManyWithoutOmnichat_userInput = {
    create?: XOR<omnichatCreateWithoutOmnichat_userInput, omnichatUncheckedCreateWithoutOmnichat_userInput> | omnichatCreateWithoutOmnichat_userInput[] | omnichatUncheckedCreateWithoutOmnichat_userInput[]
    connectOrCreate?: omnichatCreateOrConnectWithoutOmnichat_userInput | omnichatCreateOrConnectWithoutOmnichat_userInput[]
    createMany?: omnichatCreateManyOmnichat_userInputEnvelope
    connect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
  }

  export type omnichat_lineUncheckedCreateNestedManyWithoutOmnichat_userInput = {
    create?: XOR<omnichat_lineCreateWithoutOmnichat_userInput, omnichat_lineUncheckedCreateWithoutOmnichat_userInput> | omnichat_lineCreateWithoutOmnichat_userInput[] | omnichat_lineUncheckedCreateWithoutOmnichat_userInput[]
    connectOrCreate?: omnichat_lineCreateOrConnectWithoutOmnichat_userInput | omnichat_lineCreateOrConnectWithoutOmnichat_userInput[]
    createMany?: omnichat_lineCreateManyOmnichat_userInputEnvelope
    connect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
  }

  export type omnichatUpdateManyWithoutOmnichat_userNestedInput = {
    create?: XOR<omnichatCreateWithoutOmnichat_userInput, omnichatUncheckedCreateWithoutOmnichat_userInput> | omnichatCreateWithoutOmnichat_userInput[] | omnichatUncheckedCreateWithoutOmnichat_userInput[]
    connectOrCreate?: omnichatCreateOrConnectWithoutOmnichat_userInput | omnichatCreateOrConnectWithoutOmnichat_userInput[]
    upsert?: omnichatUpsertWithWhereUniqueWithoutOmnichat_userInput | omnichatUpsertWithWhereUniqueWithoutOmnichat_userInput[]
    createMany?: omnichatCreateManyOmnichat_userInputEnvelope
    set?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    disconnect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    delete?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    connect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    update?: omnichatUpdateWithWhereUniqueWithoutOmnichat_userInput | omnichatUpdateWithWhereUniqueWithoutOmnichat_userInput[]
    updateMany?: omnichatUpdateManyWithWhereWithoutOmnichat_userInput | omnichatUpdateManyWithWhereWithoutOmnichat_userInput[]
    deleteMany?: omnichatScalarWhereInput | omnichatScalarWhereInput[]
  }

  export type omnichat_lineUpdateManyWithoutOmnichat_userNestedInput = {
    create?: XOR<omnichat_lineCreateWithoutOmnichat_userInput, omnichat_lineUncheckedCreateWithoutOmnichat_userInput> | omnichat_lineCreateWithoutOmnichat_userInput[] | omnichat_lineUncheckedCreateWithoutOmnichat_userInput[]
    connectOrCreate?: omnichat_lineCreateOrConnectWithoutOmnichat_userInput | omnichat_lineCreateOrConnectWithoutOmnichat_userInput[]
    upsert?: omnichat_lineUpsertWithWhereUniqueWithoutOmnichat_userInput | omnichat_lineUpsertWithWhereUniqueWithoutOmnichat_userInput[]
    createMany?: omnichat_lineCreateManyOmnichat_userInputEnvelope
    set?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    disconnect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    delete?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    connect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    update?: omnichat_lineUpdateWithWhereUniqueWithoutOmnichat_userInput | omnichat_lineUpdateWithWhereUniqueWithoutOmnichat_userInput[]
    updateMany?: omnichat_lineUpdateManyWithWhereWithoutOmnichat_userInput | omnichat_lineUpdateManyWithWhereWithoutOmnichat_userInput[]
    deleteMany?: omnichat_lineScalarWhereInput | omnichat_lineScalarWhereInput[]
  }

  export type omnichatUncheckedUpdateManyWithoutOmnichat_userNestedInput = {
    create?: XOR<omnichatCreateWithoutOmnichat_userInput, omnichatUncheckedCreateWithoutOmnichat_userInput> | omnichatCreateWithoutOmnichat_userInput[] | omnichatUncheckedCreateWithoutOmnichat_userInput[]
    connectOrCreate?: omnichatCreateOrConnectWithoutOmnichat_userInput | omnichatCreateOrConnectWithoutOmnichat_userInput[]
    upsert?: omnichatUpsertWithWhereUniqueWithoutOmnichat_userInput | omnichatUpsertWithWhereUniqueWithoutOmnichat_userInput[]
    createMany?: omnichatCreateManyOmnichat_userInputEnvelope
    set?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    disconnect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    delete?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    connect?: omnichatWhereUniqueInput | omnichatWhereUniqueInput[]
    update?: omnichatUpdateWithWhereUniqueWithoutOmnichat_userInput | omnichatUpdateWithWhereUniqueWithoutOmnichat_userInput[]
    updateMany?: omnichatUpdateManyWithWhereWithoutOmnichat_userInput | omnichatUpdateManyWithWhereWithoutOmnichat_userInput[]
    deleteMany?: omnichatScalarWhereInput | omnichatScalarWhereInput[]
  }

  export type omnichat_lineUncheckedUpdateManyWithoutOmnichat_userNestedInput = {
    create?: XOR<omnichat_lineCreateWithoutOmnichat_userInput, omnichat_lineUncheckedCreateWithoutOmnichat_userInput> | omnichat_lineCreateWithoutOmnichat_userInput[] | omnichat_lineUncheckedCreateWithoutOmnichat_userInput[]
    connectOrCreate?: omnichat_lineCreateOrConnectWithoutOmnichat_userInput | omnichat_lineCreateOrConnectWithoutOmnichat_userInput[]
    upsert?: omnichat_lineUpsertWithWhereUniqueWithoutOmnichat_userInput | omnichat_lineUpsertWithWhereUniqueWithoutOmnichat_userInput[]
    createMany?: omnichat_lineCreateManyOmnichat_userInputEnvelope
    set?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    disconnect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    delete?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    connect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    update?: omnichat_lineUpdateWithWhereUniqueWithoutOmnichat_userInput | omnichat_lineUpdateWithWhereUniqueWithoutOmnichat_userInput[]
    updateMany?: omnichat_lineUpdateManyWithWhereWithoutOmnichat_userInput | omnichat_lineUpdateManyWithWhereWithoutOmnichat_userInput[]
    deleteMany?: omnichat_lineScalarWhereInput | omnichat_lineScalarWhereInput[]
  }

  export type omnichat_userCreateNestedOneWithoutOmnichatInput = {
    create?: XOR<omnichat_userCreateWithoutOmnichatInput, omnichat_userUncheckedCreateWithoutOmnichatInput>
    connectOrCreate?: omnichat_userCreateOrConnectWithoutOmnichatInput
    connect?: omnichat_userWhereUniqueInput
  }

  export type storeCreateNestedOneWithoutOmnichatInput = {
    create?: XOR<storeCreateWithoutOmnichatInput, storeUncheckedCreateWithoutOmnichatInput>
    connectOrCreate?: storeCreateOrConnectWithoutOmnichatInput
    connect?: storeWhereUniqueInput
  }

  export type omnichat_lineCreateNestedManyWithoutOmnichatInput = {
    create?: XOR<omnichat_lineCreateWithoutOmnichatInput, omnichat_lineUncheckedCreateWithoutOmnichatInput> | omnichat_lineCreateWithoutOmnichatInput[] | omnichat_lineUncheckedCreateWithoutOmnichatInput[]
    connectOrCreate?: omnichat_lineCreateOrConnectWithoutOmnichatInput | omnichat_lineCreateOrConnectWithoutOmnichatInput[]
    createMany?: omnichat_lineCreateManyOmnichatInputEnvelope
    connect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
  }

  export type omnichat_lineUncheckedCreateNestedManyWithoutOmnichatInput = {
    create?: XOR<omnichat_lineCreateWithoutOmnichatInput, omnichat_lineUncheckedCreateWithoutOmnichatInput> | omnichat_lineCreateWithoutOmnichatInput[] | omnichat_lineUncheckedCreateWithoutOmnichatInput[]
    connectOrCreate?: omnichat_lineCreateOrConnectWithoutOmnichatInput | omnichat_lineCreateOrConnectWithoutOmnichatInput[]
    createMany?: omnichat_lineCreateManyOmnichatInputEnvelope
    connect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type omnichat_userUpdateOneWithoutOmnichatNestedInput = {
    create?: XOR<omnichat_userCreateWithoutOmnichatInput, omnichat_userUncheckedCreateWithoutOmnichatInput>
    connectOrCreate?: omnichat_userCreateOrConnectWithoutOmnichatInput
    upsert?: omnichat_userUpsertWithoutOmnichatInput
    disconnect?: omnichat_userWhereInput | boolean
    delete?: omnichat_userWhereInput | boolean
    connect?: omnichat_userWhereUniqueInput
    update?: XOR<XOR<omnichat_userUpdateToOneWithWhereWithoutOmnichatInput, omnichat_userUpdateWithoutOmnichatInput>, omnichat_userUncheckedUpdateWithoutOmnichatInput>
  }

  export type storeUpdateOneWithoutOmnichatNestedInput = {
    create?: XOR<storeCreateWithoutOmnichatInput, storeUncheckedCreateWithoutOmnichatInput>
    connectOrCreate?: storeCreateOrConnectWithoutOmnichatInput
    upsert?: storeUpsertWithoutOmnichatInput
    disconnect?: storeWhereInput | boolean
    delete?: storeWhereInput | boolean
    connect?: storeWhereUniqueInput
    update?: XOR<XOR<storeUpdateToOneWithWhereWithoutOmnichatInput, storeUpdateWithoutOmnichatInput>, storeUncheckedUpdateWithoutOmnichatInput>
  }

  export type omnichat_lineUpdateManyWithoutOmnichatNestedInput = {
    create?: XOR<omnichat_lineCreateWithoutOmnichatInput, omnichat_lineUncheckedCreateWithoutOmnichatInput> | omnichat_lineCreateWithoutOmnichatInput[] | omnichat_lineUncheckedCreateWithoutOmnichatInput[]
    connectOrCreate?: omnichat_lineCreateOrConnectWithoutOmnichatInput | omnichat_lineCreateOrConnectWithoutOmnichatInput[]
    upsert?: omnichat_lineUpsertWithWhereUniqueWithoutOmnichatInput | omnichat_lineUpsertWithWhereUniqueWithoutOmnichatInput[]
    createMany?: omnichat_lineCreateManyOmnichatInputEnvelope
    set?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    disconnect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    delete?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    connect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    update?: omnichat_lineUpdateWithWhereUniqueWithoutOmnichatInput | omnichat_lineUpdateWithWhereUniqueWithoutOmnichatInput[]
    updateMany?: omnichat_lineUpdateManyWithWhereWithoutOmnichatInput | omnichat_lineUpdateManyWithWhereWithoutOmnichatInput[]
    deleteMany?: omnichat_lineScalarWhereInput | omnichat_lineScalarWhereInput[]
  }

  export type omnichat_lineUncheckedUpdateManyWithoutOmnichatNestedInput = {
    create?: XOR<omnichat_lineCreateWithoutOmnichatInput, omnichat_lineUncheckedCreateWithoutOmnichatInput> | omnichat_lineCreateWithoutOmnichatInput[] | omnichat_lineUncheckedCreateWithoutOmnichatInput[]
    connectOrCreate?: omnichat_lineCreateOrConnectWithoutOmnichatInput | omnichat_lineCreateOrConnectWithoutOmnichatInput[]
    upsert?: omnichat_lineUpsertWithWhereUniqueWithoutOmnichatInput | omnichat_lineUpsertWithWhereUniqueWithoutOmnichatInput[]
    createMany?: omnichat_lineCreateManyOmnichatInputEnvelope
    set?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    disconnect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    delete?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    connect?: omnichat_lineWhereUniqueInput | omnichat_lineWhereUniqueInput[]
    update?: omnichat_lineUpdateWithWhereUniqueWithoutOmnichatInput | omnichat_lineUpdateWithWhereUniqueWithoutOmnichatInput[]
    updateMany?: omnichat_lineUpdateManyWithWhereWithoutOmnichatInput | omnichat_lineUpdateManyWithWhereWithoutOmnichatInput[]
    deleteMany?: omnichat_lineScalarWhereInput | omnichat_lineScalarWhereInput[]
  }

  export type omnichatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<omnichatCreateWithoutMessagesInput, omnichatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: omnichatCreateOrConnectWithoutMessagesInput
    connect?: omnichatWhereUniqueInput
  }

  export type omnichat_userCreateNestedOneWithoutOmnichat_lineInput = {
    create?: XOR<omnichat_userCreateWithoutOmnichat_lineInput, omnichat_userUncheckedCreateWithoutOmnichat_lineInput>
    connectOrCreate?: omnichat_userCreateOrConnectWithoutOmnichat_lineInput
    connect?: omnichat_userWhereUniqueInput
  }

  export type omnichatUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<omnichatCreateWithoutMessagesInput, omnichatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: omnichatCreateOrConnectWithoutMessagesInput
    upsert?: omnichatUpsertWithoutMessagesInput
    disconnect?: omnichatWhereInput | boolean
    delete?: omnichatWhereInput | boolean
    connect?: omnichatWhereUniqueInput
    update?: XOR<XOR<omnichatUpdateToOneWithWhereWithoutMessagesInput, omnichatUpdateWithoutMessagesInput>, omnichatUncheckedUpdateWithoutMessagesInput>
  }

  export type omnichat_userUpdateOneWithoutOmnichat_lineNestedInput = {
    create?: XOR<omnichat_userCreateWithoutOmnichat_lineInput, omnichat_userUncheckedCreateWithoutOmnichat_lineInput>
    connectOrCreate?: omnichat_userCreateOrConnectWithoutOmnichat_lineInput
    upsert?: omnichat_userUpsertWithoutOmnichat_lineInput
    disconnect?: omnichat_userWhereInput | boolean
    delete?: omnichat_userWhereInput | boolean
    connect?: omnichat_userWhereUniqueInput
    update?: XOR<XOR<omnichat_userUpdateToOneWithWhereWithoutOmnichat_lineInput, omnichat_userUpdateWithoutOmnichat_lineInput>, omnichat_userUncheckedUpdateWithoutOmnichat_lineInput>
  }

  export type channelCreateNestedManyWithoutClientInput = {
    create?: XOR<channelCreateWithoutClientInput, channelUncheckedCreateWithoutClientInput> | channelCreateWithoutClientInput[] | channelUncheckedCreateWithoutClientInput[]
    connectOrCreate?: channelCreateOrConnectWithoutClientInput | channelCreateOrConnectWithoutClientInput[]
    createMany?: channelCreateManyClientInputEnvelope
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
  }

  export type integrationCreateNestedManyWithoutClientsInput = {
    create?: XOR<integrationCreateWithoutClientsInput, integrationUncheckedCreateWithoutClientsInput> | integrationCreateWithoutClientsInput[] | integrationUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: integrationCreateOrConnectWithoutClientsInput | integrationCreateOrConnectWithoutClientsInput[]
    createMany?: integrationCreateManyClientsInputEnvelope
    connect?: integrationWhereUniqueInput | integrationWhereUniqueInput[]
  }

  export type channelUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<channelCreateWithoutClientInput, channelUncheckedCreateWithoutClientInput> | channelCreateWithoutClientInput[] | channelUncheckedCreateWithoutClientInput[]
    connectOrCreate?: channelCreateOrConnectWithoutClientInput | channelCreateOrConnectWithoutClientInput[]
    createMany?: channelCreateManyClientInputEnvelope
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
  }

  export type integrationUncheckedCreateNestedManyWithoutClientsInput = {
    create?: XOR<integrationCreateWithoutClientsInput, integrationUncheckedCreateWithoutClientsInput> | integrationCreateWithoutClientsInput[] | integrationUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: integrationCreateOrConnectWithoutClientsInput | integrationCreateOrConnectWithoutClientsInput[]
    createMany?: integrationCreateManyClientsInputEnvelope
    connect?: integrationWhereUniqueInput | integrationWhereUniqueInput[]
  }

  export type channelUpdateManyWithoutClientNestedInput = {
    create?: XOR<channelCreateWithoutClientInput, channelUncheckedCreateWithoutClientInput> | channelCreateWithoutClientInput[] | channelUncheckedCreateWithoutClientInput[]
    connectOrCreate?: channelCreateOrConnectWithoutClientInput | channelCreateOrConnectWithoutClientInput[]
    upsert?: channelUpsertWithWhereUniqueWithoutClientInput | channelUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: channelCreateManyClientInputEnvelope
    set?: channelWhereUniqueInput | channelWhereUniqueInput[]
    disconnect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    delete?: channelWhereUniqueInput | channelWhereUniqueInput[]
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    update?: channelUpdateWithWhereUniqueWithoutClientInput | channelUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: channelUpdateManyWithWhereWithoutClientInput | channelUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: channelScalarWhereInput | channelScalarWhereInput[]
  }

  export type integrationUpdateManyWithoutClientsNestedInput = {
    create?: XOR<integrationCreateWithoutClientsInput, integrationUncheckedCreateWithoutClientsInput> | integrationCreateWithoutClientsInput[] | integrationUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: integrationCreateOrConnectWithoutClientsInput | integrationCreateOrConnectWithoutClientsInput[]
    upsert?: integrationUpsertWithWhereUniqueWithoutClientsInput | integrationUpsertWithWhereUniqueWithoutClientsInput[]
    createMany?: integrationCreateManyClientsInputEnvelope
    set?: integrationWhereUniqueInput | integrationWhereUniqueInput[]
    disconnect?: integrationWhereUniqueInput | integrationWhereUniqueInput[]
    delete?: integrationWhereUniqueInput | integrationWhereUniqueInput[]
    connect?: integrationWhereUniqueInput | integrationWhereUniqueInput[]
    update?: integrationUpdateWithWhereUniqueWithoutClientsInput | integrationUpdateWithWhereUniqueWithoutClientsInput[]
    updateMany?: integrationUpdateManyWithWhereWithoutClientsInput | integrationUpdateManyWithWhereWithoutClientsInput[]
    deleteMany?: integrationScalarWhereInput | integrationScalarWhereInput[]
  }

  export type channelUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<channelCreateWithoutClientInput, channelUncheckedCreateWithoutClientInput> | channelCreateWithoutClientInput[] | channelUncheckedCreateWithoutClientInput[]
    connectOrCreate?: channelCreateOrConnectWithoutClientInput | channelCreateOrConnectWithoutClientInput[]
    upsert?: channelUpsertWithWhereUniqueWithoutClientInput | channelUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: channelCreateManyClientInputEnvelope
    set?: channelWhereUniqueInput | channelWhereUniqueInput[]
    disconnect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    delete?: channelWhereUniqueInput | channelWhereUniqueInput[]
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    update?: channelUpdateWithWhereUniqueWithoutClientInput | channelUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: channelUpdateManyWithWhereWithoutClientInput | channelUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: channelScalarWhereInput | channelScalarWhereInput[]
  }

  export type integrationUncheckedUpdateManyWithoutClientsNestedInput = {
    create?: XOR<integrationCreateWithoutClientsInput, integrationUncheckedCreateWithoutClientsInput> | integrationCreateWithoutClientsInput[] | integrationUncheckedCreateWithoutClientsInput[]
    connectOrCreate?: integrationCreateOrConnectWithoutClientsInput | integrationCreateOrConnectWithoutClientsInput[]
    upsert?: integrationUpsertWithWhereUniqueWithoutClientsInput | integrationUpsertWithWhereUniqueWithoutClientsInput[]
    createMany?: integrationCreateManyClientsInputEnvelope
    set?: integrationWhereUniqueInput | integrationWhereUniqueInput[]
    disconnect?: integrationWhereUniqueInput | integrationWhereUniqueInput[]
    delete?: integrationWhereUniqueInput | integrationWhereUniqueInput[]
    connect?: integrationWhereUniqueInput | integrationWhereUniqueInput[]
    update?: integrationUpdateWithWhereUniqueWithoutClientsInput | integrationUpdateWithWhereUniqueWithoutClientsInput[]
    updateMany?: integrationUpdateManyWithWhereWithoutClientsInput | integrationUpdateManyWithWhereWithoutClientsInput[]
    deleteMany?: integrationScalarWhereInput | integrationScalarWhereInput[]
  }

  export type integrationCreateNestedOneWithoutCredentInput = {
    create?: XOR<integrationCreateWithoutCredentInput, integrationUncheckedCreateWithoutCredentInput>
    connectOrCreate?: integrationCreateOrConnectWithoutCredentInput
    connect?: integrationWhereUniqueInput
  }

  export type integrationUpdateOneWithoutCredentNestedInput = {
    create?: XOR<integrationCreateWithoutCredentInput, integrationUncheckedCreateWithoutCredentInput>
    connectOrCreate?: integrationCreateOrConnectWithoutCredentInput
    upsert?: integrationUpsertWithoutCredentInput
    disconnect?: integrationWhereInput | boolean
    delete?: integrationWhereInput | boolean
    connect?: integrationWhereUniqueInput
    update?: XOR<XOR<integrationUpdateToOneWithWhereWithoutCredentInput, integrationUpdateWithoutCredentInput>, integrationUncheckedUpdateWithoutCredentInput>
  }

  export type credentCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<credentCreateWithoutIntegrationInput, credentUncheckedCreateWithoutIntegrationInput> | credentCreateWithoutIntegrationInput[] | credentUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: credentCreateOrConnectWithoutIntegrationInput | credentCreateOrConnectWithoutIntegrationInput[]
    createMany?: credentCreateManyIntegrationInputEnvelope
    connect?: credentWhereUniqueInput | credentWhereUniqueInput[]
  }

  export type clientsCreateNestedOneWithoutIntegrationInput = {
    create?: XOR<clientsCreateWithoutIntegrationInput, clientsUncheckedCreateWithoutIntegrationInput>
    connectOrCreate?: clientsCreateOrConnectWithoutIntegrationInput
    connect?: clientsWhereUniqueInput
  }

  export type credentUncheckedCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<credentCreateWithoutIntegrationInput, credentUncheckedCreateWithoutIntegrationInput> | credentCreateWithoutIntegrationInput[] | credentUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: credentCreateOrConnectWithoutIntegrationInput | credentCreateOrConnectWithoutIntegrationInput[]
    createMany?: credentCreateManyIntegrationInputEnvelope
    connect?: credentWhereUniqueInput | credentWhereUniqueInput[]
  }

  export type credentUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<credentCreateWithoutIntegrationInput, credentUncheckedCreateWithoutIntegrationInput> | credentCreateWithoutIntegrationInput[] | credentUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: credentCreateOrConnectWithoutIntegrationInput | credentCreateOrConnectWithoutIntegrationInput[]
    upsert?: credentUpsertWithWhereUniqueWithoutIntegrationInput | credentUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: credentCreateManyIntegrationInputEnvelope
    set?: credentWhereUniqueInput | credentWhereUniqueInput[]
    disconnect?: credentWhereUniqueInput | credentWhereUniqueInput[]
    delete?: credentWhereUniqueInput | credentWhereUniqueInput[]
    connect?: credentWhereUniqueInput | credentWhereUniqueInput[]
    update?: credentUpdateWithWhereUniqueWithoutIntegrationInput | credentUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: credentUpdateManyWithWhereWithoutIntegrationInput | credentUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: credentScalarWhereInput | credentScalarWhereInput[]
  }

  export type clientsUpdateOneWithoutIntegrationNestedInput = {
    create?: XOR<clientsCreateWithoutIntegrationInput, clientsUncheckedCreateWithoutIntegrationInput>
    connectOrCreate?: clientsCreateOrConnectWithoutIntegrationInput
    upsert?: clientsUpsertWithoutIntegrationInput
    disconnect?: clientsWhereInput | boolean
    delete?: clientsWhereInput | boolean
    connect?: clientsWhereUniqueInput
    update?: XOR<XOR<clientsUpdateToOneWithWhereWithoutIntegrationInput, clientsUpdateWithoutIntegrationInput>, clientsUncheckedUpdateWithoutIntegrationInput>
  }

  export type credentUncheckedUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<credentCreateWithoutIntegrationInput, credentUncheckedCreateWithoutIntegrationInput> | credentCreateWithoutIntegrationInput[] | credentUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: credentCreateOrConnectWithoutIntegrationInput | credentCreateOrConnectWithoutIntegrationInput[]
    upsert?: credentUpsertWithWhereUniqueWithoutIntegrationInput | credentUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: credentCreateManyIntegrationInputEnvelope
    set?: credentWhereUniqueInput | credentWhereUniqueInput[]
    disconnect?: credentWhereUniqueInput | credentWhereUniqueInput[]
    delete?: credentWhereUniqueInput | credentWhereUniqueInput[]
    connect?: credentWhereUniqueInput | credentWhereUniqueInput[]
    update?: credentUpdateWithWhereUniqueWithoutIntegrationInput | credentUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: credentUpdateManyWithWhereWithoutIntegrationInput | credentUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: credentScalarWhereInput | credentScalarWhereInput[]
  }

  export type order_itemsCreateNestedOneWithoutReturn_line_itemInput = {
    create?: XOR<order_itemsCreateWithoutReturn_line_itemInput, order_itemsUncheckedCreateWithoutReturn_line_itemInput>
    connectOrCreate?: order_itemsCreateOrConnectWithoutReturn_line_itemInput
    connect?: order_itemsWhereUniqueInput
  }

  export type return_refundCreateNestedOneWithoutLine_itemInput = {
    create?: XOR<return_refundCreateWithoutLine_itemInput, return_refundUncheckedCreateWithoutLine_itemInput>
    connectOrCreate?: return_refundCreateOrConnectWithoutLine_itemInput
    connect?: return_refundWhereUniqueInput
  }

  export type order_itemsUpdateOneRequiredWithoutReturn_line_itemNestedInput = {
    create?: XOR<order_itemsCreateWithoutReturn_line_itemInput, order_itemsUncheckedCreateWithoutReturn_line_itemInput>
    connectOrCreate?: order_itemsCreateOrConnectWithoutReturn_line_itemInput
    upsert?: order_itemsUpsertWithoutReturn_line_itemInput
    connect?: order_itemsWhereUniqueInput
    update?: XOR<XOR<order_itemsUpdateToOneWithWhereWithoutReturn_line_itemInput, order_itemsUpdateWithoutReturn_line_itemInput>, order_itemsUncheckedUpdateWithoutReturn_line_itemInput>
  }

  export type return_refundUpdateOneWithoutLine_itemNestedInput = {
    create?: XOR<return_refundCreateWithoutLine_itemInput, return_refundUncheckedCreateWithoutLine_itemInput>
    connectOrCreate?: return_refundCreateOrConnectWithoutLine_itemInput
    upsert?: return_refundUpsertWithoutLine_itemInput
    disconnect?: return_refundWhereInput | boolean
    delete?: return_refundWhereInput | boolean
    connect?: return_refundWhereUniqueInput
    update?: XOR<XOR<return_refundUpdateToOneWithWhereWithoutLine_itemInput, return_refundUpdateWithoutLine_itemInput>, return_refundUncheckedUpdateWithoutLine_itemInput>
  }

  export type ordersCreateNestedOneWithoutReturn_refundInput = {
    create?: XOR<ordersCreateWithoutReturn_refundInput, ordersUncheckedCreateWithoutReturn_refundInput>
    connectOrCreate?: ordersCreateOrConnectWithoutReturn_refundInput
    connect?: ordersWhereUniqueInput
  }

  export type return_line_itemCreateNestedManyWithoutReturn_refundInput = {
    create?: XOR<return_line_itemCreateWithoutReturn_refundInput, return_line_itemUncheckedCreateWithoutReturn_refundInput> | return_line_itemCreateWithoutReturn_refundInput[] | return_line_itemUncheckedCreateWithoutReturn_refundInput[]
    connectOrCreate?: return_line_itemCreateOrConnectWithoutReturn_refundInput | return_line_itemCreateOrConnectWithoutReturn_refundInput[]
    createMany?: return_line_itemCreateManyReturn_refundInputEnvelope
    connect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
  }

  export type return_line_itemUncheckedCreateNestedManyWithoutReturn_refundInput = {
    create?: XOR<return_line_itemCreateWithoutReturn_refundInput, return_line_itemUncheckedCreateWithoutReturn_refundInput> | return_line_itemCreateWithoutReturn_refundInput[] | return_line_itemUncheckedCreateWithoutReturn_refundInput[]
    connectOrCreate?: return_line_itemCreateOrConnectWithoutReturn_refundInput | return_line_itemCreateOrConnectWithoutReturn_refundInput[]
    createMany?: return_line_itemCreateManyReturn_refundInputEnvelope
    connect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
  }

  export type ordersUpdateOneRequiredWithoutReturn_refundNestedInput = {
    create?: XOR<ordersCreateWithoutReturn_refundInput, ordersUncheckedCreateWithoutReturn_refundInput>
    connectOrCreate?: ordersCreateOrConnectWithoutReturn_refundInput
    upsert?: ordersUpsertWithoutReturn_refundInput
    connect?: ordersWhereUniqueInput
    update?: XOR<XOR<ordersUpdateToOneWithWhereWithoutReturn_refundInput, ordersUpdateWithoutReturn_refundInput>, ordersUncheckedUpdateWithoutReturn_refundInput>
  }

  export type return_line_itemUpdateManyWithoutReturn_refundNestedInput = {
    create?: XOR<return_line_itemCreateWithoutReturn_refundInput, return_line_itemUncheckedCreateWithoutReturn_refundInput> | return_line_itemCreateWithoutReturn_refundInput[] | return_line_itemUncheckedCreateWithoutReturn_refundInput[]
    connectOrCreate?: return_line_itemCreateOrConnectWithoutReturn_refundInput | return_line_itemCreateOrConnectWithoutReturn_refundInput[]
    upsert?: return_line_itemUpsertWithWhereUniqueWithoutReturn_refundInput | return_line_itemUpsertWithWhereUniqueWithoutReturn_refundInput[]
    createMany?: return_line_itemCreateManyReturn_refundInputEnvelope
    set?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    disconnect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    delete?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    connect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    update?: return_line_itemUpdateWithWhereUniqueWithoutReturn_refundInput | return_line_itemUpdateWithWhereUniqueWithoutReturn_refundInput[]
    updateMany?: return_line_itemUpdateManyWithWhereWithoutReturn_refundInput | return_line_itemUpdateManyWithWhereWithoutReturn_refundInput[]
    deleteMany?: return_line_itemScalarWhereInput | return_line_itemScalarWhereInput[]
  }

  export type return_line_itemUncheckedUpdateManyWithoutReturn_refundNestedInput = {
    create?: XOR<return_line_itemCreateWithoutReturn_refundInput, return_line_itemUncheckedCreateWithoutReturn_refundInput> | return_line_itemCreateWithoutReturn_refundInput[] | return_line_itemUncheckedCreateWithoutReturn_refundInput[]
    connectOrCreate?: return_line_itemCreateOrConnectWithoutReturn_refundInput | return_line_itemCreateOrConnectWithoutReturn_refundInput[]
    upsert?: return_line_itemUpsertWithWhereUniqueWithoutReturn_refundInput | return_line_itemUpsertWithWhereUniqueWithoutReturn_refundInput[]
    createMany?: return_line_itemCreateManyReturn_refundInputEnvelope
    set?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    disconnect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    delete?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    connect?: return_line_itemWhereUniqueInput | return_line_itemWhereUniqueInput[]
    update?: return_line_itemUpdateWithWhereUniqueWithoutReturn_refundInput | return_line_itemUpdateWithWhereUniqueWithoutReturn_refundInput[]
    updateMany?: return_line_itemUpdateManyWithWhereWithoutReturn_refundInput | return_line_itemUpdateManyWithWhereWithoutReturn_refundInput[]
    deleteMany?: return_line_itemScalarWhereInput | return_line_itemScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type ordersCreateWithoutCustomersInput = {
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    order_items?: order_itemsCreateNestedManyWithoutOrdersInput
    logistic?: logisticCreateNestedOneWithoutOrdersInput
    store?: storeCreateNestedOneWithoutOrdersInput
    return_refund?: return_refundCreateNestedOneWithoutOrderInput
  }

  export type ordersUncheckedCreateWithoutCustomersInput = {
    id?: number
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    storeId?: number | null
    logisticId?: number | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    order_items?: order_itemsUncheckedCreateNestedManyWithoutOrdersInput
    return_refund?: return_refundUncheckedCreateNestedOneWithoutOrderInput
  }

  export type ordersCreateOrConnectWithoutCustomersInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutCustomersInput, ordersUncheckedCreateWithoutCustomersInput>
  }

  export type ordersCreateManyCustomersInputEnvelope = {
    data: ordersCreateManyCustomersInput | ordersCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type ordersUpsertWithWhereUniqueWithoutCustomersInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutCustomersInput, ordersUncheckedUpdateWithoutCustomersInput>
    create: XOR<ordersCreateWithoutCustomersInput, ordersUncheckedCreateWithoutCustomersInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutCustomersInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutCustomersInput, ordersUncheckedUpdateWithoutCustomersInput>
  }

  export type ordersUpdateManyWithWhereWithoutCustomersInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutCustomersInput>
  }

  export type ordersScalarWhereInput = {
    AND?: ordersScalarWhereInput | ordersScalarWhereInput[]
    OR?: ordersScalarWhereInput[]
    NOT?: ordersScalarWhereInput | ordersScalarWhereInput[]
    id?: IntFilter<"orders"> | number
    createdAt?: DateTimeFilter<"orders"> | Date | string
    status?: StringNullableFilter<"orders"> | string | null
    shop_id?: StringNullableFilter<"orders"> | string | null
    payment_id?: StringNullableFilter<"orders"> | string | null
    temp_id?: StringNullableFilter<"orders"> | string | null
    origin_id?: StringNullableFilter<"orders"> | string | null
    package_id?: StringNullableFilter<"orders"> | string | null
    invoice?: StringNullableFilter<"orders"> | string | null
    recp_name?: StringNullableFilter<"orders"> | string | null
    recp_phone?: StringNullableFilter<"orders"> | string | null
    recp_addr_full?: StringNullableFilter<"orders"> | string | null
    recp_addr_district?: StringNullableFilter<"orders"> | string | null
    recp_addr_city?: StringNullableFilter<"orders"> | string | null
    recp_addr_province?: StringNullableFilter<"orders"> | string | null
    recp_addr_country?: StringNullableFilter<"orders"> | string | null
    recp_addr_postal_code?: StringNullableFilter<"orders"> | string | null
    recp_addr_district_id?: StringNullableFilter<"orders"> | string | null
    recp_addr_city_id?: StringNullableFilter<"orders"> | string | null
    tracking_number?: StringNullableFilter<"orders"> | string | null
    ship_document_url?: StringNullableFilter<"orders"> | string | null
    recp_addr_province_id?: StringNullableFilter<"orders"> | string | null
    recp_addr_geo?: StringNullableFilter<"orders"> | string | null
    logistic_service?: StringNullableFilter<"orders"> | string | null
    origin_createdAt?: DateTimeFilter<"orders"> | Date | string
    accept_partial?: BoolNullableFilter<"orders"> | boolean | null
    device?: StringNullableFilter<"orders"> | string | null
    storeId?: IntNullableFilter<"orders"> | number | null
    customersId?: IntNullableFilter<"orders"> | number | null
    logisticId?: IntNullableFilter<"orders"> | number | null
    total_product_price?: IntNullableFilter<"orders"> | number | null
    shipping_price?: IntNullableFilter<"orders"> | number | null
    seller_discount?: IntNullableFilter<"orders"> | number | null
    platform_discount?: IntNullableFilter<"orders"> | number | null
    shipping_seller_discount?: IntNullableFilter<"orders"> | number | null
    shipping_platform_discount?: IntNullableFilter<"orders"> | number | null
    buyer_service_fee?: IntNullableFilter<"orders"> | number | null
    handling_fee?: IntNullableFilter<"orders"> | number | null
    shipping_insurance_fee?: IntNullableFilter<"orders"> | number | null
    item_insurance_fee?: IntNullableFilter<"orders"> | number | null
    total_amount?: IntNullableFilter<"orders"> | number | null
    updatedAt?: DateTimeFilter<"orders"> | Date | string
  }

  export type productsCreateWithoutProduct_imgInput = {
    origin_id?: string | null
    status?: string | null
    name?: string | null
    condition?: number | null
    desc?: string | null
    category?: number | null
    price?: number | null
    currency?: string | null
    createdAt?: Date | string
    weight?: number | null
    stock?: number | null
    sku?: string | null
    order_items?: order_itemsCreateNestedManyWithoutProductsInput
    store?: storeCreateNestedOneWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutProduct_imgInput = {
    id?: number
    origin_id?: string | null
    status?: string | null
    name?: string | null
    condition?: number | null
    desc?: string | null
    category?: number | null
    price?: number | null
    currency?: string | null
    createdAt?: Date | string
    weight?: number | null
    stock?: number | null
    sku?: string | null
    storeId?: number | null
    order_items?: order_itemsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutProduct_imgInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutProduct_imgInput, productsUncheckedCreateWithoutProduct_imgInput>
  }

  export type productsUpsertWithoutProduct_imgInput = {
    update: XOR<productsUpdateWithoutProduct_imgInput, productsUncheckedUpdateWithoutProduct_imgInput>
    create: XOR<productsCreateWithoutProduct_imgInput, productsUncheckedCreateWithoutProduct_imgInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutProduct_imgInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutProduct_imgInput, productsUncheckedUpdateWithoutProduct_imgInput>
  }

  export type productsUpdateWithoutProduct_imgInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    order_items?: order_itemsUpdateManyWithoutProductsNestedInput
    store?: storeUpdateOneWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutProduct_imgInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    order_items?: order_itemsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type clientsCreateWithoutChannelInput = {
    name: string
    origin_id?: string | null
    integration?: integrationCreateNestedManyWithoutClientsInput
  }

  export type clientsUncheckedCreateWithoutChannelInput = {
    id?: number
    name: string
    origin_id?: string | null
    integration?: integrationUncheckedCreateNestedManyWithoutClientsInput
  }

  export type clientsCreateOrConnectWithoutChannelInput = {
    where: clientsWhereUniqueInput
    create: XOR<clientsCreateWithoutChannelInput, clientsUncheckedCreateWithoutChannelInput>
  }

  export type storeCreateWithoutChannelInput = {
    name?: string | null
    origin_id?: string | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
    omnichat?: omnichatCreateNestedManyWithoutStoreInput
    orders?: ordersCreateNestedManyWithoutStoreInput
    products?: productsCreateNestedManyWithoutStoreInput
  }

  export type storeUncheckedCreateWithoutChannelInput = {
    id?: number
    name?: string | null
    origin_id?: string | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
    omnichat?: omnichatUncheckedCreateNestedManyWithoutStoreInput
    orders?: ordersUncheckedCreateNestedManyWithoutStoreInput
    products?: productsUncheckedCreateNestedManyWithoutStoreInput
  }

  export type storeCreateOrConnectWithoutChannelInput = {
    where: storeWhereUniqueInput
    create: XOR<storeCreateWithoutChannelInput, storeUncheckedCreateWithoutChannelInput>
  }

  export type storeCreateManyChannelInputEnvelope = {
    data: storeCreateManyChannelInput | storeCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type clientsUpsertWithoutChannelInput = {
    update: XOR<clientsUpdateWithoutChannelInput, clientsUncheckedUpdateWithoutChannelInput>
    create: XOR<clientsCreateWithoutChannelInput, clientsUncheckedCreateWithoutChannelInput>
    where?: clientsWhereInput
  }

  export type clientsUpdateToOneWithWhereWithoutChannelInput = {
    where?: clientsWhereInput
    data: XOR<clientsUpdateWithoutChannelInput, clientsUncheckedUpdateWithoutChannelInput>
  }

  export type clientsUpdateWithoutChannelInput = {
    name?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: integrationUpdateManyWithoutClientsNestedInput
  }

  export type clientsUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: integrationUncheckedUpdateManyWithoutClientsNestedInput
  }

  export type storeUpsertWithWhereUniqueWithoutChannelInput = {
    where: storeWhereUniqueInput
    update: XOR<storeUpdateWithoutChannelInput, storeUncheckedUpdateWithoutChannelInput>
    create: XOR<storeCreateWithoutChannelInput, storeUncheckedCreateWithoutChannelInput>
  }

  export type storeUpdateWithWhereUniqueWithoutChannelInput = {
    where: storeWhereUniqueInput
    data: XOR<storeUpdateWithoutChannelInput, storeUncheckedUpdateWithoutChannelInput>
  }

  export type storeUpdateManyWithWhereWithoutChannelInput = {
    where: storeScalarWhereInput
    data: XOR<storeUpdateManyMutationInput, storeUncheckedUpdateManyWithoutChannelInput>
  }

  export type storeScalarWhereInput = {
    AND?: storeScalarWhereInput | storeScalarWhereInput[]
    OR?: storeScalarWhereInput[]
    NOT?: storeScalarWhereInput | storeScalarWhereInput[]
    id?: IntFilter<"store"> | number
    name?: StringNullableFilter<"store"> | string | null
    origin_id?: StringNullableFilter<"store"> | string | null
    channelId?: IntNullableFilter<"store"> | number | null
    refresh_token?: StringNullableFilter<"store"> | string | null
    token?: StringNullableFilter<"store"> | string | null
    secondary_refresh_token?: StringNullableFilter<"store"> | string | null
    secondary_token?: StringNullableFilter<"store"> | string | null
    url?: StringNullableFilter<"store"> | string | null
    status?: StringNullableFilter<"store"> | string | null
  }

  export type omnichatCreateWithoutStoreInput = {
    origin_id?: string | null
    last_message: string
    last_messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    externalId?: string | null
    omnichat_user?: omnichat_userCreateNestedOneWithoutOmnichatInput
    messages?: omnichat_lineCreateNestedManyWithoutOmnichatInput
  }

  export type omnichatUncheckedCreateWithoutStoreInput = {
    id?: number
    origin_id?: string | null
    last_message: string
    last_messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    omnichat_userId?: number | null
    externalId?: string | null
    messages?: omnichat_lineUncheckedCreateNestedManyWithoutOmnichatInput
  }

  export type omnichatCreateOrConnectWithoutStoreInput = {
    where: omnichatWhereUniqueInput
    create: XOR<omnichatCreateWithoutStoreInput, omnichatUncheckedCreateWithoutStoreInput>
  }

  export type omnichatCreateManyStoreInputEnvelope = {
    data: omnichatCreateManyStoreInput | omnichatCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type ordersCreateWithoutStoreInput = {
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    order_items?: order_itemsCreateNestedManyWithoutOrdersInput
    customers?: customersCreateNestedOneWithoutOrdersInput
    logistic?: logisticCreateNestedOneWithoutOrdersInput
    return_refund?: return_refundCreateNestedOneWithoutOrderInput
  }

  export type ordersUncheckedCreateWithoutStoreInput = {
    id?: number
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    customersId?: number | null
    logisticId?: number | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    order_items?: order_itemsUncheckedCreateNestedManyWithoutOrdersInput
    return_refund?: return_refundUncheckedCreateNestedOneWithoutOrderInput
  }

  export type ordersCreateOrConnectWithoutStoreInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutStoreInput, ordersUncheckedCreateWithoutStoreInput>
  }

  export type ordersCreateManyStoreInputEnvelope = {
    data: ordersCreateManyStoreInput | ordersCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type productsCreateWithoutStoreInput = {
    origin_id?: string | null
    status?: string | null
    name?: string | null
    condition?: number | null
    desc?: string | null
    category?: number | null
    price?: number | null
    currency?: string | null
    createdAt?: Date | string
    weight?: number | null
    stock?: number | null
    sku?: string | null
    order_items?: order_itemsCreateNestedManyWithoutProductsInput
    product_img?: products_imgCreateNestedManyWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutStoreInput = {
    id?: number
    origin_id?: string | null
    status?: string | null
    name?: string | null
    condition?: number | null
    desc?: string | null
    category?: number | null
    price?: number | null
    currency?: string | null
    createdAt?: Date | string
    weight?: number | null
    stock?: number | null
    sku?: string | null
    order_items?: order_itemsUncheckedCreateNestedManyWithoutProductsInput
    product_img?: products_imgUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutStoreInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutStoreInput, productsUncheckedCreateWithoutStoreInput>
  }

  export type productsCreateManyStoreInputEnvelope = {
    data: productsCreateManyStoreInput | productsCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type channelCreateWithoutStoreInput = {
    name?: string | null
    client?: clientsCreateNestedOneWithoutChannelInput
  }

  export type channelUncheckedCreateWithoutStoreInput = {
    id?: number
    name?: string | null
    clientsId?: number | null
  }

  export type channelCreateOrConnectWithoutStoreInput = {
    where: channelWhereUniqueInput
    create: XOR<channelCreateWithoutStoreInput, channelUncheckedCreateWithoutStoreInput>
  }

  export type omnichatUpsertWithWhereUniqueWithoutStoreInput = {
    where: omnichatWhereUniqueInput
    update: XOR<omnichatUpdateWithoutStoreInput, omnichatUncheckedUpdateWithoutStoreInput>
    create: XOR<omnichatCreateWithoutStoreInput, omnichatUncheckedCreateWithoutStoreInput>
  }

  export type omnichatUpdateWithWhereUniqueWithoutStoreInput = {
    where: omnichatWhereUniqueInput
    data: XOR<omnichatUpdateWithoutStoreInput, omnichatUncheckedUpdateWithoutStoreInput>
  }

  export type omnichatUpdateManyWithWhereWithoutStoreInput = {
    where: omnichatScalarWhereInput
    data: XOR<omnichatUpdateManyMutationInput, omnichatUncheckedUpdateManyWithoutStoreInput>
  }

  export type omnichatScalarWhereInput = {
    AND?: omnichatScalarWhereInput | omnichatScalarWhereInput[]
    OR?: omnichatScalarWhereInput[]
    NOT?: omnichatScalarWhereInput | omnichatScalarWhereInput[]
    id?: IntFilter<"omnichat"> | number
    origin_id?: StringNullableFilter<"omnichat"> | string | null
    last_message?: StringFilter<"omnichat"> | string
    last_messageId?: StringNullableFilter<"omnichat"> | string | null
    createdAt?: DateTimeFilter<"omnichat"> | Date | string
    updatedAt?: DateTimeFilter<"omnichat"> | Date | string
    storeId?: IntNullableFilter<"omnichat"> | number | null
    omnichat_userId?: IntNullableFilter<"omnichat"> | number | null
    externalId?: StringNullableFilter<"omnichat"> | string | null
  }

  export type ordersUpsertWithWhereUniqueWithoutStoreInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutStoreInput, ordersUncheckedUpdateWithoutStoreInput>
    create: XOR<ordersCreateWithoutStoreInput, ordersUncheckedCreateWithoutStoreInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutStoreInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutStoreInput, ordersUncheckedUpdateWithoutStoreInput>
  }

  export type ordersUpdateManyWithWhereWithoutStoreInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutStoreInput>
  }

  export type productsUpsertWithWhereUniqueWithoutStoreInput = {
    where: productsWhereUniqueInput
    update: XOR<productsUpdateWithoutStoreInput, productsUncheckedUpdateWithoutStoreInput>
    create: XOR<productsCreateWithoutStoreInput, productsUncheckedCreateWithoutStoreInput>
  }

  export type productsUpdateWithWhereUniqueWithoutStoreInput = {
    where: productsWhereUniqueInput
    data: XOR<productsUpdateWithoutStoreInput, productsUncheckedUpdateWithoutStoreInput>
  }

  export type productsUpdateManyWithWhereWithoutStoreInput = {
    where: productsScalarWhereInput
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutStoreInput>
  }

  export type productsScalarWhereInput = {
    AND?: productsScalarWhereInput | productsScalarWhereInput[]
    OR?: productsScalarWhereInput[]
    NOT?: productsScalarWhereInput | productsScalarWhereInput[]
    id?: IntFilter<"products"> | number
    origin_id?: StringNullableFilter<"products"> | string | null
    status?: StringNullableFilter<"products"> | string | null
    name?: StringNullableFilter<"products"> | string | null
    condition?: IntNullableFilter<"products"> | number | null
    desc?: StringNullableFilter<"products"> | string | null
    category?: IntNullableFilter<"products"> | number | null
    price?: IntNullableFilter<"products"> | number | null
    currency?: StringNullableFilter<"products"> | string | null
    createdAt?: DateTimeFilter<"products"> | Date | string
    weight?: IntNullableFilter<"products"> | number | null
    stock?: IntNullableFilter<"products"> | number | null
    sku?: StringNullableFilter<"products"> | string | null
    storeId?: IntNullableFilter<"products"> | number | null
  }

  export type channelUpsertWithoutStoreInput = {
    update: XOR<channelUpdateWithoutStoreInput, channelUncheckedUpdateWithoutStoreInput>
    create: XOR<channelCreateWithoutStoreInput, channelUncheckedCreateWithoutStoreInput>
    where?: channelWhereInput
  }

  export type channelUpdateToOneWithWhereWithoutStoreInput = {
    where?: channelWhereInput
    data: XOR<channelUpdateWithoutStoreInput, channelUncheckedUpdateWithoutStoreInput>
  }

  export type channelUpdateWithoutStoreInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    client?: clientsUpdateOneWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    clientsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type order_itemsCreateWithoutProductsInput = {
    createdAt?: Date | string
    qty: number
    package_id?: string | null
    invoice?: string | null
    total_price: number
    notes?: string | null
    origin_id?: string | null
    orders?: ordersCreateNestedOneWithoutOrder_itemsInput
    return_line_item?: return_line_itemCreateNestedManyWithoutItemInput
  }

  export type order_itemsUncheckedCreateWithoutProductsInput = {
    id?: number
    createdAt?: Date | string
    qty: number
    package_id?: string | null
    invoice?: string | null
    total_price: number
    notes?: string | null
    ordersId?: number | null
    origin_id?: string | null
    return_line_item?: return_line_itemUncheckedCreateNestedManyWithoutItemInput
  }

  export type order_itemsCreateOrConnectWithoutProductsInput = {
    where: order_itemsWhereUniqueInput
    create: XOR<order_itemsCreateWithoutProductsInput, order_itemsUncheckedCreateWithoutProductsInput>
  }

  export type order_itemsCreateManyProductsInputEnvelope = {
    data: order_itemsCreateManyProductsInput | order_itemsCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type storeCreateWithoutProductsInput = {
    name?: string | null
    origin_id?: string | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
    omnichat?: omnichatCreateNestedManyWithoutStoreInput
    orders?: ordersCreateNestedManyWithoutStoreInput
    channel?: channelCreateNestedOneWithoutStoreInput
  }

  export type storeUncheckedCreateWithoutProductsInput = {
    id?: number
    name?: string | null
    origin_id?: string | null
    channelId?: number | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
    omnichat?: omnichatUncheckedCreateNestedManyWithoutStoreInput
    orders?: ordersUncheckedCreateNestedManyWithoutStoreInput
  }

  export type storeCreateOrConnectWithoutProductsInput = {
    where: storeWhereUniqueInput
    create: XOR<storeCreateWithoutProductsInput, storeUncheckedCreateWithoutProductsInput>
  }

  export type products_imgCreateWithoutProductsInput = {
    origin_id?: string | null
    filename?: string | null
    status?: string | null
    width?: number | null
    height?: number | null
    originalUrl?: string | null
    thumbnailUrl?: string | null
  }

  export type products_imgUncheckedCreateWithoutProductsInput = {
    id?: number
    origin_id?: string | null
    filename?: string | null
    status?: string | null
    width?: number | null
    height?: number | null
    originalUrl?: string | null
    thumbnailUrl?: string | null
  }

  export type products_imgCreateOrConnectWithoutProductsInput = {
    where: products_imgWhereUniqueInput
    create: XOR<products_imgCreateWithoutProductsInput, products_imgUncheckedCreateWithoutProductsInput>
  }

  export type products_imgCreateManyProductsInputEnvelope = {
    data: products_imgCreateManyProductsInput | products_imgCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type order_itemsUpsertWithWhereUniqueWithoutProductsInput = {
    where: order_itemsWhereUniqueInput
    update: XOR<order_itemsUpdateWithoutProductsInput, order_itemsUncheckedUpdateWithoutProductsInput>
    create: XOR<order_itemsCreateWithoutProductsInput, order_itemsUncheckedCreateWithoutProductsInput>
  }

  export type order_itemsUpdateWithWhereUniqueWithoutProductsInput = {
    where: order_itemsWhereUniqueInput
    data: XOR<order_itemsUpdateWithoutProductsInput, order_itemsUncheckedUpdateWithoutProductsInput>
  }

  export type order_itemsUpdateManyWithWhereWithoutProductsInput = {
    where: order_itemsScalarWhereInput
    data: XOR<order_itemsUpdateManyMutationInput, order_itemsUncheckedUpdateManyWithoutProductsInput>
  }

  export type order_itemsScalarWhereInput = {
    AND?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
    OR?: order_itemsScalarWhereInput[]
    NOT?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
    id?: IntFilter<"order_items"> | number
    createdAt?: DateTimeFilter<"order_items"> | Date | string
    qty?: IntFilter<"order_items"> | number
    package_id?: StringNullableFilter<"order_items"> | string | null
    invoice?: StringNullableFilter<"order_items"> | string | null
    total_price?: IntFilter<"order_items"> | number
    notes?: StringNullableFilter<"order_items"> | string | null
    ordersId?: IntNullableFilter<"order_items"> | number | null
    productsId?: IntNullableFilter<"order_items"> | number | null
    origin_id?: StringNullableFilter<"order_items"> | string | null
  }

  export type storeUpsertWithoutProductsInput = {
    update: XOR<storeUpdateWithoutProductsInput, storeUncheckedUpdateWithoutProductsInput>
    create: XOR<storeCreateWithoutProductsInput, storeUncheckedCreateWithoutProductsInput>
    where?: storeWhereInput
  }

  export type storeUpdateToOneWithWhereWithoutProductsInput = {
    where?: storeWhereInput
    data: XOR<storeUpdateWithoutProductsInput, storeUncheckedUpdateWithoutProductsInput>
  }

  export type storeUpdateWithoutProductsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUpdateManyWithoutStoreNestedInput
    orders?: ordersUpdateManyWithoutStoreNestedInput
    channel?: channelUpdateOneWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableIntFieldUpdateOperationsInput | number | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUncheckedUpdateManyWithoutStoreNestedInput
    orders?: ordersUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type products_imgUpsertWithWhereUniqueWithoutProductsInput = {
    where: products_imgWhereUniqueInput
    update: XOR<products_imgUpdateWithoutProductsInput, products_imgUncheckedUpdateWithoutProductsInput>
    create: XOR<products_imgCreateWithoutProductsInput, products_imgUncheckedCreateWithoutProductsInput>
  }

  export type products_imgUpdateWithWhereUniqueWithoutProductsInput = {
    where: products_imgWhereUniqueInput
    data: XOR<products_imgUpdateWithoutProductsInput, products_imgUncheckedUpdateWithoutProductsInput>
  }

  export type products_imgUpdateManyWithWhereWithoutProductsInput = {
    where: products_imgScalarWhereInput
    data: XOR<products_imgUpdateManyMutationInput, products_imgUncheckedUpdateManyWithoutProductsInput>
  }

  export type products_imgScalarWhereInput = {
    AND?: products_imgScalarWhereInput | products_imgScalarWhereInput[]
    OR?: products_imgScalarWhereInput[]
    NOT?: products_imgScalarWhereInput | products_imgScalarWhereInput[]
    id?: IntFilter<"products_img"> | number
    origin_id?: StringNullableFilter<"products_img"> | string | null
    filename?: StringNullableFilter<"products_img"> | string | null
    status?: StringNullableFilter<"products_img"> | string | null
    width?: IntNullableFilter<"products_img"> | number | null
    height?: IntNullableFilter<"products_img"> | number | null
    originalUrl?: StringNullableFilter<"products_img"> | string | null
    thumbnailUrl?: StringNullableFilter<"products_img"> | string | null
    productsId?: IntNullableFilter<"products_img"> | number | null
  }

  export type ordersCreateWithoutOrder_itemsInput = {
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    customers?: customersCreateNestedOneWithoutOrdersInput
    logistic?: logisticCreateNestedOneWithoutOrdersInput
    store?: storeCreateNestedOneWithoutOrdersInput
    return_refund?: return_refundCreateNestedOneWithoutOrderInput
  }

  export type ordersUncheckedCreateWithoutOrder_itemsInput = {
    id?: number
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    storeId?: number | null
    customersId?: number | null
    logisticId?: number | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    return_refund?: return_refundUncheckedCreateNestedOneWithoutOrderInput
  }

  export type ordersCreateOrConnectWithoutOrder_itemsInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutOrder_itemsInput, ordersUncheckedCreateWithoutOrder_itemsInput>
  }

  export type productsCreateWithoutOrder_itemsInput = {
    origin_id?: string | null
    status?: string | null
    name?: string | null
    condition?: number | null
    desc?: string | null
    category?: number | null
    price?: number | null
    currency?: string | null
    createdAt?: Date | string
    weight?: number | null
    stock?: number | null
    sku?: string | null
    store?: storeCreateNestedOneWithoutProductsInput
    product_img?: products_imgCreateNestedManyWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutOrder_itemsInput = {
    id?: number
    origin_id?: string | null
    status?: string | null
    name?: string | null
    condition?: number | null
    desc?: string | null
    category?: number | null
    price?: number | null
    currency?: string | null
    createdAt?: Date | string
    weight?: number | null
    stock?: number | null
    sku?: string | null
    storeId?: number | null
    product_img?: products_imgUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutOrder_itemsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutOrder_itemsInput, productsUncheckedCreateWithoutOrder_itemsInput>
  }

  export type return_line_itemCreateWithoutItemInput = {
    origin_id?: string | null
    refund_service_fee: number
    currency?: string | null
    refund_subtotal: number
    refund_total: number
    return_refund?: return_refundCreateNestedOneWithoutLine_itemInput
  }

  export type return_line_itemUncheckedCreateWithoutItemInput = {
    id?: number
    origin_id?: string | null
    refund_service_fee: number
    currency?: string | null
    refund_subtotal: number
    refund_total: number
    return_refundId?: number | null
  }

  export type return_line_itemCreateOrConnectWithoutItemInput = {
    where: return_line_itemWhereUniqueInput
    create: XOR<return_line_itemCreateWithoutItemInput, return_line_itemUncheckedCreateWithoutItemInput>
  }

  export type return_line_itemCreateManyItemInputEnvelope = {
    data: return_line_itemCreateManyItemInput | return_line_itemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ordersUpsertWithoutOrder_itemsInput = {
    update: XOR<ordersUpdateWithoutOrder_itemsInput, ordersUncheckedUpdateWithoutOrder_itemsInput>
    create: XOR<ordersCreateWithoutOrder_itemsInput, ordersUncheckedCreateWithoutOrder_itemsInput>
    where?: ordersWhereInput
  }

  export type ordersUpdateToOneWithWhereWithoutOrder_itemsInput = {
    where?: ordersWhereInput
    data: XOR<ordersUpdateWithoutOrder_itemsInput, ordersUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type ordersUpdateWithoutOrder_itemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: customersUpdateOneWithoutOrdersNestedInput
    logistic?: logisticUpdateOneWithoutOrdersNestedInput
    store?: storeUpdateOneWithoutOrdersNestedInput
    return_refund?: return_refundUpdateOneWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateWithoutOrder_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    logisticId?: NullableIntFieldUpdateOperationsInput | number | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    return_refund?: return_refundUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type productsUpsertWithoutOrder_itemsInput = {
    update: XOR<productsUpdateWithoutOrder_itemsInput, productsUncheckedUpdateWithoutOrder_itemsInput>
    create: XOR<productsCreateWithoutOrder_itemsInput, productsUncheckedCreateWithoutOrder_itemsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutOrder_itemsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutOrder_itemsInput, productsUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type productsUpdateWithoutOrder_itemsInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateOneWithoutProductsNestedInput
    product_img?: products_imgUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutOrder_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    product_img?: products_imgUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type return_line_itemUpsertWithWhereUniqueWithoutItemInput = {
    where: return_line_itemWhereUniqueInput
    update: XOR<return_line_itemUpdateWithoutItemInput, return_line_itemUncheckedUpdateWithoutItemInput>
    create: XOR<return_line_itemCreateWithoutItemInput, return_line_itemUncheckedCreateWithoutItemInput>
  }

  export type return_line_itemUpdateWithWhereUniqueWithoutItemInput = {
    where: return_line_itemWhereUniqueInput
    data: XOR<return_line_itemUpdateWithoutItemInput, return_line_itemUncheckedUpdateWithoutItemInput>
  }

  export type return_line_itemUpdateManyWithWhereWithoutItemInput = {
    where: return_line_itemScalarWhereInput
    data: XOR<return_line_itemUpdateManyMutationInput, return_line_itemUncheckedUpdateManyWithoutItemInput>
  }

  export type return_line_itemScalarWhereInput = {
    AND?: return_line_itemScalarWhereInput | return_line_itemScalarWhereInput[]
    OR?: return_line_itemScalarWhereInput[]
    NOT?: return_line_itemScalarWhereInput | return_line_itemScalarWhereInput[]
    id?: IntFilter<"return_line_item"> | number
    origin_id?: StringNullableFilter<"return_line_item"> | string | null
    refund_service_fee?: IntFilter<"return_line_item"> | number
    currency?: StringNullableFilter<"return_line_item"> | string | null
    refund_subtotal?: IntFilter<"return_line_item"> | number
    refund_total?: IntFilter<"return_line_item"> | number
    order_itemsId?: IntFilter<"return_line_item"> | number
    return_refundId?: IntNullableFilter<"return_line_item"> | number | null
  }

  export type ordersCreateWithoutLogisticInput = {
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    order_items?: order_itemsCreateNestedManyWithoutOrdersInput
    customers?: customersCreateNestedOneWithoutOrdersInput
    store?: storeCreateNestedOneWithoutOrdersInput
    return_refund?: return_refundCreateNestedOneWithoutOrderInput
  }

  export type ordersUncheckedCreateWithoutLogisticInput = {
    id?: number
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    storeId?: number | null
    customersId?: number | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    order_items?: order_itemsUncheckedCreateNestedManyWithoutOrdersInput
    return_refund?: return_refundUncheckedCreateNestedOneWithoutOrderInput
  }

  export type ordersCreateOrConnectWithoutLogisticInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutLogisticInput, ordersUncheckedCreateWithoutLogisticInput>
  }

  export type ordersCreateManyLogisticInputEnvelope = {
    data: ordersCreateManyLogisticInput | ordersCreateManyLogisticInput[]
    skipDuplicates?: boolean
  }

  export type ordersUpsertWithWhereUniqueWithoutLogisticInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutLogisticInput, ordersUncheckedUpdateWithoutLogisticInput>
    create: XOR<ordersCreateWithoutLogisticInput, ordersUncheckedCreateWithoutLogisticInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutLogisticInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutLogisticInput, ordersUncheckedUpdateWithoutLogisticInput>
  }

  export type ordersUpdateManyWithWhereWithoutLogisticInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutLogisticInput>
  }

  export type order_itemsCreateWithoutOrdersInput = {
    createdAt?: Date | string
    qty: number
    package_id?: string | null
    invoice?: string | null
    total_price: number
    notes?: string | null
    origin_id?: string | null
    products?: productsCreateNestedOneWithoutOrder_itemsInput
    return_line_item?: return_line_itemCreateNestedManyWithoutItemInput
  }

  export type order_itemsUncheckedCreateWithoutOrdersInput = {
    id?: number
    createdAt?: Date | string
    qty: number
    package_id?: string | null
    invoice?: string | null
    total_price: number
    notes?: string | null
    productsId?: number | null
    origin_id?: string | null
    return_line_item?: return_line_itemUncheckedCreateNestedManyWithoutItemInput
  }

  export type order_itemsCreateOrConnectWithoutOrdersInput = {
    where: order_itemsWhereUniqueInput
    create: XOR<order_itemsCreateWithoutOrdersInput, order_itemsUncheckedCreateWithoutOrdersInput>
  }

  export type order_itemsCreateManyOrdersInputEnvelope = {
    data: order_itemsCreateManyOrdersInput | order_itemsCreateManyOrdersInput[]
    skipDuplicates?: boolean
  }

  export type customersCreateWithoutOrdersInput = {
    name?: string | null
    origin_id?: string | null
    phone?: string | null
    email?: string | null
  }

  export type customersUncheckedCreateWithoutOrdersInput = {
    id?: number
    name?: string | null
    origin_id?: string | null
    phone?: string | null
    email?: string | null
  }

  export type customersCreateOrConnectWithoutOrdersInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
  }

  export type logisticCreateWithoutOrdersInput = {
    name?: string | null
    type?: string | null
  }

  export type logisticUncheckedCreateWithoutOrdersInput = {
    id?: number
    name?: string | null
    type?: string | null
  }

  export type logisticCreateOrConnectWithoutOrdersInput = {
    where: logisticWhereUniqueInput
    create: XOR<logisticCreateWithoutOrdersInput, logisticUncheckedCreateWithoutOrdersInput>
  }

  export type storeCreateWithoutOrdersInput = {
    name?: string | null
    origin_id?: string | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
    omnichat?: omnichatCreateNestedManyWithoutStoreInput
    products?: productsCreateNestedManyWithoutStoreInput
    channel?: channelCreateNestedOneWithoutStoreInput
  }

  export type storeUncheckedCreateWithoutOrdersInput = {
    id?: number
    name?: string | null
    origin_id?: string | null
    channelId?: number | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
    omnichat?: omnichatUncheckedCreateNestedManyWithoutStoreInput
    products?: productsUncheckedCreateNestedManyWithoutStoreInput
  }

  export type storeCreateOrConnectWithoutOrdersInput = {
    where: storeWhereUniqueInput
    create: XOR<storeCreateWithoutOrdersInput, storeUncheckedCreateWithoutOrdersInput>
  }

  export type return_refundCreateWithoutOrderInput = {
    origin_id?: string | null
    status?: string | null
    total_amount: number
    return_type?: string | null
    return_reason?: string | null
    line_item?: return_line_itemCreateNestedManyWithoutReturn_refundInput
  }

  export type return_refundUncheckedCreateWithoutOrderInput = {
    id?: number
    origin_id?: string | null
    status?: string | null
    total_amount: number
    return_type?: string | null
    return_reason?: string | null
    line_item?: return_line_itemUncheckedCreateNestedManyWithoutReturn_refundInput
  }

  export type return_refundCreateOrConnectWithoutOrderInput = {
    where: return_refundWhereUniqueInput
    create: XOR<return_refundCreateWithoutOrderInput, return_refundUncheckedCreateWithoutOrderInput>
  }

  export type order_itemsUpsertWithWhereUniqueWithoutOrdersInput = {
    where: order_itemsWhereUniqueInput
    update: XOR<order_itemsUpdateWithoutOrdersInput, order_itemsUncheckedUpdateWithoutOrdersInput>
    create: XOR<order_itemsCreateWithoutOrdersInput, order_itemsUncheckedCreateWithoutOrdersInput>
  }

  export type order_itemsUpdateWithWhereUniqueWithoutOrdersInput = {
    where: order_itemsWhereUniqueInput
    data: XOR<order_itemsUpdateWithoutOrdersInput, order_itemsUncheckedUpdateWithoutOrdersInput>
  }

  export type order_itemsUpdateManyWithWhereWithoutOrdersInput = {
    where: order_itemsScalarWhereInput
    data: XOR<order_itemsUpdateManyMutationInput, order_itemsUncheckedUpdateManyWithoutOrdersInput>
  }

  export type customersUpsertWithoutOrdersInput = {
    update: XOR<customersUpdateWithoutOrdersInput, customersUncheckedUpdateWithoutOrdersInput>
    create: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
    where?: customersWhereInput
  }

  export type customersUpdateToOneWithWhereWithoutOrdersInput = {
    where?: customersWhereInput
    data: XOR<customersUpdateWithoutOrdersInput, customersUncheckedUpdateWithoutOrdersInput>
  }

  export type customersUpdateWithoutOrdersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customersUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logisticUpsertWithoutOrdersInput = {
    update: XOR<logisticUpdateWithoutOrdersInput, logisticUncheckedUpdateWithoutOrdersInput>
    create: XOR<logisticCreateWithoutOrdersInput, logisticUncheckedCreateWithoutOrdersInput>
    where?: logisticWhereInput
  }

  export type logisticUpdateToOneWithWhereWithoutOrdersInput = {
    where?: logisticWhereInput
    data: XOR<logisticUpdateWithoutOrdersInput, logisticUncheckedUpdateWithoutOrdersInput>
  }

  export type logisticUpdateWithoutOrdersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type logisticUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type storeUpsertWithoutOrdersInput = {
    update: XOR<storeUpdateWithoutOrdersInput, storeUncheckedUpdateWithoutOrdersInput>
    create: XOR<storeCreateWithoutOrdersInput, storeUncheckedCreateWithoutOrdersInput>
    where?: storeWhereInput
  }

  export type storeUpdateToOneWithWhereWithoutOrdersInput = {
    where?: storeWhereInput
    data: XOR<storeUpdateWithoutOrdersInput, storeUncheckedUpdateWithoutOrdersInput>
  }

  export type storeUpdateWithoutOrdersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUpdateManyWithoutStoreNestedInput
    products?: productsUpdateManyWithoutStoreNestedInput
    channel?: channelUpdateOneWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableIntFieldUpdateOperationsInput | number | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUncheckedUpdateManyWithoutStoreNestedInput
    products?: productsUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type return_refundUpsertWithoutOrderInput = {
    update: XOR<return_refundUpdateWithoutOrderInput, return_refundUncheckedUpdateWithoutOrderInput>
    create: XOR<return_refundCreateWithoutOrderInput, return_refundUncheckedCreateWithoutOrderInput>
    where?: return_refundWhereInput
  }

  export type return_refundUpdateToOneWithWhereWithoutOrderInput = {
    where?: return_refundWhereInput
    data: XOR<return_refundUpdateWithoutOrderInput, return_refundUncheckedUpdateWithoutOrderInput>
  }

  export type return_refundUpdateWithoutOrderInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: IntFieldUpdateOperationsInput | number
    return_type?: NullableStringFieldUpdateOperationsInput | string | null
    return_reason?: NullableStringFieldUpdateOperationsInput | string | null
    line_item?: return_line_itemUpdateManyWithoutReturn_refundNestedInput
  }

  export type return_refundUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: IntFieldUpdateOperationsInput | number
    return_type?: NullableStringFieldUpdateOperationsInput | string | null
    return_reason?: NullableStringFieldUpdateOperationsInput | string | null
    line_item?: return_line_itemUncheckedUpdateManyWithoutReturn_refundNestedInput
  }

  export type omnichatCreateWithoutOmnichat_userInput = {
    origin_id?: string | null
    last_message: string
    last_messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    externalId?: string | null
    store?: storeCreateNestedOneWithoutOmnichatInput
    messages?: omnichat_lineCreateNestedManyWithoutOmnichatInput
  }

  export type omnichatUncheckedCreateWithoutOmnichat_userInput = {
    id?: number
    origin_id?: string | null
    last_message: string
    last_messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId?: number | null
    externalId?: string | null
    messages?: omnichat_lineUncheckedCreateNestedManyWithoutOmnichatInput
  }

  export type omnichatCreateOrConnectWithoutOmnichat_userInput = {
    where: omnichatWhereUniqueInput
    create: XOR<omnichatCreateWithoutOmnichat_userInput, omnichatUncheckedCreateWithoutOmnichat_userInput>
  }

  export type omnichatCreateManyOmnichat_userInputEnvelope = {
    data: omnichatCreateManyOmnichat_userInput | omnichatCreateManyOmnichat_userInput[]
    skipDuplicates?: boolean
  }

  export type omnichat_lineCreateWithoutOmnichat_userInput = {
    origin_id?: string | null
    createdAt?: Date | string
    line_text: string
    author?: string | null
    chat_type?: string | null
    omnichat?: omnichatCreateNestedOneWithoutMessagesInput
  }

  export type omnichat_lineUncheckedCreateWithoutOmnichat_userInput = {
    id?: number
    origin_id?: string | null
    createdAt?: Date | string
    line_text: string
    omnichatId?: number | null
    author?: string | null
    chat_type?: string | null
  }

  export type omnichat_lineCreateOrConnectWithoutOmnichat_userInput = {
    where: omnichat_lineWhereUniqueInput
    create: XOR<omnichat_lineCreateWithoutOmnichat_userInput, omnichat_lineUncheckedCreateWithoutOmnichat_userInput>
  }

  export type omnichat_lineCreateManyOmnichat_userInputEnvelope = {
    data: omnichat_lineCreateManyOmnichat_userInput | omnichat_lineCreateManyOmnichat_userInput[]
    skipDuplicates?: boolean
  }

  export type omnichatUpsertWithWhereUniqueWithoutOmnichat_userInput = {
    where: omnichatWhereUniqueInput
    update: XOR<omnichatUpdateWithoutOmnichat_userInput, omnichatUncheckedUpdateWithoutOmnichat_userInput>
    create: XOR<omnichatCreateWithoutOmnichat_userInput, omnichatUncheckedCreateWithoutOmnichat_userInput>
  }

  export type omnichatUpdateWithWhereUniqueWithoutOmnichat_userInput = {
    where: omnichatWhereUniqueInput
    data: XOR<omnichatUpdateWithoutOmnichat_userInput, omnichatUncheckedUpdateWithoutOmnichat_userInput>
  }

  export type omnichatUpdateManyWithWhereWithoutOmnichat_userInput = {
    where: omnichatScalarWhereInput
    data: XOR<omnichatUpdateManyMutationInput, omnichatUncheckedUpdateManyWithoutOmnichat_userInput>
  }

  export type omnichat_lineUpsertWithWhereUniqueWithoutOmnichat_userInput = {
    where: omnichat_lineWhereUniqueInput
    update: XOR<omnichat_lineUpdateWithoutOmnichat_userInput, omnichat_lineUncheckedUpdateWithoutOmnichat_userInput>
    create: XOR<omnichat_lineCreateWithoutOmnichat_userInput, omnichat_lineUncheckedCreateWithoutOmnichat_userInput>
  }

  export type omnichat_lineUpdateWithWhereUniqueWithoutOmnichat_userInput = {
    where: omnichat_lineWhereUniqueInput
    data: XOR<omnichat_lineUpdateWithoutOmnichat_userInput, omnichat_lineUncheckedUpdateWithoutOmnichat_userInput>
  }

  export type omnichat_lineUpdateManyWithWhereWithoutOmnichat_userInput = {
    where: omnichat_lineScalarWhereInput
    data: XOR<omnichat_lineUpdateManyMutationInput, omnichat_lineUncheckedUpdateManyWithoutOmnichat_userInput>
  }

  export type omnichat_lineScalarWhereInput = {
    AND?: omnichat_lineScalarWhereInput | omnichat_lineScalarWhereInput[]
    OR?: omnichat_lineScalarWhereInput[]
    NOT?: omnichat_lineScalarWhereInput | omnichat_lineScalarWhereInput[]
    id?: IntFilter<"omnichat_line"> | number
    origin_id?: StringNullableFilter<"omnichat_line"> | string | null
    createdAt?: DateTimeFilter<"omnichat_line"> | Date | string
    line_text?: StringFilter<"omnichat_line"> | string
    omnichatId?: IntNullableFilter<"omnichat_line"> | number | null
    author?: StringNullableFilter<"omnichat_line"> | string | null
    omnichat_userId?: IntNullableFilter<"omnichat_line"> | number | null
    chat_type?: StringNullableFilter<"omnichat_line"> | string | null
  }

  export type omnichat_userCreateWithoutOmnichatInput = {
    username?: string | null
    thumbnailUrl?: string | null
    origin_id?: string | null
    createdAt?: Date | string
    externalId?: string | null
    omnichat_line?: omnichat_lineCreateNestedManyWithoutOmnichat_userInput
  }

  export type omnichat_userUncheckedCreateWithoutOmnichatInput = {
    id?: number
    username?: string | null
    thumbnailUrl?: string | null
    origin_id?: string | null
    createdAt?: Date | string
    externalId?: string | null
    omnichat_line?: omnichat_lineUncheckedCreateNestedManyWithoutOmnichat_userInput
  }

  export type omnichat_userCreateOrConnectWithoutOmnichatInput = {
    where: omnichat_userWhereUniqueInput
    create: XOR<omnichat_userCreateWithoutOmnichatInput, omnichat_userUncheckedCreateWithoutOmnichatInput>
  }

  export type storeCreateWithoutOmnichatInput = {
    name?: string | null
    origin_id?: string | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
    orders?: ordersCreateNestedManyWithoutStoreInput
    products?: productsCreateNestedManyWithoutStoreInput
    channel?: channelCreateNestedOneWithoutStoreInput
  }

  export type storeUncheckedCreateWithoutOmnichatInput = {
    id?: number
    name?: string | null
    origin_id?: string | null
    channelId?: number | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
    orders?: ordersUncheckedCreateNestedManyWithoutStoreInput
    products?: productsUncheckedCreateNestedManyWithoutStoreInput
  }

  export type storeCreateOrConnectWithoutOmnichatInput = {
    where: storeWhereUniqueInput
    create: XOR<storeCreateWithoutOmnichatInput, storeUncheckedCreateWithoutOmnichatInput>
  }

  export type omnichat_lineCreateWithoutOmnichatInput = {
    origin_id?: string | null
    createdAt?: Date | string
    line_text: string
    author?: string | null
    chat_type?: string | null
    omnichat_user?: omnichat_userCreateNestedOneWithoutOmnichat_lineInput
  }

  export type omnichat_lineUncheckedCreateWithoutOmnichatInput = {
    id?: number
    origin_id?: string | null
    createdAt?: Date | string
    line_text: string
    author?: string | null
    omnichat_userId?: number | null
    chat_type?: string | null
  }

  export type omnichat_lineCreateOrConnectWithoutOmnichatInput = {
    where: omnichat_lineWhereUniqueInput
    create: XOR<omnichat_lineCreateWithoutOmnichatInput, omnichat_lineUncheckedCreateWithoutOmnichatInput>
  }

  export type omnichat_lineCreateManyOmnichatInputEnvelope = {
    data: omnichat_lineCreateManyOmnichatInput | omnichat_lineCreateManyOmnichatInput[]
    skipDuplicates?: boolean
  }

  export type omnichat_userUpsertWithoutOmnichatInput = {
    update: XOR<omnichat_userUpdateWithoutOmnichatInput, omnichat_userUncheckedUpdateWithoutOmnichatInput>
    create: XOR<omnichat_userCreateWithoutOmnichatInput, omnichat_userUncheckedCreateWithoutOmnichatInput>
    where?: omnichat_userWhereInput
  }

  export type omnichat_userUpdateToOneWithWhereWithoutOmnichatInput = {
    where?: omnichat_userWhereInput
    data: XOR<omnichat_userUpdateWithoutOmnichatInput, omnichat_userUncheckedUpdateWithoutOmnichatInput>
  }

  export type omnichat_userUpdateWithoutOmnichatInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat_line?: omnichat_lineUpdateManyWithoutOmnichat_userNestedInput
  }

  export type omnichat_userUncheckedUpdateWithoutOmnichatInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat_line?: omnichat_lineUncheckedUpdateManyWithoutOmnichat_userNestedInput
  }

  export type storeUpsertWithoutOmnichatInput = {
    update: XOR<storeUpdateWithoutOmnichatInput, storeUncheckedUpdateWithoutOmnichatInput>
    create: XOR<storeCreateWithoutOmnichatInput, storeUncheckedCreateWithoutOmnichatInput>
    where?: storeWhereInput
  }

  export type storeUpdateToOneWithWhereWithoutOmnichatInput = {
    where?: storeWhereInput
    data: XOR<storeUpdateWithoutOmnichatInput, storeUncheckedUpdateWithoutOmnichatInput>
  }

  export type storeUpdateWithoutOmnichatInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUpdateManyWithoutStoreNestedInput
    products?: productsUpdateManyWithoutStoreNestedInput
    channel?: channelUpdateOneWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateWithoutOmnichatInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableIntFieldUpdateOperationsInput | number | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUncheckedUpdateManyWithoutStoreNestedInput
    products?: productsUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type omnichat_lineUpsertWithWhereUniqueWithoutOmnichatInput = {
    where: omnichat_lineWhereUniqueInput
    update: XOR<omnichat_lineUpdateWithoutOmnichatInput, omnichat_lineUncheckedUpdateWithoutOmnichatInput>
    create: XOR<omnichat_lineCreateWithoutOmnichatInput, omnichat_lineUncheckedCreateWithoutOmnichatInput>
  }

  export type omnichat_lineUpdateWithWhereUniqueWithoutOmnichatInput = {
    where: omnichat_lineWhereUniqueInput
    data: XOR<omnichat_lineUpdateWithoutOmnichatInput, omnichat_lineUncheckedUpdateWithoutOmnichatInput>
  }

  export type omnichat_lineUpdateManyWithWhereWithoutOmnichatInput = {
    where: omnichat_lineScalarWhereInput
    data: XOR<omnichat_lineUpdateManyMutationInput, omnichat_lineUncheckedUpdateManyWithoutOmnichatInput>
  }

  export type omnichatCreateWithoutMessagesInput = {
    origin_id?: string | null
    last_message: string
    last_messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    externalId?: string | null
    omnichat_user?: omnichat_userCreateNestedOneWithoutOmnichatInput
    store?: storeCreateNestedOneWithoutOmnichatInput
  }

  export type omnichatUncheckedCreateWithoutMessagesInput = {
    id?: number
    origin_id?: string | null
    last_message: string
    last_messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId?: number | null
    omnichat_userId?: number | null
    externalId?: string | null
  }

  export type omnichatCreateOrConnectWithoutMessagesInput = {
    where: omnichatWhereUniqueInput
    create: XOR<omnichatCreateWithoutMessagesInput, omnichatUncheckedCreateWithoutMessagesInput>
  }

  export type omnichat_userCreateWithoutOmnichat_lineInput = {
    username?: string | null
    thumbnailUrl?: string | null
    origin_id?: string | null
    createdAt?: Date | string
    externalId?: string | null
    omnichat?: omnichatCreateNestedManyWithoutOmnichat_userInput
  }

  export type omnichat_userUncheckedCreateWithoutOmnichat_lineInput = {
    id?: number
    username?: string | null
    thumbnailUrl?: string | null
    origin_id?: string | null
    createdAt?: Date | string
    externalId?: string | null
    omnichat?: omnichatUncheckedCreateNestedManyWithoutOmnichat_userInput
  }

  export type omnichat_userCreateOrConnectWithoutOmnichat_lineInput = {
    where: omnichat_userWhereUniqueInput
    create: XOR<omnichat_userCreateWithoutOmnichat_lineInput, omnichat_userUncheckedCreateWithoutOmnichat_lineInput>
  }

  export type omnichatUpsertWithoutMessagesInput = {
    update: XOR<omnichatUpdateWithoutMessagesInput, omnichatUncheckedUpdateWithoutMessagesInput>
    create: XOR<omnichatCreateWithoutMessagesInput, omnichatUncheckedCreateWithoutMessagesInput>
    where?: omnichatWhereInput
  }

  export type omnichatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: omnichatWhereInput
    data: XOR<omnichatUpdateWithoutMessagesInput, omnichatUncheckedUpdateWithoutMessagesInput>
  }

  export type omnichatUpdateWithoutMessagesInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat_user?: omnichat_userUpdateOneWithoutOmnichatNestedInput
    store?: storeUpdateOneWithoutOmnichatNestedInput
  }

  export type omnichatUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    omnichat_userId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichat_userUpsertWithoutOmnichat_lineInput = {
    update: XOR<omnichat_userUpdateWithoutOmnichat_lineInput, omnichat_userUncheckedUpdateWithoutOmnichat_lineInput>
    create: XOR<omnichat_userCreateWithoutOmnichat_lineInput, omnichat_userUncheckedCreateWithoutOmnichat_lineInput>
    where?: omnichat_userWhereInput
  }

  export type omnichat_userUpdateToOneWithWhereWithoutOmnichat_lineInput = {
    where?: omnichat_userWhereInput
    data: XOR<omnichat_userUpdateWithoutOmnichat_lineInput, omnichat_userUncheckedUpdateWithoutOmnichat_lineInput>
  }

  export type omnichat_userUpdateWithoutOmnichat_lineInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUpdateManyWithoutOmnichat_userNestedInput
  }

  export type omnichat_userUncheckedUpdateWithoutOmnichat_lineInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUncheckedUpdateManyWithoutOmnichat_userNestedInput
  }

  export type channelCreateWithoutClientInput = {
    name?: string | null
    store?: storeCreateNestedManyWithoutChannelInput
  }

  export type channelUncheckedCreateWithoutClientInput = {
    id?: number
    name?: string | null
    store?: storeUncheckedCreateNestedManyWithoutChannelInput
  }

  export type channelCreateOrConnectWithoutClientInput = {
    where: channelWhereUniqueInput
    create: XOR<channelCreateWithoutClientInput, channelUncheckedCreateWithoutClientInput>
  }

  export type channelCreateManyClientInputEnvelope = {
    data: channelCreateManyClientInput | channelCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type integrationCreateWithoutClientsInput = {
    name?: string | null
    baseUrl?: string | null
    f_chat?: boolean | null
    f_review?: boolean | null
    f_cancel?: boolean | null
    f_rr?: boolean | null
    status?: string | null
    notes?: string | null
    credent?: credentCreateNestedManyWithoutIntegrationInput
  }

  export type integrationUncheckedCreateWithoutClientsInput = {
    id?: number
    name?: string | null
    baseUrl?: string | null
    f_chat?: boolean | null
    f_review?: boolean | null
    f_cancel?: boolean | null
    f_rr?: boolean | null
    status?: string | null
    notes?: string | null
    credent?: credentUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type integrationCreateOrConnectWithoutClientsInput = {
    where: integrationWhereUniqueInput
    create: XOR<integrationCreateWithoutClientsInput, integrationUncheckedCreateWithoutClientsInput>
  }

  export type integrationCreateManyClientsInputEnvelope = {
    data: integrationCreateManyClientsInput | integrationCreateManyClientsInput[]
    skipDuplicates?: boolean
  }

  export type channelUpsertWithWhereUniqueWithoutClientInput = {
    where: channelWhereUniqueInput
    update: XOR<channelUpdateWithoutClientInput, channelUncheckedUpdateWithoutClientInput>
    create: XOR<channelCreateWithoutClientInput, channelUncheckedCreateWithoutClientInput>
  }

  export type channelUpdateWithWhereUniqueWithoutClientInput = {
    where: channelWhereUniqueInput
    data: XOR<channelUpdateWithoutClientInput, channelUncheckedUpdateWithoutClientInput>
  }

  export type channelUpdateManyWithWhereWithoutClientInput = {
    where: channelScalarWhereInput
    data: XOR<channelUpdateManyMutationInput, channelUncheckedUpdateManyWithoutClientInput>
  }

  export type channelScalarWhereInput = {
    AND?: channelScalarWhereInput | channelScalarWhereInput[]
    OR?: channelScalarWhereInput[]
    NOT?: channelScalarWhereInput | channelScalarWhereInput[]
    id?: IntFilter<"channel"> | number
    name?: StringNullableFilter<"channel"> | string | null
    clientsId?: IntNullableFilter<"channel"> | number | null
  }

  export type integrationUpsertWithWhereUniqueWithoutClientsInput = {
    where: integrationWhereUniqueInput
    update: XOR<integrationUpdateWithoutClientsInput, integrationUncheckedUpdateWithoutClientsInput>
    create: XOR<integrationCreateWithoutClientsInput, integrationUncheckedCreateWithoutClientsInput>
  }

  export type integrationUpdateWithWhereUniqueWithoutClientsInput = {
    where: integrationWhereUniqueInput
    data: XOR<integrationUpdateWithoutClientsInput, integrationUncheckedUpdateWithoutClientsInput>
  }

  export type integrationUpdateManyWithWhereWithoutClientsInput = {
    where: integrationScalarWhereInput
    data: XOR<integrationUpdateManyMutationInput, integrationUncheckedUpdateManyWithoutClientsInput>
  }

  export type integrationScalarWhereInput = {
    AND?: integrationScalarWhereInput | integrationScalarWhereInput[]
    OR?: integrationScalarWhereInput[]
    NOT?: integrationScalarWhereInput | integrationScalarWhereInput[]
    id?: IntFilter<"integration"> | number
    name?: StringNullableFilter<"integration"> | string | null
    baseUrl?: StringNullableFilter<"integration"> | string | null
    f_chat?: BoolNullableFilter<"integration"> | boolean | null
    f_review?: BoolNullableFilter<"integration"> | boolean | null
    f_cancel?: BoolNullableFilter<"integration"> | boolean | null
    f_rr?: BoolNullableFilter<"integration"> | boolean | null
    status?: StringNullableFilter<"integration"> | string | null
    notes?: StringNullableFilter<"integration"> | string | null
    clientsId?: IntNullableFilter<"integration"> | number | null
  }

  export type integrationCreateWithoutCredentInput = {
    name?: string | null
    baseUrl?: string | null
    f_chat?: boolean | null
    f_review?: boolean | null
    f_cancel?: boolean | null
    f_rr?: boolean | null
    status?: string | null
    notes?: string | null
    clients?: clientsCreateNestedOneWithoutIntegrationInput
  }

  export type integrationUncheckedCreateWithoutCredentInput = {
    id?: number
    name?: string | null
    baseUrl?: string | null
    f_chat?: boolean | null
    f_review?: boolean | null
    f_cancel?: boolean | null
    f_rr?: boolean | null
    status?: string | null
    notes?: string | null
    clientsId?: number | null
  }

  export type integrationCreateOrConnectWithoutCredentInput = {
    where: integrationWhereUniqueInput
    create: XOR<integrationCreateWithoutCredentInput, integrationUncheckedCreateWithoutCredentInput>
  }

  export type integrationUpsertWithoutCredentInput = {
    update: XOR<integrationUpdateWithoutCredentInput, integrationUncheckedUpdateWithoutCredentInput>
    create: XOR<integrationCreateWithoutCredentInput, integrationUncheckedCreateWithoutCredentInput>
    where?: integrationWhereInput
  }

  export type integrationUpdateToOneWithWhereWithoutCredentInput = {
    where?: integrationWhereInput
    data: XOR<integrationUpdateWithoutCredentInput, integrationUncheckedUpdateWithoutCredentInput>
  }

  export type integrationUpdateWithoutCredentInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    f_chat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_cancel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_rr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: clientsUpdateOneWithoutIntegrationNestedInput
  }

  export type integrationUncheckedUpdateWithoutCredentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    f_chat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_cancel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_rr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    clientsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type credentCreateWithoutIntegrationInput = {
    key?: string | null
    value?: string | null
  }

  export type credentUncheckedCreateWithoutIntegrationInput = {
    id?: number
    key?: string | null
    value?: string | null
  }

  export type credentCreateOrConnectWithoutIntegrationInput = {
    where: credentWhereUniqueInput
    create: XOR<credentCreateWithoutIntegrationInput, credentUncheckedCreateWithoutIntegrationInput>
  }

  export type credentCreateManyIntegrationInputEnvelope = {
    data: credentCreateManyIntegrationInput | credentCreateManyIntegrationInput[]
    skipDuplicates?: boolean
  }

  export type clientsCreateWithoutIntegrationInput = {
    name: string
    origin_id?: string | null
    channel?: channelCreateNestedManyWithoutClientInput
  }

  export type clientsUncheckedCreateWithoutIntegrationInput = {
    id?: number
    name: string
    origin_id?: string | null
    channel?: channelUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientsCreateOrConnectWithoutIntegrationInput = {
    where: clientsWhereUniqueInput
    create: XOR<clientsCreateWithoutIntegrationInput, clientsUncheckedCreateWithoutIntegrationInput>
  }

  export type credentUpsertWithWhereUniqueWithoutIntegrationInput = {
    where: credentWhereUniqueInput
    update: XOR<credentUpdateWithoutIntegrationInput, credentUncheckedUpdateWithoutIntegrationInput>
    create: XOR<credentCreateWithoutIntegrationInput, credentUncheckedCreateWithoutIntegrationInput>
  }

  export type credentUpdateWithWhereUniqueWithoutIntegrationInput = {
    where: credentWhereUniqueInput
    data: XOR<credentUpdateWithoutIntegrationInput, credentUncheckedUpdateWithoutIntegrationInput>
  }

  export type credentUpdateManyWithWhereWithoutIntegrationInput = {
    where: credentScalarWhereInput
    data: XOR<credentUpdateManyMutationInput, credentUncheckedUpdateManyWithoutIntegrationInput>
  }

  export type credentScalarWhereInput = {
    AND?: credentScalarWhereInput | credentScalarWhereInput[]
    OR?: credentScalarWhereInput[]
    NOT?: credentScalarWhereInput | credentScalarWhereInput[]
    id?: IntFilter<"credent"> | number
    key?: StringNullableFilter<"credent"> | string | null
    value?: StringNullableFilter<"credent"> | string | null
    integrationId?: IntNullableFilter<"credent"> | number | null
  }

  export type clientsUpsertWithoutIntegrationInput = {
    update: XOR<clientsUpdateWithoutIntegrationInput, clientsUncheckedUpdateWithoutIntegrationInput>
    create: XOR<clientsCreateWithoutIntegrationInput, clientsUncheckedCreateWithoutIntegrationInput>
    where?: clientsWhereInput
  }

  export type clientsUpdateToOneWithWhereWithoutIntegrationInput = {
    where?: clientsWhereInput
    data: XOR<clientsUpdateWithoutIntegrationInput, clientsUncheckedUpdateWithoutIntegrationInput>
  }

  export type clientsUpdateWithoutIntegrationInput = {
    name?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: channelUpdateManyWithoutClientNestedInput
  }

  export type clientsUncheckedUpdateWithoutIntegrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: channelUncheckedUpdateManyWithoutClientNestedInput
  }

  export type order_itemsCreateWithoutReturn_line_itemInput = {
    createdAt?: Date | string
    qty: number
    package_id?: string | null
    invoice?: string | null
    total_price: number
    notes?: string | null
    origin_id?: string | null
    orders?: ordersCreateNestedOneWithoutOrder_itemsInput
    products?: productsCreateNestedOneWithoutOrder_itemsInput
  }

  export type order_itemsUncheckedCreateWithoutReturn_line_itemInput = {
    id?: number
    createdAt?: Date | string
    qty: number
    package_id?: string | null
    invoice?: string | null
    total_price: number
    notes?: string | null
    ordersId?: number | null
    productsId?: number | null
    origin_id?: string | null
  }

  export type order_itemsCreateOrConnectWithoutReturn_line_itemInput = {
    where: order_itemsWhereUniqueInput
    create: XOR<order_itemsCreateWithoutReturn_line_itemInput, order_itemsUncheckedCreateWithoutReturn_line_itemInput>
  }

  export type return_refundCreateWithoutLine_itemInput = {
    origin_id?: string | null
    status?: string | null
    total_amount: number
    return_type?: string | null
    return_reason?: string | null
    order: ordersCreateNestedOneWithoutReturn_refundInput
  }

  export type return_refundUncheckedCreateWithoutLine_itemInput = {
    id?: number
    origin_id?: string | null
    status?: string | null
    total_amount: number
    return_type?: string | null
    return_reason?: string | null
    ordersId: number
  }

  export type return_refundCreateOrConnectWithoutLine_itemInput = {
    where: return_refundWhereUniqueInput
    create: XOR<return_refundCreateWithoutLine_itemInput, return_refundUncheckedCreateWithoutLine_itemInput>
  }

  export type order_itemsUpsertWithoutReturn_line_itemInput = {
    update: XOR<order_itemsUpdateWithoutReturn_line_itemInput, order_itemsUncheckedUpdateWithoutReturn_line_itemInput>
    create: XOR<order_itemsCreateWithoutReturn_line_itemInput, order_itemsUncheckedCreateWithoutReturn_line_itemInput>
    where?: order_itemsWhereInput
  }

  export type order_itemsUpdateToOneWithWhereWithoutReturn_line_itemInput = {
    where?: order_itemsWhereInput
    data: XOR<order_itemsUpdateWithoutReturn_line_itemInput, order_itemsUncheckedUpdateWithoutReturn_line_itemInput>
  }

  export type order_itemsUpdateWithoutReturn_line_itemInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUpdateOneWithoutOrder_itemsNestedInput
    products?: productsUpdateOneWithoutOrder_itemsNestedInput
  }

  export type order_itemsUncheckedUpdateWithoutReturn_line_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ordersId?: NullableIntFieldUpdateOperationsInput | number | null
    productsId?: NullableIntFieldUpdateOperationsInput | number | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type return_refundUpsertWithoutLine_itemInput = {
    update: XOR<return_refundUpdateWithoutLine_itemInput, return_refundUncheckedUpdateWithoutLine_itemInput>
    create: XOR<return_refundCreateWithoutLine_itemInput, return_refundUncheckedCreateWithoutLine_itemInput>
    where?: return_refundWhereInput
  }

  export type return_refundUpdateToOneWithWhereWithoutLine_itemInput = {
    where?: return_refundWhereInput
    data: XOR<return_refundUpdateWithoutLine_itemInput, return_refundUncheckedUpdateWithoutLine_itemInput>
  }

  export type return_refundUpdateWithoutLine_itemInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: IntFieldUpdateOperationsInput | number
    return_type?: NullableStringFieldUpdateOperationsInput | string | null
    return_reason?: NullableStringFieldUpdateOperationsInput | string | null
    order?: ordersUpdateOneRequiredWithoutReturn_refundNestedInput
  }

  export type return_refundUncheckedUpdateWithoutLine_itemInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: IntFieldUpdateOperationsInput | number
    return_type?: NullableStringFieldUpdateOperationsInput | string | null
    return_reason?: NullableStringFieldUpdateOperationsInput | string | null
    ordersId?: IntFieldUpdateOperationsInput | number
  }

  export type ordersCreateWithoutReturn_refundInput = {
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    order_items?: order_itemsCreateNestedManyWithoutOrdersInput
    customers?: customersCreateNestedOneWithoutOrdersInput
    logistic?: logisticCreateNestedOneWithoutOrdersInput
    store?: storeCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutReturn_refundInput = {
    id?: number
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    storeId?: number | null
    customersId?: number | null
    logisticId?: number | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
    order_items?: order_itemsUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutReturn_refundInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutReturn_refundInput, ordersUncheckedCreateWithoutReturn_refundInput>
  }

  export type return_line_itemCreateWithoutReturn_refundInput = {
    origin_id?: string | null
    refund_service_fee: number
    currency?: string | null
    refund_subtotal: number
    refund_total: number
    item: order_itemsCreateNestedOneWithoutReturn_line_itemInput
  }

  export type return_line_itemUncheckedCreateWithoutReturn_refundInput = {
    id?: number
    origin_id?: string | null
    refund_service_fee: number
    currency?: string | null
    refund_subtotal: number
    refund_total: number
    order_itemsId: number
  }

  export type return_line_itemCreateOrConnectWithoutReturn_refundInput = {
    where: return_line_itemWhereUniqueInput
    create: XOR<return_line_itemCreateWithoutReturn_refundInput, return_line_itemUncheckedCreateWithoutReturn_refundInput>
  }

  export type return_line_itemCreateManyReturn_refundInputEnvelope = {
    data: return_line_itemCreateManyReturn_refundInput | return_line_itemCreateManyReturn_refundInput[]
    skipDuplicates?: boolean
  }

  export type ordersUpsertWithoutReturn_refundInput = {
    update: XOR<ordersUpdateWithoutReturn_refundInput, ordersUncheckedUpdateWithoutReturn_refundInput>
    create: XOR<ordersCreateWithoutReturn_refundInput, ordersUncheckedCreateWithoutReturn_refundInput>
    where?: ordersWhereInput
  }

  export type ordersUpdateToOneWithWhereWithoutReturn_refundInput = {
    where?: ordersWhereInput
    data: XOR<ordersUpdateWithoutReturn_refundInput, ordersUncheckedUpdateWithoutReturn_refundInput>
  }

  export type ordersUpdateWithoutReturn_refundInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUpdateManyWithoutOrdersNestedInput
    customers?: customersUpdateOneWithoutOrdersNestedInput
    logistic?: logisticUpdateOneWithoutOrdersNestedInput
    store?: storeUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutReturn_refundInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    logisticId?: NullableIntFieldUpdateOperationsInput | number | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type return_line_itemUpsertWithWhereUniqueWithoutReturn_refundInput = {
    where: return_line_itemWhereUniqueInput
    update: XOR<return_line_itemUpdateWithoutReturn_refundInput, return_line_itemUncheckedUpdateWithoutReturn_refundInput>
    create: XOR<return_line_itemCreateWithoutReturn_refundInput, return_line_itemUncheckedCreateWithoutReturn_refundInput>
  }

  export type return_line_itemUpdateWithWhereUniqueWithoutReturn_refundInput = {
    where: return_line_itemWhereUniqueInput
    data: XOR<return_line_itemUpdateWithoutReturn_refundInput, return_line_itemUncheckedUpdateWithoutReturn_refundInput>
  }

  export type return_line_itemUpdateManyWithWhereWithoutReturn_refundInput = {
    where: return_line_itemScalarWhereInput
    data: XOR<return_line_itemUpdateManyMutationInput, return_line_itemUncheckedUpdateManyWithoutReturn_refundInput>
  }

  export type ordersCreateManyCustomersInput = {
    id?: number
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    storeId?: number | null
    logisticId?: number | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
  }

  export type ordersUpdateWithoutCustomersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUpdateManyWithoutOrdersNestedInput
    logistic?: logisticUpdateOneWithoutOrdersNestedInput
    store?: storeUpdateOneWithoutOrdersNestedInput
    return_refund?: return_refundUpdateOneWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    logisticId?: NullableIntFieldUpdateOperationsInput | number | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUncheckedUpdateManyWithoutOrdersNestedInput
    return_refund?: return_refundUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    logisticId?: NullableIntFieldUpdateOperationsInput | number | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type storeCreateManyChannelInput = {
    id?: number
    name?: string | null
    origin_id?: string | null
    refresh_token?: string | null
    token?: string | null
    secondary_refresh_token?: string | null
    secondary_token?: string | null
    url?: string | null
    status?: string | null
  }

  export type storeUpdateWithoutChannelInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUpdateManyWithoutStoreNestedInput
    orders?: ordersUpdateManyWithoutStoreNestedInput
    products?: productsUpdateManyWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUncheckedUpdateManyWithoutStoreNestedInput
    orders?: ordersUncheckedUpdateManyWithoutStoreNestedInput
    products?: productsUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateManyWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    secondary_token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichatCreateManyStoreInput = {
    id?: number
    origin_id?: string | null
    last_message: string
    last_messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    omnichat_userId?: number | null
    externalId?: string | null
  }

  export type ordersCreateManyStoreInput = {
    id?: number
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    customersId?: number | null
    logisticId?: number | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
  }

  export type productsCreateManyStoreInput = {
    id?: number
    origin_id?: string | null
    status?: string | null
    name?: string | null
    condition?: number | null
    desc?: string | null
    category?: number | null
    price?: number | null
    currency?: string | null
    createdAt?: Date | string
    weight?: number | null
    stock?: number | null
    sku?: string | null
  }

  export type omnichatUpdateWithoutStoreInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat_user?: omnichat_userUpdateOneWithoutOmnichatNestedInput
    messages?: omnichat_lineUpdateManyWithoutOmnichatNestedInput
  }

  export type omnichatUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    omnichat_userId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: omnichat_lineUncheckedUpdateManyWithoutOmnichatNestedInput
  }

  export type omnichatUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    omnichat_userId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ordersUpdateWithoutStoreInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUpdateManyWithoutOrdersNestedInput
    customers?: customersUpdateOneWithoutOrdersNestedInput
    logistic?: logisticUpdateOneWithoutOrdersNestedInput
    return_refund?: return_refundUpdateOneWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    logisticId?: NullableIntFieldUpdateOperationsInput | number | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUncheckedUpdateManyWithoutOrdersNestedInput
    return_refund?: return_refundUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    logisticId?: NullableIntFieldUpdateOperationsInput | number | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsUpdateWithoutStoreInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    order_items?: order_itemsUpdateManyWithoutProductsNestedInput
    product_img?: products_imgUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    order_items?: order_itemsUncheckedUpdateManyWithoutProductsNestedInput
    product_img?: products_imgUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type order_itemsCreateManyProductsInput = {
    id?: number
    createdAt?: Date | string
    qty: number
    package_id?: string | null
    invoice?: string | null
    total_price: number
    notes?: string | null
    ordersId?: number | null
    origin_id?: string | null
  }

  export type products_imgCreateManyProductsInput = {
    id?: number
    origin_id?: string | null
    filename?: string | null
    status?: string | null
    width?: number | null
    height?: number | null
    originalUrl?: string | null
    thumbnailUrl?: string | null
  }

  export type order_itemsUpdateWithoutProductsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUpdateOneWithoutOrder_itemsNestedInput
    return_line_item?: return_line_itemUpdateManyWithoutItemNestedInput
  }

  export type order_itemsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ordersId?: NullableIntFieldUpdateOperationsInput | number | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    return_line_item?: return_line_itemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type order_itemsUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ordersId?: NullableIntFieldUpdateOperationsInput | number | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type products_imgUpdateWithoutProductsInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    originalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type products_imgUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    originalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type products_imgUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    originalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type return_line_itemCreateManyItemInput = {
    id?: number
    origin_id?: string | null
    refund_service_fee: number
    currency?: string | null
    refund_subtotal: number
    refund_total: number
    return_refundId?: number | null
  }

  export type return_line_itemUpdateWithoutItemInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refund_service_fee?: IntFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    refund_subtotal?: IntFieldUpdateOperationsInput | number
    refund_total?: IntFieldUpdateOperationsInput | number
    return_refund?: return_refundUpdateOneWithoutLine_itemNestedInput
  }

  export type return_line_itemUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refund_service_fee?: IntFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    refund_subtotal?: IntFieldUpdateOperationsInput | number
    refund_total?: IntFieldUpdateOperationsInput | number
    return_refundId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type return_line_itemUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refund_service_fee?: IntFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    refund_subtotal?: IntFieldUpdateOperationsInput | number
    refund_total?: IntFieldUpdateOperationsInput | number
    return_refundId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ordersCreateManyLogisticInput = {
    id?: number
    createdAt?: Date | string
    status?: string | null
    shop_id?: string | null
    payment_id?: string | null
    temp_id?: string | null
    origin_id?: string | null
    package_id?: string | null
    invoice?: string | null
    recp_name?: string | null
    recp_phone?: string | null
    recp_addr_full?: string | null
    recp_addr_district?: string | null
    recp_addr_city?: string | null
    recp_addr_province?: string | null
    recp_addr_country?: string | null
    recp_addr_postal_code?: string | null
    recp_addr_district_id?: string | null
    recp_addr_city_id?: string | null
    tracking_number?: string | null
    ship_document_url?: string | null
    recp_addr_province_id?: string | null
    recp_addr_geo?: string | null
    logistic_service?: string | null
    origin_createdAt?: Date | string
    accept_partial?: boolean | null
    device?: string | null
    storeId?: number | null
    customersId?: number | null
    total_product_price?: number | null
    shipping_price?: number | null
    seller_discount?: number | null
    platform_discount?: number | null
    shipping_seller_discount?: number | null
    shipping_platform_discount?: number | null
    buyer_service_fee?: number | null
    handling_fee?: number | null
    shipping_insurance_fee?: number | null
    item_insurance_fee?: number | null
    total_amount?: number | null
    updatedAt?: Date | string
  }

  export type ordersUpdateWithoutLogisticInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUpdateManyWithoutOrdersNestedInput
    customers?: customersUpdateOneWithoutOrdersNestedInput
    store?: storeUpdateOneWithoutOrdersNestedInput
    return_refund?: return_refundUpdateOneWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateWithoutLogisticInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUncheckedUpdateManyWithoutOrdersNestedInput
    return_refund?: return_refundUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutLogisticInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    shop_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    temp_id?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    recp_name?: NullableStringFieldUpdateOperationsInput | string | null
    recp_phone?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_full?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_country?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_district_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_city_id?: NullableStringFieldUpdateOperationsInput | string | null
    tracking_number?: NullableStringFieldUpdateOperationsInput | string | null
    ship_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_province_id?: NullableStringFieldUpdateOperationsInput | string | null
    recp_addr_geo?: NullableStringFieldUpdateOperationsInput | string | null
    logistic_service?: NullableStringFieldUpdateOperationsInput | string | null
    origin_createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accept_partial?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    customersId?: NullableIntFieldUpdateOperationsInput | number | null
    total_product_price?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_price?: NullableIntFieldUpdateOperationsInput | number | null
    seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_seller_discount?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_platform_discount?: NullableIntFieldUpdateOperationsInput | number | null
    buyer_service_fee?: NullableIntFieldUpdateOperationsInput | number | null
    handling_fee?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    item_insurance_fee?: NullableIntFieldUpdateOperationsInput | number | null
    total_amount?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_itemsCreateManyOrdersInput = {
    id?: number
    createdAt?: Date | string
    qty: number
    package_id?: string | null
    invoice?: string | null
    total_price: number
    notes?: string | null
    productsId?: number | null
    origin_id?: string | null
  }

  export type order_itemsUpdateWithoutOrdersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    products?: productsUpdateOneWithoutOrder_itemsNestedInput
    return_line_item?: return_line_itemUpdateManyWithoutItemNestedInput
  }

  export type order_itemsUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    productsId?: NullableIntFieldUpdateOperationsInput | number | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    return_line_item?: return_line_itemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type order_itemsUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: IntFieldUpdateOperationsInput | number
    package_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    total_price?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    productsId?: NullableIntFieldUpdateOperationsInput | number | null
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichatCreateManyOmnichat_userInput = {
    id?: number
    origin_id?: string | null
    last_message: string
    last_messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    storeId?: number | null
    externalId?: string | null
  }

  export type omnichat_lineCreateManyOmnichat_userInput = {
    id?: number
    origin_id?: string | null
    createdAt?: Date | string
    line_text: string
    omnichatId?: number | null
    author?: string | null
    chat_type?: string | null
  }

  export type omnichatUpdateWithoutOmnichat_userInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateOneWithoutOmnichatNestedInput
    messages?: omnichat_lineUpdateManyWithoutOmnichatNestedInput
  }

  export type omnichatUncheckedUpdateWithoutOmnichat_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: omnichat_lineUncheckedUpdateManyWithoutOmnichatNestedInput
  }

  export type omnichatUncheckedUpdateManyWithoutOmnichat_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    last_message?: StringFieldUpdateOperationsInput | string
    last_messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichat_lineUpdateWithoutOmnichat_userInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    line_text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    chat_type?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat?: omnichatUpdateOneWithoutMessagesNestedInput
  }

  export type omnichat_lineUncheckedUpdateWithoutOmnichat_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    line_text?: StringFieldUpdateOperationsInput | string
    omnichatId?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    chat_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichat_lineUncheckedUpdateManyWithoutOmnichat_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    line_text?: StringFieldUpdateOperationsInput | string
    omnichatId?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    chat_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichat_lineCreateManyOmnichatInput = {
    id?: number
    origin_id?: string | null
    createdAt?: Date | string
    line_text: string
    author?: string | null
    omnichat_userId?: number | null
    chat_type?: string | null
  }

  export type omnichat_lineUpdateWithoutOmnichatInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    line_text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    chat_type?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat_user?: omnichat_userUpdateOneWithoutOmnichat_lineNestedInput
  }

  export type omnichat_lineUncheckedUpdateWithoutOmnichatInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    line_text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat_userId?: NullableIntFieldUpdateOperationsInput | number | null
    chat_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type omnichat_lineUncheckedUpdateManyWithoutOmnichatInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    line_text?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    omnichat_userId?: NullableIntFieldUpdateOperationsInput | number | null
    chat_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type channelCreateManyClientInput = {
    id?: number
    name?: string | null
  }

  export type integrationCreateManyClientsInput = {
    id?: number
    name?: string | null
    baseUrl?: string | null
    f_chat?: boolean | null
    f_review?: boolean | null
    f_cancel?: boolean | null
    f_rr?: boolean | null
    status?: string | null
    notes?: string | null
  }

  export type channelUpdateWithoutClientInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateManyWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type integrationUpdateWithoutClientsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    f_chat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_cancel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_rr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    credent?: credentUpdateManyWithoutIntegrationNestedInput
  }

  export type integrationUncheckedUpdateWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    f_chat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_cancel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_rr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    credent?: credentUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type integrationUncheckedUpdateManyWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    f_chat?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_review?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_cancel?: NullableBoolFieldUpdateOperationsInput | boolean | null
    f_rr?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credentCreateManyIntegrationInput = {
    id?: number
    key?: string | null
    value?: string | null
  }

  export type credentUpdateWithoutIntegrationInput = {
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credentUncheckedUpdateWithoutIntegrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type credentUncheckedUpdateManyWithoutIntegrationInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type return_line_itemCreateManyReturn_refundInput = {
    id?: number
    origin_id?: string | null
    refund_service_fee: number
    currency?: string | null
    refund_subtotal: number
    refund_total: number
    order_itemsId: number
  }

  export type return_line_itemUpdateWithoutReturn_refundInput = {
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refund_service_fee?: IntFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    refund_subtotal?: IntFieldUpdateOperationsInput | number
    refund_total?: IntFieldUpdateOperationsInput | number
    item?: order_itemsUpdateOneRequiredWithoutReturn_line_itemNestedInput
  }

  export type return_line_itemUncheckedUpdateWithoutReturn_refundInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refund_service_fee?: IntFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    refund_subtotal?: IntFieldUpdateOperationsInput | number
    refund_total?: IntFieldUpdateOperationsInput | number
    order_itemsId?: IntFieldUpdateOperationsInput | number
  }

  export type return_line_itemUncheckedUpdateManyWithoutReturn_refundInput = {
    id?: IntFieldUpdateOperationsInput | number
    origin_id?: NullableStringFieldUpdateOperationsInput | string | null
    refund_service_fee?: IntFieldUpdateOperationsInput | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    refund_subtotal?: IntFieldUpdateOperationsInput | number
    refund_total?: IntFieldUpdateOperationsInput | number
    order_itemsId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}